{"version":3,"sources":["webpack:///./node_modules/inherits/inherits_browser.js","webpack:///./node_modules/uuid/lib/rng-browser.js","webpack:///./node_modules/uuid/lib/bytesToUuid.js","webpack:///./node_modules/util/util.js","webpack:///./node_modules/pouchdb/lib/index-browser.es.js","webpack:///./node_modules/argsarray/index.js","webpack:///./node_modules/immediate/lib/browser.js","webpack:///./node_modules/events/events.js","webpack:///./node_modules/spark-md5/spark-md5.js","webpack:///./node_modules/uuid/index.js","webpack:///./node_modules/uuid/v1.js","webpack:///./node_modules/uuid/v4.js","webpack:///./node_modules/vuvuzela/index.js","webpack:///./node_modules/util/support/isBufferBrowser.js"],"names":["Object","create","module","exports","ctor","superCtor","super_","prototype","constructor","value","enumerable","writable","configurable","TempCtor","getRandomValues","crypto","bind","msCrypto","rnds8","Uint8Array","rnds","Array","r","i","Math","random","byteToHex","toString","substr","buf","offset","bth","process","getOwnPropertyDescriptors","obj","keys","descriptors","length","getOwnPropertyDescriptor","formatRegExp","format","f","isString","objects","arguments","push","inspect","join","args","len","str","String","replace","x","Number","JSON","stringify","_","isNull","isObject","deprecate","fn","msg","noDeprecation","apply","this","warned","throwDeprecation","Error","traceDeprecation","console","trace","error","debugEnviron","debugs","opts","ctx","seen","stylize","stylizeNoColor","depth","colors","isBoolean","showHidden","_extend","isUndefined","customInspect","stylizeWithColor","formatValue","styleType","style","styles","recurseTimes","isFunction","ret","primitive","simple","isNumber","formatPrimitive","visibleKeys","array","hash","forEach","val","idx","arrayToHash","getOwnPropertyNames","isError","indexOf","formatError","name","isRegExp","RegExp","call","isDate","Date","output","base","braces","isArray","toUTCString","l","hasOwnProperty","formatProperty","key","match","formatArray","map","pop","reduce","prev","cur","numLinesEst","reduceToSingleString","desc","get","set","split","line","ar","arg","re","objectToString","d","e","o","pad","n","debuglog","env","NODE_DEBUG","toUpperCase","test","pid","bold","italic","underline","inverse","white","grey","black","blue","cyan","green","magenta","red","yellow","special","number","boolean","undefined","null","string","date","regexp","isNullOrUndefined","isSymbol","isPrimitive","isBuffer","__webpack_require__","months","prop","log","time","getHours","getMinutes","getSeconds","getDate","getMonth","inherits","origin","add","kCustomPromisifiedSymbol","Symbol","callbackifyOnRejected","reason","cb","newReason","promisify","original","TypeError","defineProperty","promiseResolve","promiseReject","promise","Promise","resolve","reject","err","setPrototypeOf","getPrototypeOf","defineProperties","custom","callbackify","callbackified","maybeCb","self","then","nextTick","rej","__webpack_exports__","global","argsarray__WEBPACK_IMPORTED_MODULE_0__","argsarray__WEBPACK_IMPORTED_MODULE_0___default","immediate__WEBPACK_IMPORTED_MODULE_1__","immediate__WEBPACK_IMPORTED_MODULE_1___default","events__WEBPACK_IMPORTED_MODULE_2__","inherits__WEBPACK_IMPORTED_MODULE_3__","inherits__WEBPACK_IMPORTED_MODULE_3___default","spark_md5__WEBPACK_IMPORTED_MODULE_4__","spark_md5__WEBPACK_IMPORTED_MODULE_4___default","uuid__WEBPACK_IMPORTED_MODULE_5__","uuid__WEBPACK_IMPORTED_MODULE_5___default","vuvuzela__WEBPACK_IMPORTED_MODULE_6__","vuvuzela__WEBPACK_IMPORTED_MODULE_6___default","cloneBinaryObject","object","ArrayBuffer","buff","slice","target","byteLength","targetArray","sourceArray","cloneArrayBuffer","size","type","webkitSlice","ExportedSet","ExportedMap","funcToString","Function","objectCtorString","clone","newObject","toISOString","Blob","isBinaryObject","proto","Ctor","isPlainObject","once","fun","called","toPromise","func","usedCB","fulfill","resp","callback","mesg","result","adapterFun","_closed","_destroyed","listeners","logArgs","emit","origCallback","res","responseArgs","concat","logApiCall","taskqueue","isReady","addTask","failed","mangle","unmangle","substring","Map$1","_store","Set$1","pick","arr","mangled","has","delete","Map","Set","species","supportsMapAndSet","hasLocal","MAX_NUM_CONCURRENT_REQUESTS","identityFunction","formatResultForOpenRevsGet","ok","bulkGet","db","requests","docs","requestsById","request","id","numDocs","numDone","perDocResults","checkDone","results","info","allRequests","nextBatch","upTo","min","batch","docId","j","docIdx","docRequests","docOpts","open_revs","rev","filter","formatResult","param","processBatch","localStorage","setItem","getItem","hasLocalStorage","Changes","_listeners","addEventListener","guardedConsole","method","defaultBackOff","max","parseInt","maxTimeout","randomNumber","explainError","status","addListener","dbName","inprogress","eventFunction","on","changesOpts","changes","c","seq","since","cancelled","onChange","removeListener","notifyLocalWindows","notify","$inject_Object_assign","assign","to","index","nextSource","nextKey","PouchError","message","MISSING_BULK_DOCS","MISSING_DOC","REV_CONFLICT","INVALID_ID","MISSING_ID","RESERVED_ID","UNKNOWN_ERROR","BAD_ARG","QUERY_PARSE_ERROR","DOC_VALIDATION","BAD_REQUEST","NOT_AN_OBJECT","IDB_ERROR","INVALID_REV","MISSING_STUB","createError","CustomPouchError","p","generateErrorFromResponse","data","filterChange","req","hasFilter","query","query_params","change","doc","filterReturn","tryFilter","include_docs","attachments","att","_attachments","stub","flatten","arrs","invalidIdError","isRemote","_remote","parseDesignDocFunctionName","s","parts","normalizeDesignDocFunctionName","normalized","qName","qParser","parser","parseUri","m","exec","uri","encoded","decodeURIComponent","$0","$1","$2","scopeEval","source","scope","values","upsert","diffFun","docRev","_rev","newDoc","updated","_id","put","tryAndPut","thisAtob","atob","thisBtoa","btoa","createBlob","properties","builder","BlobBuilder","MSBlobBuilder","MozBlobBuilder","WebKitBlobBuilder","append","getBlob","binaryStringToArrayBuffer","bin","charCodeAt","binStringToBluffer","binString","b64ToBluffer","b64","readAsBinaryString","blob","reader","FileReader","hasBinaryString","onloadend","buffer","binary","bytes","fromCharCode","arrayBufferToBinaryString","readAsArrayBuffer","blobToBinaryString","blobOrBuffer","blobToBase64","base64","setImmediateShim","setImmediate","setTimeout","MD5_CHUNK_SIZE","appendBlob","start","end","sliceBlob","arrayBuffer","appendString","appendBinary","binaryMd5","inputIsString","chunkSize","chunks","ceil","currentChunk","a","next","loadNextChunk","done","raw","rawToBase64","destroy","stringMd5","rev$$1","deterministic_revs","clonedDoc","_rev_tree","v4","toLowerCase","uuid","winningRev","metadata","winningId","winningPos","winningDeleted","node","toVisit","rev_tree","tree","ids","branches","pos","deleted","traverseRevTree","revs","newCtx","sortByPos","b","collectLeaves","leaves","isLeaf","acc","sort","reverse","collectConflicts","win","conflicts","leaf","rootToLeaf","paths","history","sortByPos$1","insertSorted","item","comparator","mid","low","high","binarySearch","splice","pathToTree","path","numStemmed","root","currentLeaf","compareTree","mergeTree","in_tree1","in_tree2","queue","tree1","tree2","merged","doMerge","dontExpand","restree","branch","t1","t2","diff","candidateParents","trees","parent","parentIdx","elements","elementsLen","el","merge","newTree","stemmed","stemmedRevs","revHash","stem","getTrees","isDeleted","isLocalId","Changes$1","complete","ee","listenerCount","removeAllListeners","onDestroy","cancel","pending","lastSeq","isCancelled","tryCatchInChangeListener","validateChanges","processChange","changeList","_conflicts","compare","left","right","yankError","compareByIdThenRev","idCompare","_revisions","AbstractPouchDB","TaskQueue","PouchDB","__opts","auto_compaction","prefix","backend","adapter","adapters","preferredAdapters","adapterName","use_prefix","parseAdapter","_adapter","valid","fail","onDestroyed","from_constructor","onClosed","prepareForDestruction","ready","_changesFilterPlugin","validate","doChanges","continuous","live","normalize","shouldFilter","descending","limit","newPromise","_changes","update_seq","post","bulkDocs","_putLocal","_deleted","_removeLocal","oldRevId","newRevNum","newRevId","putDoc","_put","new_edits","force","putAttachment","attachmentId","api","createAttachment","prevrevpos","content_type","revpos","removeAttachment","remove","docOrId","optsOrRev","was_delete","revsDiff","count","missing","addToMissing","revId","_getRevisionTree","missingForId","processDoc","missingObj","compactDocument","maxHeight","revTree","height","edges","prnt","from","edge","computeHeight","candidates","_doCompaction","compact","_compactionQueue","doNextCompaction","task","catch","last_seq","_compact","shift","return_docs","promises","row","all","_getLocal","finishOpenRevs","latest","existing","_get","revs_info","splittedRev","revNo","currentPath","hashIndex","indexOfRev","howMany","_revs_info","_getAttachment","getAttachment","allDocs","skip","start_key","startkey","end_key","endkey","incompatibleOpt","allDocsKeysParse","_allDocs","close","_close","_info","db_name","_type","attachmentError","charAt","attachmentNameError","atts","cleanDocs","_bulkDocs","registerDependentDatabase","dependentDb","depDB","dependentDbs","usePrefix","destroyDb","_destroy","localDoc","deletedMap","trueName","execute","AbortController","abort","f$1","fetch","h","Headers","eventEmitter","Pouch","destructListeners","_destructionListeners","dbList","setUpEventEmitter","addToPreferredAdapters","plugin","__defaults","defaults","defaultOpts","PouchAlt","url","getFieldFromDoc","parsedField","parseField","fieldName","fields","current","ch","combinationFields","isCombinationalField","field","getKey","mergeAndedSelectors","selectors","selector","matcher","$eq","fieldMatchers","operator","$gte","$gt","mergeGtGte","$lte","$lt","mergeLtLte","$ne","mergeNe","mergeEq","MIN_MAGNITUDE","MAGNITUDE_DIGITS","SEP","collate","normalizeKey","ai","collationIndex","bi","stringCollate","arrayCollate","ak","bk","objectCollate","Infinity","isNaN","origKey","toJSON","k","indexify","num","expFormat","toExponential","magnitude","neg","magString","padWith","upToLength","padding","targetLength","factor","abs","parseFloat","factorStr","toFixed","numToIndexableString","toIndexableString","objKey","parseNumber","originalIdx","numAsString","magAsString","stack","metaStack","lastMetaElement","element","lastElementIndex","filterInMemoryFields","rows","requestDef","inMemoryFields","rowFilter","fieldSorter","getFieldValuesAsArray","sorting","aRow","bRow","collation","createFieldSorter","every","docFieldValue","some","orMatchers","find","matchCominationalSelector","matchSelector","userOperator","userValue","matchers","fieldExists","fieldIsNotUndefined","arrayContainsValue","$elemMatch","$allMatch","$exists","$mod","divisor","mod","modField","neValue","$in","$nin","$size","arraySize","$all","arrayContainsAllValues","$regex","regexMatch","$type","typeMatch","matchesSelector","rowsMatched","input","wasAnded","orOrNor","subSelector","massageSelector","filterName","view","changesHandler","doc_ids","viewName","ddoc","mapFun","views","filterFun","filters","toObject","version","reservedWords","dataWords","parseRevisionInfo","parseDoc","newEdits","dbOpts","nRevNum","revInfo","revisions","revisionIds","makeRevTreeFromRevisions","specialKey","preprocessString","blobType","asBinary","parseBase64","digest","preprocessAttachment","md5","preprocessBlob","updateDoc","revLimit","docInfo","writeDoc","splitRev","targetPos","targetId","revExists","previousWinningRev","previouslyDeleted","isRoot","newRev","rev_map","winningRev$$1","winningRevIsDeleted","delta","processDocs","docInfos","fetchedDocs","tx","overallCallback","idsToDocs","docsDone","docsToDo","checkAllDocsDone","currentDoc","resultsIdx","docWritten","nextDoc","rootIsMissing","insertDoc","ADAPTER_VERSION","DOC_STORE","BY_SEQ_STORE","ATTACH_STORE","ATTACH_AND_SEQ_STORE","META_STORE","LOCAL_STORE","DETECT_BLOB_SUPPORT_STORE","safeJsonStringify","json","idbError","evt","encodeMetadata","deletedOrLocal","decodeMetadata","storedObject","parse","safeJsonParse","decodeDoc","_doc_id_rev","lastIndexOf","readBlobData","body","asBlob","fetchAttachmentsIfNecessary","txn","attObj","objectStore","onsuccess","fetchAttachment","postProcessAttachments","attNames","compactRevs","possiblyOrphanedDigests","seqStore","attStore","attAndSeqStore","countReq","IDBKeyRange","bound","deleteOrphanedAttachments","openCursor","only","event","cursor","digestSeq","primaryKey","continue","openTransactionSafely","idb","stores","mode","transaction","idbBulkDocs","docStore","bySeqStore","attachStore","attachAndSeqStore","metaStore","docInfoError","metaDoc","allDocsProcessed","docCountDelta","preconditionErrored","_meta","blobSupport","onAllDocsProcessed","updateDocCountIfReady","docCount","newRevIsDeleted","isUpdate","collectResults","finishDoc","attachmentSaved","newAtt","putReq","saveAttachment","writeAttachments","afterPutDoc","revsToDelete","compactTree","metadataToStore","afterPutMetadata","attsAdded","attsToAdd","onerror","preventDefault","stopPropagation","insertAttachmentMappings","overallErr","docv","recv","processedAttachment","preprocessAttachments","txnResult","onabort","ontimeout","oncomplete","finish","digests","filename","verifyAttachment","attErr","verifyAttachments","numFetched","revs_limit","readMetadata","fetchExistingDocs","startTransaction","runBatchedCursor","keyRange","batchSize","onBatch","keysBatch","valuesBatch","pseudoCursor","onGetAll","onGetAllKeys","onCursor","getAll","getAllKeys","newKeyRange","lastKey","upper","upperOpen","code","lowerBound","idbAllDocs","keyRangeError","inclusiveEnd","inclusive_end","upperBound","createKeyRange","onResultsReady","updateSeq","docIdRevIndex","allDocsInner","fetchDocAsynchronously","batchValues","batchValue","batchKeys","returnVal","total_rows","onSuccess","maxKey","getMaxUpdateSeq","allDocsKeys","running","applyNext","docIds","numResults","docIdsToMetadata","onGetMetadata","docIdRev","objectStores","winningDocs","metadatas","fetchWinningDocAndMetadata","winningDoc","processMetadataAndWinningDoc","onBatchDone","filtered","blobSupportPromise","cachedDBs","openReqList","IdbPouch","action","tryCode","enqueueTask","thisCallback","addDeletedOrLocalIndex","createIndex","unique","migrateLocalStore","localStore","local","range","seqCursor","migrateAttsAndSeqs","digestMap","migrateMetadata","metadataSeq","decodeMetadataCompat","onGetMetadataSeq","instanceId","reqOpts","historyNode","attachId","attachment","blobData","doc_count","idb_attachment_format","oldRev","oStore","oldDoc","openReq","indexedDB","deleteDatabase","cached","open","onupgradeneeded","oldVersion","createObjectStore","keyPath","autoIncrement","createSchema","currentTarget","createLocalStoreSchema","addAttachAndSeqStore","migrations","migration","onversionchange","storedMetaDoc","completeSetup","storeMetaDocIfReady","instanceKey","countDocs","blob$$1","matchedChrome","navigator","userAgent","matchedEdge","checkBlobSupport","init","CHANGES_BATCH_SIZE","MAX_SIMULTANEOUS_REVS","CHANGES_TIMEOUT_BUFFER","DEFAULT_HEARTBEAT","supportsBulkGetMap","readAttachmentsAsBlobOrBuffer","encodeDocId","encodeURIComponent","preprocessAttachments$1","getHost","protocol","hasUrlPrefix","user","password","auth","username","genDBUrl","genUrl","pathDel","host","port","paramsToStr","params","HttpPouch","dbUrl","setupPromise","ourFetch","options","headers","nAuth","token","unescape","ua","isIE","isTrident","isEdge","isGET","shouldCacheBust","now","adapterFun$$1","setup","fetchJSON","response","v","skip_setup","encodeAttachmentId","uuid$$1","ping","compact_running","interval","doBulkGet","doBulkGetShim","numBatches","onResult","batchNum","subOpts","supportsBulkGet","fetchAttachments","filenames","promiseFactories","doNext","runNextBatch","onError","thisErr","pool","browser","fetchData","docOrDocs","contentType","Content-Type","paramStr","batch_size","heartbeat","requestTimeout","timeout","leftToFetch","feed","seq_interval","param_name","lastFetchedSeq","controller","aborted","fetchOpts","signal","fetched","raw_results_length","finished","QueryParseError","captureStackTrace","NotFoundError","BuiltInError","promisedCallback","sequentialize","promiseFactory","that","uniq","theSet","mapToKeysArray","createBuiltInError","sum","jLen","jNum","evalFunctionWithEval","TaskQueue$1","createView","sourceDB","reduceFun","temporary","localDocName","cachedViews","viewSignature","createViewSignature","_cachedViews","promiseForView","depDbName","fullViewName","depDbs","lastSeqDoc","persistentQueues","tempViewQueue","CHANGES_BATCH_SIZE$1","parseViewName","emitError","builtInReduce","_sum","_count","_stats","sumsqr","_sumsqr","abstract","mapper","reducer","ddocValidator","tryMap","tryReduce","rereduce","sortByKeyThenValue","y","keyCompare","sliceResults","rowToDocId","postprocessAttachments","addHttpParam","paramName","asJson","coerceInteger","integerCandidate","asNumber","checkQueryParseError","startkeyName","endkeyName","group","group_level","optionName","checkPositiveInteger","defaultsTo","getDocsToPersist","docIdsToChangesAndEmits","metaDocId","defaultMetaDoc","docData","indexableKeysToKeyValues","isGenOne","getKeyValueDocs","kvDocsRes","kvDocs","oldKeys","keyValue","newKeys","kvDoc","processKeyValueDocs","getQueue","updateView","mapResults","currentSeq","listOfDocsToPersist","docsToPersist","saveKeyValues","processNextBatch","createIndexableKeysToKeyValues","createDocIdsToChangesAndEmits","emittedKeyValue","complexKey","updateViewInQueue","queryView","totalRows","shouldReduce","fetchFromView","viewOpts","expectedKeys","parsedKeyAndDocId","parsedNum","parsedStr","arrayElement","objElement","parseIndexableString","onMapResultsReady","finalResults","shouldGroup","groups","lvl","POSITIVE_INFINITY","last","groupKey","reduceTry","reduceView","allDocsRes","docIdsToDocs","fetchPromises","keyStart","keyEnd","queryViewInQueue","queryPromised","_query","customQuery","keysAsString","httpQuery","finalPromiseFactory","designDocName","stale","coerceOptions","viewCleanup","_viewCleanup","customViewCleanup","httpViewCleanup","docsToViews","viewsToStatus","ddocName","viewDBNames","statusIsGood","viewDBName","destroyPromises","localViewCleanup","createAbstractMapReduce","origMap","reduceFunString","builtIn","getBuiltIn","mapreduce","isGenOne$1","getDocAttachments","getDocs","src","diffs","state","resultDocs","fetchRevisionOneDocs","hasConflicts","bulkGetOpts","missingRev","createBulkGetOpts","bulkGetResponse","bulkGetInfo","remoteDoc","doCheckForLocalAttachments","fileHasChanged","getDocAttachmentsFromTargetOrSource","Boolean","CHECKPOINT_VERSION","REPLICATOR","CHECKPOINT_HISTORY_SIZE","LOWEST_SEQ","updateCheckpoint","checkpoint","session","returnValue","session_id","replicator","unshift","Checkpointer","writeCheckpoint","updateTarget","updateSource","writeTargetCheckpoint","writeSourceCheckpoint","isForbiddenError","comparisons","targetDoc","sourceDoc","1","srcDoc","tgtDoc","compareReplicationHistory","sourceHistory","targetHistory","S","sourceRest","T","targetRest","sourceId","hasSessionId","compareReplicationLogs","sessionId","props","rest","floor","getCheckpoint","STARTING_BACK_OFF","generateReplicationId","queryParams","filterViewName","sortObjectPropertiesByKey","queryData","md5sum","replicate","currentBatch","repId","checkpointer","batches","pendingBatch","writingCheckpoint","changesCompleted","replicationCompleted","batches_limit","changesPending","changedDocs","start_time","docs_read","docs_written","doc_write_failures","errors","initCheckpointer","checkpointOpts","writeDocs","bulkOpts","completeReplication","errorsById","errorsNo","errorName","finishBatch","outResult","getChanges","onCheckpointError","getBatchDocs","got","startNextBatch","abortReplication","processPendingBatch","immediate","fatalError","end_time","retry","back_off_function","backOffSet","current_back_off","backOff","onChangesComplete","onChangesError","_abortChanges","abortChanges","startChanges","_addedListeners","Replication","toPouch","PouchConstructor","replicateWrapper","replicateRet","sync","Sync","canceled","optsPush","optsPull","pull","pullChange","direction","pushChange","pushDenied","pullDenied","pushPaused","pullPaused","pushActive","pullActive","removed","removeAll","addOneListener","listener","out","success","_readyCalled","replicateMethods","other","scheduleDrain","draining","Mutation","MutationObserver","WebKitMutationObserver","observer","document","createTextNode","observe","characterData","MessageChannel","createElement","scriptEl","onreadystatechange","parentNode","removeChild","documentElement","appendChild","channel","port1","onmessage","port2","postMessage","oldQueue","ReflectOwnKeys","R","Reflect","ReflectApply","receiver","ownKeys","getOwnPropertySymbols","NumberIsNaN","EventEmitter","_events","_eventsCount","_maxListeners","defaultMaxListeners","$getMaxListeners","_addListener","prepend","events","warning","newListener","w","emitter","warn","_onceWrap","fired","wrapFn","wrapped","unwrap","evlistener","unwrapListeners","arrayClone","copy","RangeError","setMaxListeners","getMaxListeners","doError","er","context","handler","prependListener","prependOnceListener","list","position","originalListener","spliceOne","off","rawListeners","eventNames","hex_chr","md5cycle","md5blk","md5blks","md5blk_array","md51","tail","tmp","lo","hi","rhex","hex","toUtf8","hexToBinaryString","SparkMD5","reset","clamp","begin","contents","_buff","_length","_hash","_finish","getState","setState","hashBinary","content","first","second","returnUInt8Array","subarray","utf8Str2ArrayBuffer","md51_array","factory","v1","_nodeId","_clockseq","rng","bytesToUuid","_lastMSecs","_lastNSecs","clockseq","seedBytes","msecs","getTime","nsecs","dt","tl","tmh","ii","arrayPrefix","objPrefix","numChar","parsedString","lastCh","numConsecutiveSlashes","fill","readUInt8"],"mappings":"2EAAA,mBAAAA,OAAAC,OAEAC,EAAAC,QAAA,SAAAC,EAAAC,GACAD,EAAAE,OAAAD,EACAD,EAAAG,UAAAP,OAAAC,OAAAI,EAAAE,UAAA,CACAC,YAAA,CACAC,MAAAL,EACAM,YAAA,EACAC,UAAA,EACAC,cAAA,MAMAV,EAAAC,QAAA,SAAAC,EAAAC,GACAD,EAAAE,OAAAD,EACA,IAAAQ,EAAA,aACAA,EAAAN,UAAAF,EAAAE,UACAH,EAAAG,UAAA,IAAAM,EACAT,EAAAG,UAAAC,YAAAJ,sBCdA,IAAAU,EAAA,4BAAAC,OAAAD,gBAAAE,KAAAD,SACA,8BAAAE,SAAAH,gBAAAE,KAAAC,UACA,GAAAH,EAAA,CAEA,IAAAI,EAAA,IAAAC,WAAA,IAEAjB,EAAAC,QAAA,WAEA,OADAW,EAAAI,GACAA,OAEC,CAKD,IAAAE,EAAA,IAAAC,MAAA,IAEAnB,EAAAC,QAAA,WACA,QAAAmB,EAAAC,EAAA,EAAsBA,EAAA,GAAQA,IAC9B,MAAAA,KAAAD,EAAA,WAAAE,KAAAC,UACAL,EAAAG,GAAAD,MAAA,EAAAC,IAAA,OAGA,OAAAH,uBCxBA,IADA,IAAAM,EAAA,GACAH,EAAA,EAAeA,EAAA,MAASA,EACxBG,EAAAH,MAAA,KAAAI,SAAA,IAAAC,OAAA,GAgBA1B,EAAAC,QAbA,SAAA0B,EAAAC,GACA,IAAAP,EAAAO,GAAA,EACAC,EAAAL,EACA,OAAAK,EAAAF,EAAAN,MAAAQ,EAAAF,EAAAN,MACAQ,EAAAF,EAAAN,MAAAQ,EAAAF,EAAAN,MAAA,IACAQ,EAAAF,EAAAN,MAAAQ,EAAAF,EAAAN,MAAA,IACAQ,EAAAF,EAAAN,MAAAQ,EAAAF,EAAAN,MAAA,IACAQ,EAAAF,EAAAN,MAAAQ,EAAAF,EAAAN,MAAA,IACAQ,EAAAF,EAAAN,MAAAQ,EAAAF,EAAAN,MACAQ,EAAAF,EAAAN,MAAAQ,EAAAF,EAAAN,MACAQ,EAAAF,EAAAN,MAAAQ,EAAAF,EAAAN,6BCnBA,SAAAS,GAqBA,IAAAC,EAAAjC,OAAAiC,2BACA,SAAAC,GAGA,IAFA,IAAAC,EAAAnC,OAAAmC,KAAAD,GACAE,EAAA,GACAb,EAAA,EAAmBA,EAAAY,EAAAE,OAAiBd,IACpCa,EAAAD,EAAAZ,IAAAvB,OAAAsC,yBAAAJ,EAAAC,EAAAZ,IAEA,OAAAa,GAGAG,EAAA,WACApC,EAAAqC,OAAA,SAAAC,GACA,IAAAC,EAAAD,GAAA,CAEA,IADA,IAAAE,EAAA,GACApB,EAAA,EAAmBA,EAAAqB,UAAAP,OAAsBd,IACzCoB,EAAAE,KAAAC,EAAAF,UAAArB,KAEA,OAAAoB,EAAAI,KAAA,KAGAxB,EAAA,EAmBA,IAnBA,IACAyB,EAAAJ,UACAK,EAAAD,EAAAX,OACAa,EAAAC,OAAAV,GAAAW,QAAAb,EAAA,SAAAc,GACA,UAAAA,EAAA,UACA,GAAA9B,GAAA0B,EAAA,OAAAI,EACA,OAAAA,GACA,gBAAAF,OAAAH,EAAAzB,MACA,gBAAA+B,OAAAN,EAAAzB,MACA,SACA,IACA,OAAAgC,KAAAC,UAAAR,EAAAzB,MACS,MAAAkC,GACT,mBAEA,QACA,OAAAJ,KAGAA,EAAAL,EAAAzB,GAAuBA,EAAA0B,EAASI,EAAAL,IAAAzB,GAChCmC,EAAAL,KAAAM,EAAAN,GACAH,GAAA,IAAAG,EAEAH,GAAA,IAAAJ,EAAAO,GAGA,OAAAH,GAOA/C,EAAAyD,UAAA,SAAAC,EAAAC,GACA,YAAA9B,IAAA,IAAAA,EAAA+B,cACA,OAAAF,EAIA,YAAA7B,EACA,kBACA,OAAA7B,EAAAyD,UAAAC,EAAAC,GAAAE,MAAAC,KAAArB,YAIA,IAAAsB,GAAA,EAeA,OAdA,WACA,IAAAA,EAAA,CACA,GAAAlC,EAAAmC,iBACA,UAAAC,MAAAN,GACO9B,EAAAqC,iBACPC,QAAAC,MAAAT,GAEAQ,QAAAE,MAAAV,GAEAI,GAAA,EAEA,OAAAL,EAAAG,MAAAC,KAAArB,aAOA,IACA6B,EADAC,EAAA,GA6BA,SAAA5B,EAAAZ,EAAAyC,GAEA,IAAAC,EAAA,CACAC,KAAA,GACAC,QAAAC,GAkBA,OAfAnC,UAAAP,QAAA,IAAAuC,EAAAI,MAAApC,UAAA,IACAA,UAAAP,QAAA,IAAAuC,EAAAK,OAAArC,UAAA,IACAsC,EAAAP,GAEAC,EAAAO,WAAAR,EACGA,GAEHxE,EAAAiF,QAAAR,EAAAD,GAGAU,EAAAT,EAAAO,cAAAP,EAAAO,YAAA,GACAE,EAAAT,EAAAI,SAAAJ,EAAAI,MAAA,GACAK,EAAAT,EAAAK,UAAAL,EAAAK,QAAA,GACAI,EAAAT,EAAAU,iBAAAV,EAAAU,eAAA,GACAV,EAAAK,SAAAL,EAAAE,QAAAS,GACAC,EAAAZ,EAAA1C,EAAA0C,EAAAI,OAoCA,SAAAO,EAAArC,EAAAuC,GACA,IAAAC,EAAA5C,EAAA6C,OAAAF,GAEA,OAAAC,EACA,KAAA5C,EAAAmC,OAAAS,GAAA,OAAAxC,EACA,KAAAJ,EAAAmC,OAAAS,GAAA,OAEAxC,EAKA,SAAA6B,EAAA7B,EAAAuC,GACA,OAAAvC,EAeA,SAAAsC,EAAAZ,EAAAnE,EAAAmF,GAGA,GAAAhB,EAAAU,eACA7E,GACAoF,EAAApF,EAAAqC,UAEArC,EAAAqC,UAAA3C,EAAA2C,WAEArC,EAAAD,aAAAC,EAAAD,YAAAD,YAAAE,GAAA,CACA,IAAAqF,EAAArF,EAAAqC,QAAA8C,EAAAhB,GAIA,OAHAlC,EAAAoD,KACAA,EAAAN,EAAAZ,EAAAkB,EAAAF,IAEAE,EAIA,IAAAC,EA+FA,SAAAnB,EAAAnE,GACA,GAAA4E,EAAA5E,GACA,OAAAmE,EAAAE,QAAA,yBACA,GAAApC,EAAAjC,GAAA,CACA,IAAAuF,EAAA,IAAAzC,KAAAC,UAAA/C,GAAA2C,QAAA,aACAA,QAAA,YACAA,QAAA,gBACA,OAAAwB,EAAAE,QAAAkB,EAAA,UAEA,GAAAC,EAAAxF,GACA,OAAAmE,EAAAE,QAAA,GAAArE,EAAA,UACA,GAAAyE,EAAAzE,GACA,OAAAmE,EAAAE,QAAA,GAAArE,EAAA,WAEA,GAAAiD,EAAAjD,GACA,OAAAmE,EAAAE,QAAA,eA9GAoB,CAAAtB,EAAAnE,GACA,GAAAsF,EACA,OAAAA,EAIA,IAAA5D,EAAAnC,OAAAmC,KAAA1B,GACA0F,EApCA,SAAAC,GACA,IAAAC,EAAA,GAMA,OAJAD,EAAAE,QAAA,SAAAC,EAAAC,GACAH,EAAAE,IAAA,IAGAF,EA6BAI,CAAAtE,GAQA,GANAyC,EAAAO,aACAhD,EAAAnC,OAAA0G,oBAAAjG,IAKAkG,EAAAlG,KACA0B,EAAAyE,QAAA,eAAAzE,EAAAyE,QAAA,mBACA,OAAAC,EAAApG,GAIA,OAAA0B,EAAAE,OAAA,CACA,GAAAwD,EAAApF,GAAA,CACA,IAAAqG,EAAArG,EAAAqG,KAAA,KAAArG,EAAAqG,KAAA,GACA,OAAAlC,EAAAE,QAAA,YAAAgC,EAAA,eAEA,GAAAC,EAAAtG,GACA,OAAAmE,EAAAE,QAAAkC,OAAAzG,UAAAoB,SAAAsF,KAAAxG,GAAA,UAEA,GAAAyG,EAAAzG,GACA,OAAAmE,EAAAE,QAAAqC,KAAA5G,UAAAoB,SAAAsF,KAAAxG,GAAA,QAEA,GAAAkG,EAAAlG,GACA,OAAAoG,EAAApG,GAIA,IA2CA2G,EA3CAC,EAAA,GAAAjB,GAAA,EAAAkB,EAAA,KAA4C,MAG5CC,EAAA9G,KACA2F,GAAA,EACAkB,EAAA,WAIAzB,EAAApF,MAEA4G,EAAA,cADA5G,EAAAqG,KAAA,KAAArG,EAAAqG,KAAA,IACA,KAkBA,OAdAC,EAAAtG,KACA4G,EAAA,IAAAL,OAAAzG,UAAAoB,SAAAsF,KAAAxG,IAIAyG,EAAAzG,KACA4G,EAAA,IAAAF,KAAA5G,UAAAiH,YAAAP,KAAAxG,IAIAkG,EAAAlG,KACA4G,EAAA,IAAAR,EAAApG,IAGA,IAAA0B,EAAAE,QAAA+D,GAAA,GAAA3F,EAAA4B,OAIAuD,EAAA,EACAmB,EAAAtG,GACAmE,EAAAE,QAAAkC,OAAAzG,UAAAoB,SAAAsF,KAAAxG,GAAA,UAEAmE,EAAAE,QAAA,uBAIAF,EAAAC,KAAAhC,KAAApC,GAIA2G,EADAhB,EAsCA,SAAAxB,EAAAnE,EAAAmF,EAAAO,EAAAhE,GAEA,IADA,IAAAiF,EAAA,GACA7F,EAAA,EAAAkG,EAAAhH,EAAA4B,OAAmCd,EAAAkG,IAAOlG,EAC1CmG,EAAAjH,EAAA0C,OAAA5B,IACA6F,EAAAvE,KAAA8E,EAAA/C,EAAAnE,EAAAmF,EAAAO,EACAhD,OAAA5B,IAAA,IAEA6F,EAAAvE,KAAA,IASA,OANAV,EAAAmE,QAAA,SAAAsB,GACAA,EAAAC,MAAA,UACAT,EAAAvE,KAAA8E,EAAA/C,EAAAnE,EAAAmF,EAAAO,EACAyB,GAAA,MAGAR,EArDAU,CAAAlD,EAAAnE,EAAAmF,EAAAO,EAAAhE,GAEAA,EAAA4F,IAAA,SAAAH,GACA,OAAAD,EAAA/C,EAAAnE,EAAAmF,EAAAO,EAAAyB,EAAAxB,KAIAxB,EAAAC,KAAAmD,MA6GA,SAAAZ,EAAAC,EAAAC,GAQA,GANAF,EAAAa,OAAA,SAAAC,EAAAC,GAGA,OAFAC,EACAD,EAAAvB,QAAA,UAAAwB,EACAF,EAAAC,EAAA/E,QAAA,sBAAAf,OAAA,GACG,GAEH,GACA,OAAAiF,EAAA,IACA,KAAAD,EAAA,GAAAA,EAAA,OACA,IACAD,EAAArE,KAAA,SACA,IACAuE,EAAA,GAGA,OAAAA,EAAA,GAAAD,EAAA,IAAAD,EAAArE,KAAA,UAAAuE,EAAA,GA5HAe,CAAAjB,EAAAC,EAAAC,IAxBAA,EAAA,GAAAD,EAAAC,EAAA,GA+CA,SAAAT,EAAApG,GACA,UAAA2D,MAAA7D,UAAAoB,SAAAsF,KAAAxG,GAAA,IAwBA,SAAAkH,EAAA/C,EAAAnE,EAAAmF,EAAAO,EAAAyB,EAAAxB,GACA,IAAAU,EAAA5D,EAAAoF,EAsCA,IArCAA,EAAAtI,OAAAsC,yBAAA7B,EAAAmH,IAAA,CAAyDnH,QAAAmH,KACzDW,IAEArF,EADAoF,EAAAE,IACA5D,EAAAE,QAAA,6BAEAF,EAAAE,QAAA,sBAGAwD,EAAAE,MACAtF,EAAA0B,EAAAE,QAAA,uBAGA4C,EAAAvB,EAAAyB,KACAd,EAAA,IAAAc,EAAA,KAEA1E,IACA0B,EAAAC,KAAA+B,QAAA0B,EAAA7H,OAAA,GAEAyC,EADAQ,EAAAkC,GACAJ,EAAAZ,EAAA0D,EAAA7H,MAAA,MAEA+E,EAAAZ,EAAA0D,EAAA7H,MAAAmF,EAAA,IAEAgB,QAAA,WAEA1D,EADAkD,EACAlD,EAAAuF,MAAA,MAAAV,IAAA,SAAAW,GACA,WAAAA,IACW3F,KAAA,MAAAnB,OAAA,GAEX,KAAAsB,EAAAuF,MAAA,MAAAV,IAAA,SAAAW,GACA,YAAAA,IACW3F,KAAA,OAIXG,EAAA0B,EAAAE,QAAA,yBAGAO,EAAAyB,GAAA,CACA,GAAAV,GAAAwB,EAAAC,MAAA,SACA,OAAA3E,GAEA4D,EAAAvD,KAAAC,UAAA,GAAAoE,IACAC,MAAA,iCACAf,IAAAlF,OAAA,EAAAkF,EAAAzE,OAAA,GACAyE,EAAAlC,EAAAE,QAAAgC,EAAA,UAEAA,IAAA1D,QAAA,YACAA,QAAA,YACAA,QAAA,gBACA0D,EAAAlC,EAAAE,QAAAgC,EAAA,WAIA,OAAAA,EAAA,KAAA5D,EA2BA,SAAAqE,EAAAoB,GACA,OAAAtH,MAAAkG,QAAAoB,GAIA,SAAAzD,EAAA0D,GACA,wBAAAA,EAIA,SAAAlF,EAAAkF,GACA,cAAAA,EASA,SAAA3C,EAAA2C,GACA,uBAAAA,EAIA,SAAAlG,EAAAkG,GACA,uBAAAA,EASA,SAAAvD,EAAAuD,GACA,gBAAAA,EAIA,SAAA7B,EAAA8B,GACA,OAAAlF,EAAAkF,IAAA,oBAAAC,EAAAD,GAIA,SAAAlF,EAAAiF,GACA,uBAAAA,GAAA,OAAAA,EAIA,SAAA1B,EAAA6B,GACA,OAAApF,EAAAoF,IAAA,kBAAAD,EAAAC,GAIA,SAAApC,EAAAqC,GACA,OAAArF,EAAAqF,KACA,mBAAAF,EAAAE,iBAAA5E,OAIA,SAAAyB,EAAA+C,GACA,yBAAAA,EAgBA,SAAAE,EAAAG,GACA,OAAAjJ,OAAAO,UAAAoB,SAAAsF,KAAAgC,GAIA,SAAAC,EAAAC,GACA,OAAAA,EAAA,OAAAA,EAAAxH,SAAA,IAAAwH,EAAAxH,SAAA,IApbAxB,EAAAiJ,SAAA,SAAAZ,GAIA,GAHAnD,EAAAZ,KACAA,EAAAzC,EAAAqH,IAAAC,YAAA,IACAd,IAAAe,eACA7E,EAAA8D,GACA,OAAAxB,OAAA,MAAAwB,EAAA,WAAAgB,KAAA/E,GAAA,CACA,IAAAgF,EAAAzH,EAAAyH,IACA/E,EAAA8D,GAAA,WACA,IAAA1E,EAAA3D,EAAAqC,OAAAwB,MAAA7D,EAAAyC,WACA0B,QAAAE,MAAA,YAAAgE,EAAAiB,EAAA3F,SAGAY,EAAA8D,GAAA,aAGA,OAAA9D,EAAA8D,IAoCArI,EAAA2C,UAIAA,EAAAmC,OAAA,CACAyE,KAAA,OACAC,OAAA,OACAC,UAAA,OACAC,QAAA,OACAC,MAAA,QACAC,KAAA,QACAC,MAAA,QACAC,KAAA,QACAC,KAAA,QACAC,MAAA,QACAC,QAAA,QACAC,IAAA,QACAC,OAAA,SAIAxH,EAAA6C,OAAA,CACA4E,QAAA,OACAC,OAAA,SACAC,QAAA,SACAC,UAAA,OACAC,KAAA,OACAC,OAAA,QACAC,KAAA,UAEAC,OAAA,OAkRA3K,EAAAoH,UAKApH,EAAA+E,YAKA/E,EAAAuD,SAKAvD,EAAA4K,kBAHA,SAAAnC,GACA,aAAAA,GAOAzI,EAAA8F,WAKA9F,EAAAuC,WAKAvC,EAAA6K,SAHA,SAAApC,GACA,uBAAAA,GAOAzI,EAAAkF,cAKAlF,EAAA4G,WAKA5G,EAAAwD,WAKAxD,EAAA+G,SAMA/G,EAAAwG,UAKAxG,EAAA0F,aAUA1F,EAAA8K,YARA,SAAArC,GACA,cAAAA,GACA,kBAAAA,GACA,iBAAAA,GACA,iBAAAA,GACA,iBAAAA,QACA,IAAAA,GAIAzI,EAAA+K,SAAmBC,EAAQ,KAY3B,IAAAC,EAAA,uDACA,mBA6CA,SAAA1D,EAAAxF,EAAAmJ,GACA,OAAArL,OAAAO,UAAAmH,eAAAT,KAAA/E,EAAAmJ,GAjCAlL,EAAAmL,IAAA,WAVA,IACAvC,EACAwC,EASAjH,QAAAgH,IAAA,WAVAvC,EAAA,IAAA5B,KACAoE,EAAA,CAAArC,EAAAH,EAAAyC,YACAtC,EAAAH,EAAA0C,cACAvC,EAAAH,EAAA2C,eAAA3I,KAAA,KACA,CAAAgG,EAAA4C,UAAAP,EAAArC,EAAA6C,YAAAL,GAAAxI,KAAA,MAMA5C,EAAAqC,OAAAwB,MAAA7D,EAAAyC,aAiBAzC,EAAA0L,SAAmBV,EAAQ,KAE3BhL,EAAAiF,QAAA,SAAA0G,EAAAC,GAEA,IAAAA,IAAApI,EAAAoI,GAAA,OAAAD,EAIA,IAFA,IAAA3J,EAAAnC,OAAAmC,KAAA4J,GACAxK,EAAAY,EAAAE,OACAd,KACAuK,EAAA3J,EAAAZ,IAAAwK,EAAA5J,EAAAZ,IAEA,OAAAuK,GAOA,IAAAE,EAAA,oBAAAC,cAAA,8BAAAvB,EA0DA,SAAAwB,EAAAC,EAAAC,GAKA,IAAAD,EAAA,CACA,IAAAE,EAAA,IAAAjI,MAAA,2CACAiI,EAAAF,SACAA,EAAAE,EAEA,OAAAD,EAAAD,GAlEAhM,EAAAmM,UAAA,SAAAC,GACA,sBAAAA,EACA,UAAAC,UAAA,oDAEA,GAAAR,GAAAO,EAAAP,GAAA,CACA,IAAAnI,EACA,sBADAA,EAAA0I,EAAAP,IAEA,UAAAQ,UAAA,iEAKA,OAHAxM,OAAAyM,eAAA5I,EAAAmI,EAAA,CACAvL,MAAAoD,EAAAnD,YAAA,EAAAC,UAAA,EAAAC,cAAA,IAEAiD,EAGA,SAAAA,IAQA,IAPA,IAAA6I,EAAAC,EACAC,EAAA,IAAAC,QAAA,SAAAC,EAAAC,GACAL,EAAAI,EACAH,EAAAI,IAGA/J,EAAA,GACAzB,EAAA,EAAmBA,EAAAqB,UAAAP,OAAsBd,IACzCyB,EAAAH,KAAAD,UAAArB,IAEAyB,EAAAH,KAAA,SAAAmK,EAAAvM,GACAuM,EACAL,EAAAK,GAEAN,EAAAjM,KAIA,IACA8L,EAAAvI,MAAAC,KAAAjB,GACK,MAAAgK,GACLL,EAAAK,GAGA,OAAAJ,EAQA,OALA5M,OAAAiN,eAAApJ,EAAA7D,OAAAkN,eAAAX,IAEAP,GAAAhM,OAAAyM,eAAA5I,EAAAmI,EAAA,CACAvL,MAAAoD,EAAAnD,YAAA,EAAAC,UAAA,EAAAC,cAAA,IAEAZ,OAAAmN,iBACAtJ,EACA5B,EAAAsK,KAIApM,EAAAmM,UAAAc,OAAApB,EAiDA7L,EAAAkN,YAlCA,SAAAd,GACA,sBAAAA,EACA,UAAAC,UAAA,oDAMA,SAAAc,IAEA,IADA,IAAAtK,EAAA,GACAzB,EAAA,EAAmBA,EAAAqB,UAAAP,OAAsBd,IACzCyB,EAAAH,KAAAD,UAAArB,IAGA,IAAAgM,EAAAvK,EAAAgF,MACA,sBAAAuF,EACA,UAAAf,UAAA,8CAEA,IAAAgB,EAAAvJ,KACAmI,EAAA,WACA,OAAAmB,EAAAvJ,MAAAwJ,EAAA5K,YAIA2J,EAAAvI,MAAAC,KAAAjB,GACAyK,KAAA,SAAA3H,GAA2B9D,EAAA0L,SAAAtB,EAAA,KAAAtG,IAC3B,SAAA6H,GAA2B3L,EAAA0L,SAAAxB,EAAAyB,EAAAvB,KAM3B,OAHApM,OAAAiN,eAAAK,EAAAtN,OAAAkN,eAAAX,IACAvM,OAAAmN,iBAAAG,EACArL,EAAAsK,IACAe,yDC5rBAnC,EAAA7J,EAAAsM,GAAA,SAAAC,EAAA7L,GAAA,IAAA8L,EAAA3C,EAAA,KAAA4C,EAAA5C,EAAAhC,EAAA2E,GAAAE,EAAA7C,EAAA,KAAA8C,EAAA9C,EAAAhC,EAAA6E,GAAAE,EAAA/C,EAAA,KAAAgD,EAAAhD,EAAA,KAAAiD,EAAAjD,EAAAhC,EAAAgF,GAAAE,EAAAlD,EAAA,KAAAmD,EAAAnD,EAAAhC,EAAAkF,GAAAE,EAAApD,EAAA,KAAAqD,EAAArD,EAAAhC,EAAAoF,GAAAE,EAAAtD,EAAA,KAAAuD,EAAAvD,EAAAhC,EAAAsF,GAyBA,SAAAE,EAAAC,GACA,GAAAA,aAAAC,YACA,OAdA,SAAAC,GACA,sBAAAA,EAAAC,MACA,OAAAD,EAAAC,MAAA,GAGA,IAAAC,EAAA,IAAAH,YAAAC,EAAAG,YACAC,EAAA,IAAA/N,WAAA6N,GACAG,EAAA,IAAAhO,WAAA2N,GAEA,OADAI,EAAA1G,IAAA2G,GACAH,EAKAI,CAAAR,GAEA,IAAAS,EAAAT,EAAAS,KACAC,EAAAV,EAAAU,KAEA,yBAAAV,EAAAG,MACAH,EAAAG,MAAA,EAAAM,EAAAC,GAGAV,EAAAW,YAAA,EAAAF,EAAAC,GAOA,IAkPAE,EACAC,EAnPAC,EAAAC,SAAApP,UAAAoB,SACAiO,EAAAF,EAAAzI,KAAAjH,QAaA,SAAA6P,EAAAjB,GACA,IAAAkB,EACAvO,EACA0B,EAEA,IAAA2L,GAAA,iBAAAA,EACA,OAAAA,EAGA,GAAAvN,MAAAkG,QAAAqH,GAAA,CAEA,IADAkB,EAAA,GACAvO,EAAA,EAAA0B,EAAA2L,EAAAvM,OAAoCd,EAAA0B,EAAS1B,IAC7CuO,EAAAvO,GAAAsO,EAAAjB,EAAArN,IAEA,OAAAuO,EAKA,GAAAlB,aAAAzH,KACA,OAAAyH,EAAAmB,cAGA,GAxEA,SAAAnB,GACA,0BAAAC,aAAAD,aAAAC,aACA,oBAAAmB,MAAApB,aAAAoB,KAsEAC,CAAArB,GACA,OAAAD,EAAAC,GAGA,IAtCA,SAAAnO,GACA,IAAAyP,EAAAlQ,OAAAkN,eAAAzM,GAEA,UAAAyP,EACA,SAEA,IAAAC,EAAAD,EAAA1P,YACA,yBAAA2P,GACAA,gBAAAT,EAAAzI,KAAAkJ,IAAAP,EA8BAQ,CAAAxB,GACA,OAAAA,EAIA,IAAArN,KADAuO,EAAA,GACAlB,EAEA,GAAA5O,OAAAO,UAAAmH,eAAAT,KAAA2H,EAAArN,GAAA,CACA,IAAAd,EAAAoP,EAAAjB,EAAArN,SACA,IAAAd,IACAqP,EAAAvO,GAAAd,GAIA,OAAAqP,EAGA,SAAAO,EAAAC,GACA,IAAAC,GAAA,EACA,OAASxC,IAAY,SAAA/K,GAErB,GAAAuN,EAEA,UAAAnM,MAAA,8BAEAmM,GAAA,EACAD,EAAAtM,MAAAC,KAAAjB,KAKA,SAAAwN,EAAAC,GAEA,OAAS1C,IAAY,SAAA/K,GAErBA,EAAA6M,EAAA7M,GACA,IAAAwK,EAAAvJ,KAEAyM,EAAA,mBAAA1N,IAAAX,OAAA,IAAAW,EAAAgF,MACA4E,EAAA,IAAAC,QAAA,SAAA8D,EAAA5D,GACA,IAAA6D,EACA,IACA,IAAAC,EAAAR,EAAA,SAAArD,EAAA8D,GACA9D,EACAD,EAAAC,GAEA2D,EAAAG,KAKA9N,EAAAH,KAAAgO,IACAD,EAAAH,EAAAzM,MAAAwJ,EAAAxK,KACA,mBAAA4N,EAAAnD,MACAkD,EAAAC,GAEO,MAAA5H,GACP+D,EAAA/D,MASA,OALA0H,GACA9D,EAAAa,KAAA,SAAAsD,GACAL,EAAA,KAAAK,IACOL,GAEP9D,IA0BA,SAAAoE,EAAAlK,EAAA+J,GACA,OAAAL,EAAmBzC,IAAY,SAAA/K,GAC/B,GAAAiB,KAAAgN,QACA,OAAApE,QAAAE,OAAA,IAAA3I,MAAA,uBAEA,GAAAH,KAAAiN,WACA,OAAArE,QAAAE,OAAA,IAAA3I,MAAA,0BAEA,IAAAoJ,EAAAvJ,KAEA,OAhCA,SAAAuJ,EAAA1G,EAAA9D,GAEA,GAAAwK,EAAAhN,YAAA2Q,UAAA,SAAA9O,OAAA,CAEA,IADA,IAAA+O,EAAA,OAAA5D,EAAA1G,QACAvF,EAAA,EAAmBA,EAAAyB,EAAAX,OAAA,EAAqBd,IACxC6P,EAAAvO,KAAAG,EAAAzB,IAEAiM,EAAAhN,YAAA6Q,KAAA,QAAAD,GAGA,IAAAE,EAAAtO,IAAAX,OAAA,GACAW,IAAAX,OAAA,YAAA2K,EAAAuE,GACA,IAAAC,EAAA,OAAAhE,EAAA1G,QACA0K,IAAAC,OACAzE,EAAA,SAAAA,GAAA,WAAAuE,IAEA/D,EAAAhN,YAAA6Q,KAAA,QAAAG,GACAF,EAAAtE,EAAAuE,KAcAG,CAAAlE,EAAA1G,EAAA9D,GACAiB,KAAA0N,UAAAC,QAWAf,EAAA7M,MAAAC,KAAAjB,GAVA,IAAA6J,QAAA,SAAA8D,EAAA5D,GACAS,EAAAmE,UAAAE,QAAA,SAAAC,GACAA,EACA/E,EAAA+E,GAEAnB,EAAAnD,EAAA1G,GAAA9C,MAAAwJ,EAAAxK,WASA,SAAA+O,EAAAnK,GACA,UAAAA,EAEA,SAAAoK,EAAApK,GACA,OAAAA,EAAAqK,UAAA,GAEA,SAAAC,IACAjO,KAAAkO,OAAA,GAoCA,SAAAC,EAAAhM,GAIA,GAHAnC,KAAAkO,OAAA,IAAAD,EAGA9L,GAAA/E,MAAAkG,QAAAnB,GACA,QAAA7E,EAAA,EAAA0B,EAAAmD,EAAA/D,OAAuCd,EAAA0B,EAAS1B,IAChD0C,KAAA8H,IAAA3F,EAAA7E,IAiDA,SAAA8Q,EAAAnQ,EAAAoQ,GAEA,IADA,IAAAf,EAAA,GACAhQ,EAAA,EAAA0B,EAAAqP,EAAAjQ,OAAmCd,EAAA0B,EAAS1B,IAAA,CAC5C,IAAA8J,EAAAiH,EAAA/Q,GACA8J,KAAAnJ,IACAqP,EAAAlG,GAAAnJ,EAAAmJ,IAGA,OAAAkG,EAjGAW,EAAA3R,UAAAgI,IAAA,SAAAX,GACA,IAAA2K,EAAAR,EAAAnK,GACA,OAAA3D,KAAAkO,OAAAI,IAEAL,EAAA3R,UAAAiI,IAAA,SAAAZ,EAAAnH,GACA,IAAA8R,EAAAR,EAAAnK,GAEA,OADA3D,KAAAkO,OAAAI,GAAA9R,GACA,GAEAyR,EAAA3R,UAAAiS,IAAA,SAAA5K,GAEA,OADAmK,EAAAnK,KACA3D,KAAAkO,QAEAD,EAAA3R,UAAAkS,OAAA,SAAA7K,GACA,IAAA2K,EAAAR,EAAAnK,GACA2J,EAAAgB,KAAAtO,KAAAkO,OAEA,cADAlO,KAAAkO,OAAAI,GACAhB,GAEAW,EAAA3R,UAAA+F,QAAA,SAAA8F,GAEA,IADA,IAAAjK,EAAAnC,OAAAmC,KAAA8B,KAAAkO,QACA5Q,EAAA,EAAA0B,EAAAd,EAAAE,OAAoCd,EAAA0B,EAAS1B,IAAA,CAC7C,IAAAqG,EAAAzF,EAAAZ,GAGA6K,EAFAnI,KAAAkO,OAAAvK,GACAA,EAAAoK,EAAApK,MAIA5H,OAAAyM,eAAAyF,EAAA3R,UAAA,QACAgI,IAAA,WACA,OAAAvI,OAAAmC,KAAA8B,KAAAkO,QAAA9P,UAcA+P,EAAA7R,UAAAwL,IAAA,SAAAnE,GACA,OAAA3D,KAAAkO,OAAA3J,IAAAZ,GAAA,IAEAwK,EAAA7R,UAAAiS,IAAA,SAAA5K,GACA,OAAA3D,KAAAkO,OAAAK,IAAA5K,IAEAwK,EAAA7R,UAAA+F,QAAA,SAAA8F,GACAnI,KAAAkO,OAAA7L,QAAA,SAAA7F,EAAAmH,GACAwE,EAAAxE,MAGA5H,OAAAyM,eAAA2F,EAAA7R,UAAA,QACAgI,IAAA,WACA,OAAAtE,KAAAkO,OAAA9C,SAQA,WACA,uBAAApD,QAAA,oBAAAyG,KAAA,oBAAAC,IACA,SAEA,IAAAtH,EAAArL,OAAAsC,yBAAAoQ,IAAAzG,OAAA2G,SACA,OAAAvH,GAAA,QAAAA,GAAAqH,IAAAzG,OAAA2G,WAAAF,IASAG,IAIArD,EAAA4C,EACA3C,EAAAyC,IAJA1C,EAAAmD,IACAlD,EAAAiD,KAsBA,IAgIAI,EAhIAC,EAAA,EAEA,SAAAC,EAAA3P,GACA,OAAAA,EAGA,SAAA4P,EAAAlC,GACA,QACAmC,GAAAnC,IAKA,SAAAoC,EAAAC,EAAAzO,EAAAkM,GACA,IAAAwC,EAAA1O,EAAA2O,KAGAC,EAAA,IAAA9D,EACA4D,EAAA/M,QAAA,SAAAkN,GACAD,EAAAf,IAAAgB,EAAAC,IACAF,EAAAhL,IAAAiL,EAAAC,IAAA5Q,KAAA2Q,GAEAD,EAAA/K,IAAAgL,EAAAC,GAAA,CAAAD,MAIA,IAAAE,EAAAH,EAAAlE,KACAsE,EAAA,EACAC,EAAA,IAAAvS,MAAAqS,GAeA,SAAAG,IAbA,IACAC,IAaAH,IAAAD,IAbAI,EAAA,GACAF,EAAAtN,QAAA,SAAAiL,GACAA,EAAA+B,KAAAhN,QAAA,SAAAyN,GACAD,EAAAjR,KAAA,CACA4Q,GAAAlC,EAAAkC,GACAH,KAAA,CAAAS,SAIAlD,EAAA,MAAoBiD,aAcpB,IAAAE,EAAA,GACAT,EAAAjN,QAAA,SAAA7F,EAAAmH,GACAoM,EAAAnR,KAAA+E,KAGA,IAAArG,EAAA,EAEA,SAAA0S,IAEA,KAAA1S,GAAAyS,EAAA3R,QAAA,CAIA,IAAA6R,EAAA1S,KAAA2S,IAAA5S,EAAAwR,EAAAiB,EAAA3R,QACA+R,EAAAJ,EAAAjF,MAAAxN,EAAA2S,IAKA,SAAAE,EAAAtS,GACAsS,EAAA9N,QAAA,SAAA+N,EAAAC,GACA,IAAAC,EAAAzS,EAAAwS,EACAE,EAAAjB,EAAAhL,IAAA8L,GAQAI,EAAApC,EAAAmC,EAAA,iCACAC,EAAAC,UAAAF,EAAAzM,IAAA,SAAAyL,GAEA,OAAAA,EAAAmB,MAIAF,EAAAC,UAAAD,EAAAC,UAAAE,OAAA5B,GAEA,IAAA6B,EAAA7B,EAEA,IAAAyB,EAAAC,UAAArS,gBACAoS,EAAAC,UAKAG,EAAA5B,GAIA,gDAAA3M,QAAA,SAAAwO,GACAA,KAAAnQ,IACA8P,EAAAK,GAAAnQ,EAAAmQ,MAGA1B,EAAA7K,IAAA8L,EAAAI,EAAA,SAAAzH,EAAAuE,GACA,IAAAR,EA9DA0C,EAAAH,EAiEAvC,EADA/D,EACA,EAAqBxI,MAAAwI,IAErB6H,EAAAtD,GAnEAkC,EAqEAY,EArEAf,EAqEAvC,EApEA6C,EAoEAW,GApEA,CAA+Bd,KAAAH,QAC/BO,IAoEAI,QAlDAc,CAAAX,EAAA7S,GACAA,GAAA6S,EAAA/R,QAsDA4R,IAMA,IACAe,aAAAC,QAAA,+BACAnC,IAAAkC,aAAAE,QAAA,6BACC,MAAAlM,GACD8J,GAAA,EAGA,SAAAqC,IACA,OAAArC,EAgBA,SAAAsC,IARA,IAAA5H,EASEU,EAAA,aAAYjH,KAAAhD,MACdA,KAAAoR,WAAA,GAVA7H,EAYAvJ,KAXAkR,KACAG,iBAAA,mBAAAtM,GACAwE,EAAA6D,KAAArI,EAAApB,OA+EA,SAAA2N,EAAAC,GAEA,uBAAAlR,SAAA,mBAAAA,QAAAkR,GAAA,CACA,IAAAxS,EAAA3B,MAAAd,UAAAwO,MAAA9H,KAAArE,UAAA,GACA0B,QAAAkR,GAAAxR,MAAAM,QAAAtB,IAwBA,SAAAyS,EAAAtB,GACA,IAAAuB,EAAA,EAIA,OAHAvB,IACAuB,EAAA,KAvBA,SAAAvB,EAAAuB,GAiBA,OAfAvB,EAAAwB,SAAAxB,EAAA,QACAuB,EAAAC,SAAAD,EAAA,MACAA,MAAAvB,EACAuB,GAAAvB,GAAA,MAEAuB,GAAA,EAGAA,EATA,MAUAvB,EAAAyB,IACAF,EAXA,SAcAA,EAAAvB,GADA3S,KAAAC,SAGA0S,GAQA0B,CAAA1B,EAAAuB,GAKA,SAAAI,EAAAC,EAAA7S,GACAqS,EAAA,oBAAAQ,EAAA,uBAAA7S,GA5HAkL,IAAQgH,EAAUlH,EAAA,cAiBlBkH,EAAA7U,UAAAyV,YAAA,SAAAC,EAAAxC,EAAAL,EAAAzO,GAEA,IAAAV,KAAAoR,WAAA5B,GAAA,CAGA,IAAAjG,EAAAvJ,KACAiS,GAAA,EAiCAjS,KAAAoR,WAAA5B,GAAA0C,EACAlS,KAAAmS,GAAAH,EAAAE,GAjCA,SAAAA,IAEA,GAAA3I,EAAA6H,WAAA5B,GAGA,GAAAyC,EACAA,EAAA,cADA,CAIAA,GAAA,EACA,IAAAG,EAAAhE,EAAA1N,EAAA,CACA,0DACA,iEAQAyO,EAAAkD,QAAAD,GAAAD,GAAA,kBAAAG,GACAA,EAAAC,IAAA7R,EAAA8R,QAAA9R,EAAA+R,YACA/R,EAAA8R,MAAAF,EAAAC,IACA7R,EAAAgS,SAAAJ,MAEKH,GAAA,sBACL,YAAAF,GACQjI,IAAQkI,GAEhBD,GAAA,IACKE,GAAA,QAdL,WACAF,GAAA,OAmBAd,EAAA7U,UAAAqW,eAAA,SAAAX,EAAAxC,GAEAA,KAAAxP,KAAAoR,aAGEnH,EAAA,aAAY3N,UAAAqW,eAAA3P,KAAAhD,KAAAgS,EACdhS,KAAAoR,WAAA5B,WACAxP,KAAAoR,WAAA5B,KAKA2B,EAAA7U,UAAAsW,mBAAA,SAAAZ,GAGAd,MACAH,aAAAiB,GAAA,MAAAjB,aAAAiB,GAAA,UAIAb,EAAA7U,UAAAuW,OAAA,SAAAb,GACAhS,KAAAoN,KAAA4E,GACAhS,KAAA4S,mBAAAZ,IAwEA,IAAAc,EAzBA,mBAAA/W,OAAAgX,OACAhX,OAAAgX,OAIA,SAAAhI,GAGA,IAFA,IAAAiI,EAAAjX,OAAAgP,GAEAkI,EAAA,EAAyBA,EAAAtU,UAAAP,OAA0B6U,IAAA,CACnD,IAAAC,EAAAvU,UAAAsU,GAEA,SAAAC,EACA,QAAAC,KAAAD,EAEAnX,OAAAO,UAAAmH,eAAAT,KAAAkQ,EAAAC,KACAH,EAAAG,GAAAD,EAAAC,IAKA,OAAAH,GASA,SAAAI,EAAAtB,EAAAvR,EAAA2H,GACA/H,MAAA6C,KAAAhD,KAAAkI,GACAlI,KAAA8R,SACA9R,KAAA6C,KAAAtC,EACAP,KAAAqT,QAAAnL,EACAlI,KAAAO,OAAA,EAPA4J,IAAQiJ,EAAAjT,OAURiT,EAAA9W,UAAAoB,SAAA,WACA,OAAA4B,KAAAC,UAAA,CACAuS,OAAA9R,KAAA8R,OACAjP,KAAA7C,KAAA6C,KACAwQ,QAAArT,KAAAqT,QACAnL,OAAAlI,KAAAkI,UAIA,IAAAkL,EAAA,yDACAE,EAAA,IAAAF,EAAA,iDACAG,EAAA,IAAAH,EAAA,2BACAI,EAAA,IAAAJ,EAAA,2CACAK,EAAA,IAAAL,EAAA,qDACAM,EAAA,IAAAN,EAAA,6CACAO,EAAA,IAAAP,EAAA,2EAEAQ,GADA,IAAAR,EAAA,+CACA,IAAAA,EAAA,8DACAS,EAAA,IAAAT,EAAA,+CAEAU,GADA,IAAAV,EAAA,6CACA,IAAAA,EAAA,4DACAW,EAAA,IAAAX,EAAA,oDACAY,EAAA,IAAAZ,EAAA,sDACAa,GAAA,IAAAb,EAAA,oDAEAc,IADA,IAAAd,EAAA,sCACA,IAAAA,EAAA,sCAIAe,IAHA,IAAAf,EAAA,kCACA,IAAAA,EAAA,uCACA,IAAAA,EAAA,wEACA,IAAAA,EAAA,yCAEAgB,IADA,IAAAhB,EAAA,iFACA,IAAAA,EAAA,mEACA,IAAAA,EAAA,6CAEA,SAAAiB,GAAA9T,EAAA2H,GACA,SAAAoM,EAAApM,GAIA,QAAAqM,KAAAhU,EACA,mBAAAA,EAAAgU,KACAvU,KAAAuU,GAAAhU,EAAAgU,SAIA9N,IAAAyB,IACAlI,KAAAkI,UAIA,OADAoM,EAAAhY,UAAA8W,EAAA9W,UACA,IAAAgY,EAAApM,GAGA,SAAAsM,GAAAzL,GAEA,oBAAAA,EAAA,CACA,IAAA0L,EAAA1L,GACAA,EAAA6K,GACAa,OAoBA,MAjBA,UAAA1L,GAAA,aAAAA,EAAAxI,QACAwI,EAAAlG,KAAA,WACAkG,EAAA+I,OAAA,KAGA,SAAA/I,IACAA,EAAAlG,KAAAkG,EAAAxI,OAAA,WAGA,WAAAwI,IACAA,EAAA+I,OAAA,KAGA,YAAA/I,IACAA,EAAAsK,QAAAtK,EAAAsK,SAAAtK,EAAAb,QAGAa,EAYA,SAAA2L,GAAAhU,GACA,IAAAiU,EAAA,GACAC,EAAAlU,EAAAiQ,QAAA,mBAAAjQ,EAAAiQ,OAGA,OAFAgE,EAAAE,MAAAnU,EAAAoU,aAEA,SAAAC,GACAA,EAAAC,MAGAD,EAAAC,IAAA,IAGA,IAAAC,EAAAL,GArBA,SAAAjE,EAAAqE,EAAAL,GACA,IACA,OAAAhE,EAAAqE,EAAAL,GACG,MAAA5L,GACH,IAAAlJ,EAAA,0BAAAkJ,EAAArL,WACA,OAAA2W,GAAAL,EAAAnU,IAgBAqV,CAAAxU,EAAAiQ,OAAAoE,EAAAC,IAAAL,GAEA,oBAAAM,EACA,OAAAA,EAGA,GAAAA,EACA,SAGA,GAAAvU,EAAAyU,cAEK,IAAAzU,EAAA0U,YACL,QAAAC,KAAAN,EAAAC,IAAAM,aAEAP,EAAAC,IAAAM,aAAA7R,eAAA4R,KACAN,EAAAC,IAAAM,aAAAD,GAAAE,MAAA,eALAR,EAAAC,IASA,UAIA,SAAAQ,GAAAC,GAEA,IADA,IAAAnI,EAAA,GACAhQ,EAAA,EAAA0B,EAAAyW,EAAArX,OAAoCd,EAAA0B,EAAS1B,IAC7CgQ,IAAAE,OAAAiI,EAAAnY,IAEA,OAAAgQ,EAUA,SAAAoI,GAAAlG,GACA,IAAAzG,EAQA,GAPAyG,EAEG,iBAAAA,EACHzG,EAAAsL,GAAAZ,GACG,KAAAlO,KAAAiK,KAAA,mBAAAjK,KAAAiK,KACHzG,EAAAsL,GAAAV,IAJA5K,EAAAsL,GAAAX,GAMA3K,EACA,MAAAA,EAMA,SAAA4M,GAAAxG,GACA,wBAAAA,EAAAyG,QACAzG,EAAAyG,QAGA,mBAAAzG,EAAA9D,OACAiG,EAAA,OACA,8EAEA,SAAAnC,EAAA9D,QAWA,SAAAwK,GAAAC,GACA,IAAAA,EACA,YAEA,IAAAC,EAAAD,EAAAtR,MAAA,KACA,WAAAuR,EAAA3X,OACA2X,EAEA,IAAAA,EAAA3X,OACA,CAAA0X,KAEA,KAGA,SAAAE,GAAAF,GACA,IAAAG,EAAAJ,GAAAC,GACA,OAAAG,IAAAnX,KAAA,UAMA,IAAAZ,GAAA,8DACA,qEACAgY,GAAA,WACAC,GAAA,4BAIAC,GAAA,mMAEA,SAAAC,GAAApX,GAKA,IAJA,IAAAqX,EAAAF,GAAAG,KAAAtX,GACAuX,EAAA,GACAlZ,EAAA,GAEAA,KAAA,CACA,IAAAqG,EAAAzF,GAAAZ,GACAd,EAAA8Z,EAAAhZ,IAAA,GACAmZ,GAAA,wBAAA9T,QAAAgB,GACA6S,EAAA7S,GAAA8S,EAAAC,mBAAAla,KAUA,OAPAga,EAAAN,IAAA,GACAM,EAAAtY,GAAA,KAAAiB,QAAAgX,GAAA,SAAAQ,EAAAC,EAAAC,GACAD,IACAJ,EAAAN,IAAAU,GAAAC,KAIAL,EAOA,SAAAM,GAAAC,EAAAC,GACA,IAAA9Y,EAAA,GACA+Y,EAAA,GACA,QAAAtT,KAAAqT,EACAA,EAAAvT,eAAAE,KACAzF,EAAAU,KAAA+E,GACAsT,EAAArY,KAAAoY,EAAArT,KAIA,OADAzF,EAAAU,KAAAmY,GACArL,SAAA3L,MAAA,KAAA7B,GAAA6B,MAAA,KAAAkX,GAMA,SAAAC,GAAA/H,EAAAiB,EAAA+G,GACA,WAAAvO,QAAA,SAAA8D,EAAA5D,GACAqG,EAAA7K,IAAA8L,EAAA,SAAArH,EAAAiM,GACA,GAAAjM,EAAA,CAEA,SAAAA,EAAA+I,OACA,OAAAhJ,EAAAC,GAEAiM,EAAA,GAIA,IAAAoC,EAAApC,EAAAqC,KACAC,EAAAH,EAAAnC,GAEA,IAAAsC,EAGA,OAAA5K,EAAA,CAAwB6K,SAAA,EAAA7G,IAAA0G,IAKxBE,EAAAE,IAAApH,EACAkH,EAAAD,KAAAD,EACA1K,EAKA,SAAAyC,EAAA6F,EAAAmC,GACA,OAAAhI,EAAAsI,IAAAzC,GAAAxL,KAAA,SAAA8D,GACA,OACAiK,SAAA,EACA7G,IAAApD,EAAAoD,MAEG,SAAA3H,GAEH,SAAAA,EAAA+I,OACA,MAAA/I,EAEA,OAAAmO,GAAA/H,EAAA6F,EAAAwC,IAAAL,KAhBAO,CAAAvI,EAAAmI,EAAAH,QAoBA,IAAAQ,GAAA,SAAA1Y,GACA,OAAA2Y,KAAA3Y,IAGA4Y,GAAA,SAAA5Y,GACA,OAAA6Y,KAAA7Y,IAMA,SAAA8Y,GAAAhC,EAAAiC,GAEAjC,KAAA,GACAiC,KAAA,GACA,IACA,WAAAjM,KAAAgK,EAAAiC,GACG,MAAAjT,GACH,iBAAAA,EAAAlC,KACA,MAAAkC,EAOA,IALA,IAIAkT,EAAA,IAJA,oBAAAC,wBACA,oBAAAC,4BACA,oBAAAC,8BACAC,mBAEA/a,EAAA,EAAmBA,EAAAyY,EAAA3X,OAAkBd,GAAA,EACrC2a,EAAAK,OAAAvC,EAAAzY,IAEA,OAAA2a,EAAAM,QAAAP,EAAA3M,OAMA,SAAAmN,GAAAC,GAIA,IAHA,IAAAra,EAAAqa,EAAAra,OACAR,EAAA,IAAAgN,YAAAxM,GACAiQ,EAAA,IAAAnR,WAAAU,GACAN,EAAA,EAAiBA,EAAAc,EAAYd,IAC7B+Q,EAAA/Q,GAAAmb,EAAAC,WAAApb,GAEA,OAAAM,EAGA,SAAA+a,GAAAC,EAAAvN,GACA,OAAA0M,GAAA,CAAAS,GAAAI,IAAA,CAA6DvN,SAG7D,SAAAwN,GAAAC,EAAAzN,GACA,OAAAsN,GAAAhB,GAAAmB,GAAAzN,GAiBA,SAAA0N,GAAAC,EAAApM,GACA,IAAAqM,EAAA,IAAAC,WACAC,EAAA,mBAAAF,EAAAF,mBACAE,EAAAG,UAAA,SAAArU,GACA,IAAA+H,EAAA/H,EAAAgG,OAAA+B,QAAA,GACA,GAAAqM,EACA,OAAAvM,EAAAE,GAEAF,EAnBA,SAAAyM,GAIA,IAHA,IAAAC,EAAA,GACAC,EAAA,IAAArc,WAAAmc,GACAjb,EAAAmb,EAAAvO,WACA1N,EAAA,EAAiBA,EAAAc,EAAYd,IAC7Bgc,GAAApa,OAAAsa,aAAAD,EAAAjc,IAEA,OAAAgc,EAYAG,CAAA3M,KAEAqM,EACAF,EAAAF,mBAAAC,GAEAC,EAAAS,kBAAAV,GAIA,SAAAW,GAAAC,EAAAhN,GACAmM,GAAAa,EAAA,SAAAnB,GACA7L,EAAA6L,KAIA,SAAAoB,GAAAD,EAAAhN,GACA+M,GAAAC,EAAA,SAAAE,GACAlN,EAAAiL,GAAAiC,MAgBA,IAAAC,GAAAnQ,EAAAoQ,cAAApQ,EAAAqQ,WACAC,GAAA,MAaA,SAAAC,GAAAd,EAAAL,EAAAoB,EAAAC,EAAAzN,IACAwN,EAAA,GAAAC,EAAArB,EAAA5N,QAEA4N,EAVA,SAAAA,EAAAoB,EAAAC,GACA,OAAArB,EAAA1N,YACA0N,EAAA1N,YAAA8O,EAAAC,GAEArB,EAAAlO,MAAAsP,EAAAC,GAMAC,CAAAtB,EAAAoB,EAAAC,IA5BA,SAAArB,EAAApM,GACA,IAAAqM,EAAA,IAAAC,WACAD,EAAAG,UAAA,SAAArU,GACA,IAAA+H,EAAA/H,EAAAgG,OAAA+B,QAAA,IAAAlC,YAAA,GACAgC,EAAAE,IAEAmM,EAAAS,kBAAAV,GAwBAU,CAAAV,EAAA,SAAAuB,GACAlB,EAAAf,OAAAiC,GACA3N,MAIA,SAAA4N,GAAAnB,EAAA1S,EAAAyT,EAAAC,EAAAzN,IACAwN,EAAA,GAAAC,EAAA1T,EAAAvI,UAEAuI,IAAAqH,UAAAoM,EAAAC,IAEAhB,EAAAoB,aAAA9T,GACAiG,IAGA,SAAA8N,GAAAjG,EAAA7H,GACA,IAAA+N,EAAA,iBAAAlG,EACAzV,EAAA2b,EAAAlG,EAAArW,OAAAqW,EAAArJ,KACAwP,EAAArd,KAAA2S,IAAAgK,GAAAlb,GACA6b,EAAAtd,KAAAud,KAAA9b,EAAA4b,GACAG,EAAA,EACA1B,EAAAsB,EAAA,IAAmCtQ,EAAA2Q,EAAG,IAAS3Q,EAAA2Q,EAAGpQ,YAElD0N,EAAAqC,EAAAH,GAAAL,GAEA,SAAAc,IACAlB,GAAAmB,GAGA,SAAAC,IACA,IACArB,EA/CA,SAAAsB,GACA,OAAAvD,GAAAuD,GA8CAC,CADAhC,EAAAgB,KAAA,IAEAzN,EAAAkN,GACAT,EAAAiC,UAGA,SAAAJ,IACA,IAAAd,EAAAW,EAAAH,EACAP,EAAAD,EAAAQ,EAGAtC,EAAAe,EAAA5E,EAAA2F,EAAAC,IAFAU,EACAF,EACAI,EAEAE,GAGAD,IAGA,SAAAK,GAAA5U,GACA,OAAS0D,EAAA2Q,EAAG5Y,KAAAuE,GAGZ,SAAA6U,GAAAxG,EAAAyG,GACA,IAAAC,EAAA9P,EAAAoJ,GACA,OAAAyG,UAIAC,EAAAC,UACAJ,GAAAjc,KAAAC,UAAAmc,KAJWnR,EAAAyQ,EAAMY,KAAAzc,QAAA,SAAA0c,cAOjB,IAAAC,GAAWvR,EAAAyQ,EAAMY,GAOjB,SAAAG,GAAAC,GAMA,IALA,IAAAC,EACAC,EACAC,EAEAC,EADAC,EAAAL,EAAAM,SAAAxR,QAEAsR,EAAAC,EAAAtY,OAAA,CACA,IAAAwY,EAAAH,EAAAI,IACAC,EAAAF,EAAA,GACAG,EAAAN,EAAAM,IACA,GAAAD,EAAAre,OACA,QAAAd,EAAA,EAAA0B,EAAAyd,EAAAre,OAA4Cd,EAAA0B,EAAS1B,IACrD+e,EAAAzd,KAAA,CAAsB8d,MAAA,EAAAF,IAAAC,EAAAnf,SAFtB,CAMA,IAAAqf,IAAAJ,EAAA,GAAAI,QACAnN,EAAA+M,EAAA,GAEAN,KAAAE,IAAAQ,EAAAR,EACAD,IAAAQ,EAAAR,EAAAQ,EAAAT,EAAAzM,KACAyM,EAAAzM,EACA0M,EAAAQ,EACAP,EAAAQ,IAIA,OAAAT,EAAA,IAAAD,EAOA,SAAAW,GAAAC,EAAAjQ,GAIA,IAHA,IAEAwP,EAFAC,EAAAQ,EAAA/R,QAGAsR,EAAAC,EAAAtY,OAMA,IALA,IAAA2Y,EAAAN,EAAAM,IACAH,EAAAH,EAAAI,IACAC,EAAAF,EAAA,GACAO,EACAlQ,EAAA,IAAA6P,EAAAre,OAAAse,EAAAH,EAAA,GAAAH,EAAAzb,IAAA4b,EAAA,IACAjf,EAAA,EAAA0B,EAAAyd,EAAAre,OAA0Cd,EAAA0B,EAAS1B,IACnD+e,EAAAzd,KAAA,CAAoB8d,MAAA,EAAAF,IAAAC,EAAAnf,GAAAqD,IAAAmc,IAKpB,SAAAC,GAAA/B,EAAAgC,GACA,OAAAhC,EAAA0B,IAAAM,EAAAN,IAGA,SAAAO,GAAAJ,GACA,IAAAK,EAAA,GACAN,GAAAC,EAAA,SAAAM,EAAAT,EAAAlN,EAAA4N,EAAA1c,GACAyc,GACAD,EAAAte,KAAA,CAAmB8R,IAAAgM,EAAA,IAAAlN,EAAAkN,MAAAhc,WAGnBwc,EAAAG,KAAAN,IAAAO,UACA,QAAAhgB,EAAA,EAAA0B,EAAAke,EAAA9e,OAAsCd,EAAA0B,EAAS1B,WAC/C4f,EAAA5f,GAAAof,IAEA,OAAAQ,EAMA,SAAAK,GAAAvB,GAIA,IAHA,IAAAwB,EAAAzB,GAAAC,GACAkB,EAAAD,GAAAjB,EAAAM,UACAmB,EAAA,GACAngB,EAAA,EAAA0B,EAAAke,EAAA9e,OAAsCd,EAAA0B,EAAS1B,IAAA,CAC/C,IAAAogB,EAAAR,EAAA5f,GACAogB,EAAAhN,MAAA8M,GAAAE,EAAAhd,KAAAic,SACAc,EAAA7e,KAAA8e,EAAAhN,KAGA,OAAA+M,EAkBA,SAAAE,GAAAd,GAIA,IAHA,IAEAT,EAFAwB,EAAA,GACAvB,EAAAQ,EAAA/R,QAEAsR,EAAAC,EAAAtY,OAAA,CACA,IAAA2Y,EAAAN,EAAAM,IACAH,EAAAH,EAAAI,IACAhN,EAAA+M,EAAA,GACA7b,EAAA6b,EAAA,GACAE,EAAAF,EAAA,GACAY,EAAA,IAAAV,EAAAre,OAEAyf,EAAAzB,EAAAyB,QAAAzB,EAAAyB,QAAA/S,QAAA,GACA+S,EAAAjf,KAAA,CAAkB4Q,KAAA9O,SAClByc,GACAS,EAAAhf,KAAA,CAAkB8d,MAAA,EAAAmB,EAAAzf,OAAAoe,IAAAqB,IAElB,QAAAvgB,EAAA,EAAA0B,EAAAyd,EAAAre,OAA0Cd,EAAA0B,EAAS1B,IACnD+e,EAAAzd,KAAA,CAAoB8d,MAAA,EAAAF,IAAAC,EAAAnf,GAAAugB,YAGpB,OAAAD,EAAAN,UAKA,SAAAQ,GAAA9C,EAAAgC,GACA,OAAAhC,EAAA0B,IAAAM,EAAAN,IAoBA,SAAAqB,GAAA1P,EAAA2P,EAAAC,GACA,IAAA1b,EAjBA,SAAA8L,EAAA2P,EAAAC,GAIA,IAHA,IAEAC,EAFAC,EAAA,EACAC,EAAA/P,EAAAjQ,OAEA+f,EAAAC,GAEAH,EAAA5P,EADA6P,EAAAC,EAAAC,IAAA,GACAJ,GAAA,EACAG,EAAAD,EAAA,EAEAE,EAAAF,EAGA,OAAAC,EAKAE,CAAAhQ,EAAA2P,EAAAC,GACA5P,EAAAiQ,OAAA/b,EAAA,EAAAyb,GAMA,SAAAO,GAAAC,EAAAC,GAGA,IAFA,IAAAC,EACAhB,EACApgB,EAAAmhB,EAAAzf,EAAAwf,EAAApgB,OAA6Cd,EAAA0B,EAAS1B,IAAA,CACtD,IAAA8e,EAAAoC,EAAAlhB,GACAqhB,EAAA,CAAAvC,EAAA5M,GAAA4M,EAAA1b,KAAA,IACAgd,GACAA,EAAA,GAAA9e,KAAA+f,GACAjB,EAAAiB,GAEAD,EAAAhB,EAAAiB,EAGA,OAAAD,EAIA,SAAAE,GAAA5D,EAAAgC,GACA,OAAAhC,EAAA,GAAAgC,EAAA,QAKA,SAAA6B,GAAAC,EAAAC,GAGA,IAFA,IAAAC,EAAA,EAAgBC,MAAAH,EAAAI,MAAAH,IAChBtB,GAAA,EACAuB,EAAA5gB,OAAA,IACA,IAAA4f,EAAAgB,EAAAjb,MACAkb,EAAAjB,EAAAiB,MACAC,EAAAlB,EAAAkB,OAEAD,EAAA,GAAAnN,QAAAoN,EAAA,GAAApN,UACAmN,EAAA,GAAAnN,OACA,cAAAmN,EAAA,GAAAnN,QACA,cAAAoN,EAAA,GAAApN,OAAA,uBAGA,QAAAxU,EAAA,EAAmBA,EAAA4hB,EAAA,GAAA9gB,OAAqBd,IACxC,GAAA2hB,EAAA,OAOA,IADA,IAAAE,GAAA,EACA9O,EAAA,EAAqBA,EAAA4O,EAAA,GAAA7gB,OAAqBiS,IAC1C4O,EAAA,GAAA5O,GAAA,KAAA6O,EAAA,GAAA5hB,GAAA,KACA0hB,EAAApgB,KAAA,CAAsBqgB,QAAA,GAAA5O,GAAA6O,QAAA,GAAA5hB,KACtB6hB,GAAA,GAGAA,IACA1B,EAAA,aACAM,GAAAkB,EAAA,GAAAC,EAAA,GAAA5hB,GAAAshB,UAdAnB,EAAA,WACAwB,EAAA,MAAAC,EAAA,GAAA5hB,GAiBA,OAAUmgB,YAAAlB,KAAAuC,GAGV,SAAAM,GAAA7C,EAAAiC,EAAAa,GACA,IAGA/R,EAHAgS,EAAA,GACA7B,GAAA,EACA0B,GAAA,EAGA,IAAA5C,EAAAne,OACA,OAAYme,KAAA,CAAAiC,GAAAf,UAAA,YAGZ,QAAAngB,EAAA,EAAA0B,EAAAud,EAAAne,OAAoCd,EAAA0B,EAAS1B,IAAA,CAC7C,IAAAiiB,EAAAhD,EAAAjf,GACA,GAAAiiB,EAAA7C,MAAA8B,EAAA9B,KAAA6C,EAAA/C,IAAA,KAAAgC,EAAAhC,IAAA,GAGAlP,EAAAuR,GAAAU,EAAA/C,IAAAgC,EAAAhC,KACA8C,EAAA1gB,KAAA,CAAoB8d,IAAA6C,EAAA7C,IAAAF,IAAAlP,EAAAiP,OACpBkB,KAAAnQ,EAAAmQ,UACA0B,GAAA,OACK,QAAAE,EAAA,CAML,IAAAG,EAAAD,EAAA7C,IAAA8B,EAAA9B,IAAA6C,EAAAf,EACAiB,EAAAF,EAAA7C,IAAA8B,EAAA9B,IAAA8B,EAAAe,EACAG,EAAAD,EAAA/C,IAAA8C,EAAA9C,IAEAiD,EAAA,GAEAC,EAAA,GAEA,IADAA,EAAAhhB,KAAA,CAAkB4d,IAAAgD,EAAAhD,IAAAkD,OAAAG,OAAA,KAAAC,UAAA,OAClBF,EAAAxhB,OAAA,IACA,IAAA4f,EAAA4B,EAAA7b,MACA,OAAAia,EAAA0B,KAOA,IADA,IAAAK,EAAA/B,EAAAxB,IAAA,GACAnM,EAAA,EAAA2P,EAAAD,EAAA3hB,OAAsDiS,EAAA2P,EAAiB3P,IACvEuP,EAAAhhB,KAAA,CACA4d,IAAAuD,EAAA1P,GACAqP,KAAA1B,EAAA0B,KAAA,EACAG,OAAA7B,EAAAxB,IACAsD,UAAAzP,SAXA2N,EAAAxB,IAAA,KAAAiD,EAAAjD,IAAA,IACAmD,EAAA/gB,KAAAof,GAeA,IAAAiC,EAAAN,EAAA,GAEAM,GAGA3S,EAAAuR,GAAAoB,EAAAzD,IAAAiD,EAAAjD,KACAyD,EAAAJ,OAAA,GAAAI,EAAAH,WAAAxS,EAAAiP,KACA+C,EAAA1gB,KAAA,CAAsB8d,IAAA8C,EAAA9C,IAAAF,IAAAgD,EAAAhD,MACtBiB,KAAAnQ,EAAAmQ,UACA0B,GAAA,GANAG,EAAA1gB,KAAA2gB,QASAD,EAAA1gB,KAAA2gB,GAWA,OANAJ,GACAG,EAAA1gB,KAAA4f,GAGAc,EAAAjC,KAAAS,IAEA,CACAvB,KAAA+C,EACA7B,aAAA,iBA8DA,SAAAyC,GAAA3D,EAAAiC,EAAAzd,GACA,IAAAof,EAAAf,GAAA7C,EAAAiC,GACA4B,EA3DA,SAAA7D,EAAAxb,GAMA,IAJA,IACAsf,EAEAvT,EAHA8Q,EAAAD,GAAApB,GAIAjf,EAAA,EAAA0B,EAAA4e,EAAAxf,OAAqCd,EAAA0B,EAAS1B,IAAA,CAG9C,IAEA8e,EAFAoC,EAAAZ,EAAAtgB,GACA8iB,EAAA5B,EAAAhC,IAEA,GAAA4D,EAAAhiB,OAAA2C,EAAA,CAEAsf,IACAA,EAAA,IAEA,IAAA5B,EAAA2B,EAAAhiB,OAAA2C,EACAqb,EAAA,CACAM,IAAA8B,EAAA9B,IAAA+B,EACAjC,IAAA+B,GAAA6B,EAAA3B,IAGA,QAAA3I,EAAA,EAAqBA,EAAA2I,EAAgB3I,IAAA,CACrC,IAAApF,EAAA8N,EAAA9B,IAAA5G,EAAA,IAAAsK,EAAAtK,GAAAtG,GACA6Q,EAAA3P,IAAA,QAGA0L,EAAA,CACAM,IAAA8B,EAAA9B,IACAF,IAAA+B,GAAA6B,EAAA,IAOAtT,EADAA,EACAsS,GAAAtS,EAAAsP,GAAA,GAAAG,KAEA,CAAAH,GAYA,OAPAiE,GACAzD,GAAA9P,EAAA,SAAAqQ,EAAAT,EAAA4D,UAEAD,EAAA3D,EAAA,IAAA4D,KAIA,CACA/D,KAAAzP,EACA+P,KAAAwD,EAAAtkB,OAAAmC,KAAAmiB,GAAA,IAMAE,CAAAJ,EAAA5D,KAAAxb,GACA,OACAwb,KAAA6D,EAAA7D,KACA8D,YAAAD,EAAAvD,KACAY,UAAA0C,EAAA1C,WAwBA,SAAA+C,GAAApE,GACA,OAAAA,EAAAI,IAMA,SAAAiE,GAAAzE,EAAAtL,GACAA,IACAA,EAAAqL,GAAAC,IAMA,IAJA,IAGAO,EAHA/M,EAAAkB,EAAA1C,UAAA0C,EAAA/N,QAAA,QACA0Z,EAAAL,EAAAM,SAAAxY,IAAA0c,IAGAjE,EAAAF,EAAAtY,OAAA,CACA,GAAAwY,EAAA,KAAA/M,EACA,QAAA+M,EAAA,GAAAI,QAEAN,IAAA7O,OAAA+O,EAAA,KAIA,SAAAmE,GAAAlR,GACA,gBAAAjK,KAAAiK,GAkDA,SAAAmR,GAAAxR,EAAAzO,EAAAkM,GACE3C,EAAA,aAAYjH,KAAAhD,MACd,IAAAuJ,EAAAvJ,KACAA,KAAAmP,KAEA,IAAAyR,GADAlgB,IAAAkL,EAAAlL,GAAA,IACAkgB,SAAAxU,EAAA,SAAArD,EAAA4D,GA9wBA,IAAAkU,EAAAxV,EA+wBAtC,GA/wBAsC,EAgxBA,SA/wBA,kBADAwV,EAgxBAtX,GA/wBAsX,EAAAC,cAAAzV,GACiCpB,EAAA,aAAY6W,cAAAD,EAAAxV,IA8wB7C,GACA9B,EAAA6D,KAAA,QAAArE,IAGAQ,EAAA6D,KAAA,WAAAT,GAEApD,EAAAwX,qBACA5R,EAAAwD,eAAA,YAAAqO,KAQA,SAAAA,IACAzX,EAAA0X,SAPArU,IACArD,EAAA4I,GAAA,oBAAAxF,GACAC,EAAA,KAAAD,KAEApD,EAAA4I,GAAA,QAAAvF,IAKAuC,EAAA/C,KAAA,YAAA4U,GAEAtgB,EAAAgS,SAAA,SAAAqC,EAAAmM,EAAAC,GAEA5X,EAAA6X,aAtCA,SAAA7X,EAAAwL,EAAAmM,EAAAC,GAEA,IACA5X,EAAA6D,KAAA,SAAA2H,EAAAmM,EAAAC,GACG,MAAApc,GACHuM,EAAA,4CAAAvM,IAoCAsc,CAAA9X,EAAAwL,EAAAmM,EAAAC,IAGA,IAAAxY,EAAA,IAAAC,QAAA,SAAA8D,EAAA5D,GACApI,EAAAkgB,SAAA,SAAA7X,EAAAuE,GACAvE,EACAD,EAAAC,GAEA2D,EAAAY,MAIA/D,EAAA6C,KAAA,oBACA+C,EAAAwD,eAAA,YAAAqO,GACAtgB,EAAAkgB,SAAA,MAAyB9O,OAAA,gBAEzB9R,KAAAwJ,KAAAb,EAAAa,KAAAzM,KAAA4L,GACA3I,KAAA,MAAA2I,EAAA,MAAA5L,KAAA4L,GACA3I,KAAAwJ,KAAA,SAAAsD,GACA8T,EAAA,KAAA9T,IACG8T,GAIHzR,EAAAzB,UAAAC,QAWApE,EAAA+X,gBAAA5gB,GAVAyO,EAAAzB,UAAAE,QAAA,SAAAC,GACAA,EACAnN,EAAAkgB,SAAA/S,GACOtE,EAAA6X,YACP7X,EAAA6D,KAAA,UAEA7D,EAAA+X,gBAAA5gB,KAaA,SAAA6gB,GAAAvM,EAAAgH,EAAAtb,GACA,IAAA8gB,EAAA,EAAqB9Q,IAAAsE,EAAAqC,OACrB,aAAA3W,EAAAe,QACA+f,EAAAvE,GAAAjB,EAAAM,UACAxY,IAAA,SAAA1E,GAAuB,OAASsR,IAAAtR,EAAAsR,QAEhC,IAAAqE,EAAA,CACAvF,GAAAwM,EAAAxM,GACA6C,QAAAmP,EACAxM,OAYA,OATAyL,GAAAzE,EAAAhH,EAAAqC,QACAtC,EAAA4H,SAAA,GAEAjc,EAAA+c,YACA1I,EAAAC,IAAAyM,WAAAlE,GAAAvB,GACAjH,EAAAC,IAAAyM,WAAArjB,eACA2W,EAAAC,IAAAyM,YAGA1M,EAyFA,SAAA2M,GAAAC,EAAAC,GACA,OAAAD,EAAAC,GAAA,EAAAD,EAAAC,EAAA,IAKA,SAAAC,GAAAjV,EAAAwD,GACA,gBAAArH,EAAA8G,GACA9G,GAAA8G,EAAA,IAAAA,EAAA,GAAAtP,QACAwI,KAAA8G,EAAA,IACAO,QACAxD,EAAA7D,IAEA6D,EAAA,KAAAiD,EAAAzR,OAAAyR,EAAA,GAAAA,IAwBA,SAAAiS,GAAA9G,EAAAgC,GACA,IAAA+E,EAAAL,GAAA1G,EAAAxD,IAAAwF,EAAAxF,KACA,WAAAuK,EACAA,EAIAL,GAFA1G,EAAAgH,WAAAhH,EAAAgH,WAAA5H,MAAA,EACA4C,EAAAgF,WAAAhF,EAAAgF,WAAA5H,MAAA,GAmFA,SAAA6H,KAIA,QAAA1N,KAHEtK,EAAA,aAAYjH,KAAAhD,MAGdiiB,GAAA3lB,UACA,mBAAA0D,KAAAuU,KACAvU,KAAAuU,GAAAvU,KAAAuU,GAAAxX,KAAAiD,OAsxBA,SAAAkiB,KACAliB,KAAA2N,SAAA,EACA3N,KAAA6N,QAAA,EACA7N,KAAAgf,MAAA,GA2GA,SAAAmD,GAAAtf,EAAAnC,GAGA,KAAAV,gBAAAmiB,IACA,WAAAA,GAAAtf,EAAAnC,GAGA,IAAA6I,EAAAvJ,KAkBA,GAjBAU,KAAA,GAEAmC,GAAA,iBAAAA,IAEAA,GADAnC,EAAAmC,GACAA,YACAnC,EAAAmC,WAGA4D,IAAA/F,EAAA+a,qBACA/a,EAAA+a,oBAAA,GAGAzb,KAAAoiB,OAAA1hB,EAAAkL,EAAAlL,GAEA6I,EAAA8Y,gBAAA3hB,EAAA2hB,gBACA9Y,EAAA+Y,OAAAH,GAAAG,OAEA,iBAAAzf,EACA,UAAA1C,MAAA,2BAGA,IACAoiB,EAvGA,SAAA1f,EAAAnC,GACA,IAAAkD,EAAAf,EAAAe,MAAA,sBACA,GAAAA,EAEA,OACAf,KAAA,SAAA0C,KAAA3B,EAAA,IAAAA,EAAA,SAAAA,EAAA,GAAAA,EAAA,GACA4e,QAAA5e,EAAA,IAIA,IAAA6e,EAAAN,GAAAM,SACAC,EAAAP,GAAAO,kBACAJ,EAAAH,GAAAG,OACAK,EAAAjiB,EAAA8hB,QAEA,IAAAG,EACA,QAAArlB,EAAA,EAAmBA,EAAAolB,EAAAtkB,QAInB,SAHAukB,EAAAD,EAAAplB,KAGA,WAAAmlB,GACAvR,KAAAH,aAAA,oBAAAuR,EAAAzf,KALiDvF,EAOjDgU,EAAA,iCAAAzO,EAAA,8EAQA,IAAA2f,EAAAC,EAAAE,GAMA,OACA9f,KAJA2f,GAAA,eAAAA,IACAA,EAAAI,WAGA/f,EAAAyf,EAAAzf,EACA2f,QAAAG,GAgEAE,EADAniB,EAAA4hB,QAAA,IAAAzf,EACAnC,GASA,GAPAA,EAAAmC,KAAA0f,EAAA1f,KACAnC,EAAA8hB,QAAA9hB,EAAA8hB,SAAAD,EAAAC,QAEAjZ,EAAA1G,OACA0G,EAAAuZ,SAAApiB,EAAA8hB,QACAL,GAAA/U,KAAA,sCAAA1M,EAAA8hB,WAEAL,GAAAM,SAAA/hB,EAAA8hB,WACAL,GAAAM,SAAA/hB,EAAA8hB,SAAAO,QACA,UAAA5iB,MAAA,oBAAAO,EAAA8hB,SAGAP,GAAAjf,KAAAuG,GACAA,EAAAmE,UAAA,IAAAwU,GAEA3Y,EAAAiZ,QAAA9hB,EAAA8hB,QAEAL,GAAAM,SAAA/hB,EAAA8hB,SAAAxf,KAAAuG,EAAA7I,EAAA,SAAAqI,GACA,GAAAA,EACA,OAAAQ,EAAAmE,UAAAsV,KAAAja,IAvEA,SAAAQ,GAEA,SAAA0Z,EAAAC,GACA3Z,EAAAoJ,eAAA,SAAAwQ,GACAD,GACA3Z,EAAAhN,YAAA6Q,KAAA,YAAA7D,EAAA1G,MAIA,SAAAsgB,IACA5Z,EAAAoJ,eAAA,YAAAsQ,GACA1Z,EAAAhN,YAAA6Q,KAAA,QAAA7D,GAGAA,EAAA6C,KAAA,YAAA6W,GACA1Z,EAAA6C,KAAA,SAAA+W,GACA5Z,EAAAhN,YAAA6Q,KAAA,MAAA7D,GAyDA6Z,CAAA7Z,GAEAA,EAAA6D,KAAA,UAAA7D,GACA4Y,GAAA/U,KAAA,UAAA7D,EAAA1G,MACA0G,EAAAmE,UAAA2V,MAAA9Z,KAtwCAY,IAAQwW,GAAY1W,EAAA,cAiFpB0W,GAAArkB,UAAA2kB,OAAA,WACAjhB,KAAAohB,aAAA,EACAphB,KAAAmP,GAAAzB,UAAAC,SACA3N,KAAAoN,KAAA,WA2BAuT,GAAArkB,UAAAglB,gBAAA,SAAA5gB,GACA,IAAAkM,EAAAlM,EAAAkgB,SACArX,EAAAvJ,KAGAmiB,GAAAmB,qBACAnB,GAAAmB,qBAAAC,SAAA7iB,EAAA,SAAAqI,GACA,GAAAA,EACA,OAAA6D,EAAA7D,GAEAQ,EAAAia,UAAA9iB,KAGA6I,EAAAia,UAAA9iB,IAIAigB,GAAArkB,UAAAknB,UAAA,SAAA9iB,GACA,IAAA6I,EAAAvJ,KACA4M,EAAAlM,EAAAkgB,SAcA,GAXA,SADAlgB,EAAAkL,EAAAlL,OACA,eAAAA,KACAA,EAAA+iB,WAAA/iB,EAAAgjB,MAEAhjB,EAAA6gB,iBAEA,WAAA7gB,EAAA8R,QACA9R,EAAA8R,MAAA,OAEA9R,EAAA8R,QACA9R,EAAA8R,MAAA,GAEA,QAAA9R,EAAA8R,MAAA,CAcA,GAAA2P,GAAAmB,sBAEA,GADAnB,GAAAmB,qBAAAK,UAAAjjB,GACAyhB,GAAAmB,qBAAAM,aAAA5jB,KAAAU,GACA,OAAAyhB,GAAAmB,qBAAA3S,OAAA3Q,KAAAU,OAGA,uCAAA2B,QAAA,SAAAsB,GACAA,KAAAjD,GACA4Q,EAAA,OACA,QAAA3N,EAAA,wKAQA,eAAAjD,IACAA,EAAAmjB,YAAA,GAIAnjB,EAAAojB,MAAA,IAAApjB,EAAAojB,MAAA,EAAApjB,EAAAojB,MACApjB,EAAAkgB,SAAAhU,EACA,IAAAmX,EAAA/jB,KAAAmP,GAAA6U,SAAAtjB,GAEA,GAAAqjB,GAAA,mBAAAA,EAAA9C,OAAA,CACA,IAAAA,EAAA1X,EAAA0X,OACA1X,EAAA0X,OAAkBnX,IAAY,SAAA/K,GAC9BglB,EAAA9C,SACAA,EAAAlhB,MAAAC,KAAAjB,WA3CAiB,KAAAmP,GAAAW,OAAAtG,KAAA,SAAAsG,GAEAvG,EAAA6X,YACAxU,EAAA,MAAwBkF,OAAA,eAGxBpR,EAAA8R,MAAA1C,EAAAmU,WACA1a,EAAAia,UAAA9iB,KACKkM,IAwKLzC,IAAQ8X,GAAkBhY,EAAA,cAa1BgY,GAAA3lB,UAAA4nB,KACAnX,EAAA,gBAAAiI,EAAAtU,EAAAkM,GAKA,GAJA,mBAAAlM,IACAkM,EAAAlM,EACAA,EAAA,IAEA,iBAAAsU,GAAA5X,MAAAkG,QAAA0R,GACA,OAAApI,EAAAyH,GAAAJ,KAEAjU,KAAAmkB,SAAA,CAAiB9U,KAAA,CAAA2F,IAAYtU,EAAAmhB,GAAAjV,EAAAoI,EAAAwC,QAG7ByK,GAAA3lB,UAAAmb,IAAA1K,EAAA,eAAAiI,EAAAtU,EAAAyH,GAKA,GAJA,mBAAAzH,IACAyH,EAAAzH,EACAA,EAAA,IAEA,iBAAAsU,GAAA5X,MAAAkG,QAAA0R,GACA,OAAA7M,EAAAkM,GAAAJ,KAGA,GADAyB,GAAAV,EAAAwC,KACAkJ,GAAA1L,EAAAwC,MAAA,mBAAAxX,KAAAokB,UACA,OAAApP,EAAAqP,SACArkB,KAAAskB,aAAAtP,EAAA7M,GAEAnI,KAAAokB,UAAApP,EAAA7M,GAGA,IAYA4N,EACAwO,EAGAC,EACAC,EAjBAlb,EAAAvJ,KA0BA,SAAA0kB,EAAAzJ,GACA,mBAAA1R,EAAAob,OAAA,IAAAjkB,EAAAkkB,UACArb,EAAAob,KAAA3P,EAAAtU,EAAAua,GAEA1R,EAAA4a,SAAA,CAAqB9U,KAAA,CAAA2F,IAAYtU,EAAAmhB,GAAA5G,EAAAjG,EAAAwC,MA7BjC9W,EAAAmkB,OAAA7P,EAAAqC,MAWAtB,EAAAf,EAAAqC,KAAA7S,MAAA,KACA+f,EAAAxO,EAAA,GAGAyO,EAFA9S,SAAAqE,EAAA,OAEA,EACA0O,EAAAjJ,KAEAxG,EAAAgN,WAAA,CACA5H,MAAAoK,EACAhI,IAAA,CAAAiI,EAAAF,IAEAvP,EAAAqC,KAAAmN,EAAA,IAAAC,EACA/jB,EAAAkkB,WAAA,EArBAF,EAAA,SAAA3b,GACA,IAAA+D,EAAA/D,EAAA,MAAiCkG,IAAA,EAAAO,GAAAwF,EAAAwC,IAAA9G,IAAAsE,EAAAqC,MACjClP,EAAAY,EAAA+D,MAGA4X,EAAAvc,KA2BA8Z,GAAA3lB,UAAAwoB,cACA/X,EAAA,yBAAAqD,EAAA2U,EAAArU,EACAsI,EAAA3N,GACA,IAAA2Z,EAAAhlB,KAiBA,SAAAilB,EAAAjQ,GACA,IAAAkQ,EAAA,SAAAlQ,EAAAtD,SAAAsD,EAAAqC,KAAA,MAOA,OANArC,EAAAM,aAAAN,EAAAM,cAAA,GACAN,EAAAM,aAAAyP,GAAA,CACAI,aAAA9Z,EACAoJ,KAAAuE,EACAoM,SAAAF,GAEAF,EAAAvN,IAAAzC,GAGA,MA3BA,mBAAA3J,IACAA,EAAA2N,EACAA,EAAAtI,EACAA,EAAA,WAIA,IAAArF,IACAA,EAAA2N,EACAA,EAAAtI,EACAA,EAAA,MAEArF,GACAiG,EAAA,oBAAAyT,EAAA,cAAA3U,EAAA,2BAcA4U,EAAA1gB,IAAA8L,GAAA5G,KAAA,SAAAwL,GACA,GAAAA,EAAAqC,OAAA3G,EACA,MAAA2D,GAAAb,GAGA,OAAAyR,EAAAjQ,IACG,SAAAjM,GAGH,GAAAA,EAAAb,SAAAqL,EAAAF,QACA,OAAA4R,EAAA,CAA+BzN,IAAApH,IAE/B,MAAArH,MAKAkZ,GAAA3lB,UAAA+oB,iBACAtY,EAAA,4BAAAqD,EAAA2U,EAAArU,EACA9D,GACA,IAAArD,EAAAvJ,KACAuJ,EAAAjF,IAAA8L,EAAA,SAAArH,EAAA9K,GAEA,GAAA8K,EACA6D,EAAA7D,QAGA,GAAA9K,EAAAoZ,OAAA3G,EAAA,CAKA,IAAAzS,EAAAqX,aACA,OAAA1I,WAEA3O,EAAAqX,aAAAyP,GACA,IAAAhpB,OAAAmC,KAAAD,EAAAqX,cAAAlX,eACAH,EAAAqX,aAEA/L,EAAAkO,IAAAxZ,EAAA2O,QAXAA,EAAAyH,GAAAb,QAeAyO,GAAA3lB,UAAAgpB,OACAvY,EAAA,kBAAAwY,EAAAC,EAAA9kB,EAAAkM,GACA,IAAAoI,EACA,iBAAAwQ,GAEAxQ,EAAA,CACAwC,IAAA+N,EACAlO,KAAAmO,GAEA,mBAAA9kB,IACAkM,EAAAlM,EACAA,EAAA,MAIAsU,EAAAuQ,EACA,mBAAAC,GACA5Y,EAAA4Y,EACA9kB,EAAA,KAEAkM,EAAAlM,EACAA,EAAA8kB,KAGA9kB,KAAA,IACA+kB,YAAA,EACA,IAAAnO,EAAA,CAAgBE,IAAAxC,EAAAwC,IAAAH,KAAArC,EAAAqC,MAAA3W,EAAAgQ,IAChB2T,UAAA,GACA,GAAA3D,GAAApJ,EAAAE,MAAA,mBAAAxX,KAAAskB,aACA,OAAAtkB,KAAAskB,aAAAtP,EAAApI,GAEA5M,KAAAmkB,SAAA,CAAiB9U,KAAA,CAAAiI,IAAe5W,EAAAmhB,GAAAjV,EAAA0K,EAAAE,QAGhCyK,GAAA3lB,UAAAopB,SACA3Y,EAAA,oBAAA4H,EAAAjU,EAAAkM,GACA,mBAAAlM,IACAkM,EAAAlM,EACAA,EAAA,IAEA,IAAA8b,EAAAzgB,OAAAmC,KAAAyW,GAEA,IAAA6H,EAAApe,OACA,OAAAwO,EAAA,SAGA,IAAA+Y,EAAA,EACAC,EAAA,IAAApa,EAEA,SAAAqa,EAAArW,EAAAsW,GACAF,EAAArX,IAAAiB,IACAoW,EAAArhB,IAAAiL,EAAA,CAAuBoW,QAAA,KAEvBA,EAAAthB,IAAAkL,GAAAoW,QAAAhnB,KAAAknB,GA4BAtJ,EAAA1Y,IAAA,SAAA0L,GACAxP,KAAA+lB,iBAAAvW,EAAA,SAAAzG,EAAAuT,GACA,GAAAvT,GAAA,MAAAA,EAAA+I,QAAA,YAAA/I,EAAAsK,QACAuS,EAAArhB,IAAAiL,EAAA,CAAyBoW,QAAAjR,EAAAnF,SAClB,IAAAzG,EAEP,OAAA6D,EAAA7D,IA/BA,SAAAyG,EAAA8M,GAEA,IAAA0J,EAAArR,EAAAnF,GAAA1E,MAAA,GACA8R,GAAAN,EAAA,SAAAa,EAAAT,EAAA4D,EAAA3f,EACAD,GACA,IAAAgQ,EAAAgM,EAAA,IAAA4D,EACA/d,EAAAyjB,EAAArjB,QAAA+N,IACA,IAAAnO,IAIAyjB,EAAA1H,OAAA/b,EAAA,GAEA,cAAA7B,EAAAoR,QACA+T,EAAArW,EAAAkB,MAMAsV,EAAA3jB,QAAA,SAAAqO,GACAmV,EAAArW,EAAAkB,KAYAuV,CAAAzW,EAAA8M,GAGA,KAAAqJ,IAAAnJ,EAAApe,OAAA,CAEA,IAAA8nB,EAAA,GAIA,OAHAN,EAAAvjB,QAAA,SAAA7F,EAAAmH,GACAuiB,EAAAviB,GAAAnH,IAEAoQ,EAAA,KAAAsZ,OAGGlmB,QAUHiiB,GAAA3lB,UAAA4S,QACAnC,EAAA,mBAAArM,EAAAkM,GACAsC,EAAAlP,KAAAU,EAAAkM,KAMAqV,GAAA3lB,UAAA6pB,gBACApZ,EAAA,2BAAAqD,EAAAgW,EAAAxZ,GACA,IAAArD,EAAAvJ,KACAA,KAAA+lB,iBAAA3V,EAAA,SAAArH,EAAAsd,GAEA,GAAAtd,EACA,OAAA6D,EAAA7D,GAEA,IAAAud,EAhWA,SAAAzJ,GACA,IAAAyJ,EAAA,GACAC,EAAA,GAoBA,OAnBA3J,GAAAC,EAAA,SAAAM,EAAAT,EAAAlN,EAAAgX,GACA,IAAA9V,EAAAgM,EAAA,IAAAlN,EAOA,OANA2N,IACAmJ,EAAA5V,GAAA,QAEAjK,IAAA+f,GACAD,EAAA3nB,KAAA,CAAkB6nB,KAAAD,EAAAxT,GAAAtC,IAElBA,IAGA6V,EAAAjJ,UACAiJ,EAAAlkB,QAAA,SAAAqkB,QACAjgB,IAAA6f,EAAAI,EAAAD,MACAH,EAAAI,EAAAD,MAAA,EAAAH,EAAAI,EAAA1T,IAEAsT,EAAAI,EAAAD,MAAAlpB,KAAA2S,IAAAoW,EAAAI,EAAAD,MAAA,EAAAH,EAAAI,EAAA1T,OAGAsT,EA0UAK,CAAAN,GACAO,EAAA,GACA/J,EAAA,GACA9gB,OAAAmC,KAAAooB,GAAAjkB,QAAA,SAAAqO,GACA4V,EAAA5V,GAAA0V,GACAQ,EAAAhoB,KAAA8R,KAIAkM,GAAAyJ,EAAA,SAAAlJ,EAAAT,EAAA4D,EAAA3f,EAAAD,GACA,IAAAgQ,EAAAgM,EAAA,IAAA4D,EACA,cAAA5f,EAAAoR,SAAA,IAAA8U,EAAAjkB,QAAA+N,IACAmM,EAAAje,KAAA8R,KAGAnH,EAAAsd,cAAAzW,EAAAyM,EAAAjQ,OAMAqV,GAAA3lB,UAAAwqB,QACA/Z,EAAA,mBAAArM,EAAAkM,GACA,mBAAAlM,IACAkM,EAAAlM,EACAA,EAAA,IAIAA,KAAA,GADAV,KAGA+mB,iBAHA/mB,KAGA+mB,kBAAA,GAHA/mB,KAIA+mB,iBAAAnoB,KAAA,CAA8B8B,OAAAkM,aAC9B,IALA5M,KAKA+mB,iBAAA3oB,QAzVA,SAAA4oB,EAAAzd,GACA,IAAA0d,EAAA1d,EAAAwd,iBAAA,GACArmB,EAAAumB,EAAAvmB,KACAkM,EAAAqa,EAAAra,SACArD,EAAAjF,IAAA,qBAAA4iB,MAAA,WACA,WACG1d,KAAA,SAAAwL,GACHA,KAAAmS,WACAzmB,EAAAymB,SAAAnS,EAAAmS,UAEA5d,EAAA6d,SAAA1mB,EAAA,SAAAqI,EAAAuE,GAEAvE,EACA6D,EAAA7D,GAEA6D,EAAA,KAAAU,GAEMtD,IAAQ,WACdT,EAAAwd,iBAAAM,QACA9d,EAAAwd,iBAAA3oB,QACA4oB,EAAAzd,SAsUAyd,CANAhnB,QASAiiB,GAAA3lB,UAAA8qB,SAAA,SAAA1mB,EAAAkM,GACA,IAAArD,EAAAvJ,KACAoS,EAAA,CACAkV,aAAA,EACAH,SAAAzmB,EAAAymB,UAAA,GAEAI,EAAA,GAmBAhe,EAAA8I,QAAAD,GACAD,GAAA,SAlBA,SAAAqV,GACAD,EAAA3oB,KAAA2K,EAAA4c,gBAAAqB,EAAAhY,GAAA,MAkBA2C,GAAA,WAhBA,SAAAxF,GACA,IAAAwU,EAAAxU,EAAAwa,SACAve,QAAA6e,IAAAF,GAAA/d,KAAA,WACA,OAAA0N,GAAA3N,EAAA,6BAAAyL,GACA,QAAAA,EAAAmS,UAAAnS,EAAAmS,SAAAhG,KACAnM,EAAAmS,SAAAhG,EACAnM,OAIKxL,KAAA,WACLoD,EAAA,MAAsBqC,IAAA,MACjBiY,MAAAta,KAKLuF,GAAA,QAAAvF,IAKAqV,GAAA3lB,UAAAgI,IAAAyI,EAAA,eAAAyC,EAAA9O,EAAAyH,GAKA,GAJA,mBAAAzH,IACAyH,EAAAzH,EACAA,EAAA,IAEA,iBAAA8O,EACA,OAAArH,EAAAkM,GAAAZ,IAEA,GAAAiN,GAAAlR,IAAA,mBAAAxP,KAAA0nB,UACA,OAAA1nB,KAAA0nB,UAAAlY,EAAArH,GAEA,IAAA+U,EAAA,GAAA3T,EAAAvJ,KAEA,SAAA2nB,IACA,IAAA7a,EAAA,GACA6Y,EAAAzI,EAAA9e,OAEA,IAAAunB,EACA,OAAAxd,EAAA,KAAA2E,GAIAoQ,EAAA7a,QAAA,SAAAqb,GACAnU,EAAAjF,IAAAkL,EAAA,CACAkB,IAAAgN,EACAb,KAAAnc,EAAAmc,KACA+K,OAAAlnB,EAAAknB,OACAxS,YAAA1U,EAAA0U,YACAkE,OAAA5Y,EAAA4Y,QACO,SAAAvQ,EAAAiM,GACP,GAAAjM,EAaA+D,EAAAlO,KAAA,CAAuBgnB,QAAAlI,QAbvB,CAGA,IADA,IAAAmK,EACAvqB,EAAA,EAAAkG,EAAAsJ,EAAA1O,OAA4Cd,EAAAkG,EAAOlG,IACnD,GAAAwP,EAAAxP,GAAA2R,IAAAnC,EAAAxP,GAAA2R,GAAAoI,OAAArC,EAAAqC,KAAA,CACAwQ,GAAA,EACA,MAGAA,GACA/a,EAAAlO,KAAA,CAAyBqQ,GAAA+F,MAKzB2Q,GAEAxd,EAAA,KAAA2E,OAMA,IAAApM,EAAA+P,UA8BA,OAAAzQ,KAAA8nB,KAAAtY,EAAA9O,EAAA,SAAAqI,EAAA+D,GACA,GAAA/D,EAEA,OADAA,EAAAqH,MAAAZ,EACArH,EAAAY,GAGA,IAAAiM,EAAAlI,EAAAkI,IACAgH,EAAAlP,EAAAkP,SACArb,EAAAmM,EAAAnM,IAEA,GAAAD,EAAA+c,UAAA,CACA,IAAAA,EAAAF,GAAAvB,GACAyB,EAAArf,SACA4W,EAAAyM,WAAAhE,GAQA,GAJAgD,GAAAzE,EAAAhH,EAAAqC,QACArC,EAAAqP,UAAA,GAGA3jB,EAAAmc,MAAAnc,EAAAqnB,UAAA,CAQA,IAPA,IAAAC,EAAAhT,EAAAqC,KAAA7S,MAAA,KACAyjB,EAAAvW,SAAAsW,EAAA,OACA1H,EAAA0H,EAAA,GAEApK,EAAAD,GAAA3B,EAAAM,UACAkC,EAAA,KAEAlhB,EAAA,EAAqBA,EAAAsgB,EAAAxf,OAAkBd,IAAA,CACvC,IAAA4qB,EAAAtK,EAAAtgB,GACA6qB,EAAAD,EAAA1L,IAAA1Y,IAAA,SAAA1E,GAA0D,OAAAA,EAAAoQ,KAC1D7M,QAAA2d,IACA6H,IAAAF,EAAA,IAEAzJ,IAAA,IAAA2J,KACA3J,EAAA0J,GAIA,IAAAE,EAAA5J,EAAAhC,IAAA1Y,IAAA,SAAA1E,GAAkD,OAAAA,EAAAoQ,KAClD7M,QAAAqS,EAAAqC,KAAA7S,MAAA,WACA6jB,EAAA7J,EAAAhC,IAAApe,OAAAgqB,EAYA,GAXA5J,EAAAhC,IAAA8B,OAAA8J,EAAAC,GACA7J,EAAAhC,IAAAc,UAEA5c,EAAAmc,OACA7H,EAAAgN,WAAA,CACA5H,MAAAoE,EAAA9B,IAAA8B,EAAAhC,IAAApe,OAAA,EACAoe,IAAAgC,EAAAhC,IAAA1Y,IAAA,SAAA4M,GACA,OAAAA,EAAAlB,OAIA9O,EAAAqnB,UAAA,CACA,IAAArL,EAAA8B,EAAA9B,IAAA8B,EAAAhC,IAAApe,OACA4W,EAAAsT,WAAA9J,EAAAhC,IAAA1Y,IAAA,SAAA4M,GAEA,OACAA,MAFAgM,EAEA,IAAAhM,EAAAlB,GACAsC,OAAApB,EAAAhQ,KAAAoR,WAMA,GAAApR,EAAA0U,aAAAJ,EAAAM,aAAA,CACA,IAAAF,EAAAJ,EAAAM,aACAqQ,EAAA5pB,OAAAmC,KAAAkX,GAAAhX,OACA,OAAAunB,EACA,OAAAxd,EAAA,KAAA6M,GAEAjZ,OAAAmC,KAAAkX,GAAA/S,QAAA,SAAAsB,GACA3D,KAAAuoB,eAAAvT,EAAAwC,IAAA7T,EAAAyR,EAAAzR,GAAA,CAIA+M,IAAAsE,EAAAqC,KACAiC,OAAA5Y,EAAA4Y,OACA3Y,OACS,SAAAoI,EAAA0L,GACT,IAAAY,EAAAL,EAAAM,aAAA3R,GACA0R,EAAAZ,cACAY,EAAAE,YACAF,EAAAjX,SACAunB,GACAxd,EAAA,KAAA6M,MAGOzL,OACF,CACL,GAAAyL,EAAAM,aACA,QAAA3R,KAAAqR,EAAAM,aAEAN,EAAAM,aAAA7R,eAAAE,KACAqR,EAAAM,aAAA3R,GAAA4R,MAAA,GAIApN,EAAA,KAAA6M,MAhIA,WAAAtU,EAAA+P,UACAzQ,KAAA+lB,iBAAAvW,EAAA,SAAAzG,EAAAuT,GAEA,GAAAvT,EACA,OAAAZ,EAAAY,GAEAmU,EAAAD,GAAAX,GAAAxY,IAAA,SAAA4Z,GACA,OAAAA,EAAAhN,MAEAiX,UAEK,CACL,IAAAvqB,MAAAkG,QAAA5C,EAAA+P,WAWA,OAAAtI,EAAAkM,GAAAT,EAAA,oBAVAsJ,EAAAxc,EAAA+P,UACA,QAAAnT,EAAA,EAAuBA,EAAA4f,EAAA9e,OAAmBd,IAAA,CAC1C,IAAAkG,EAAA0Z,EAAA5f,GAEA,gCAAAiI,KAAA/B,GACA,OAAA2E,EAAAkM,GAAAF,KAGAwT,OAmHA1F,GAAA3lB,UAAAksB,cACAzb,EAAA,yBAAAqD,EAAA2U,EAAArkB,EAAAkM,GACA,IAAArD,EAAAvJ,KACAU,aAAAgL,WACAkB,EAAAlM,EACAA,EAAA,IAEAV,KAAA8nB,KAAA1X,EAAA1P,EAAA,SAAAqI,EAAAuE,GACA,OAAAvE,EACA6D,EAAA7D,GAEAuE,EAAA0H,IAAAM,cAAAhI,EAAA0H,IAAAM,aAAAyP,IACArkB,EAAAC,IAAA2M,EAAA3M,IACAD,EAAA4Y,QAAA,OACA/P,EAAAgf,eAAAnY,EAAA2U,EACAzX,EAAA0H,IAAAM,aAAAyP,GAAArkB,EAAAkM,IAEAA,EAAAyH,GAAAd,QAKA0O,GAAA3lB,UAAAmsB,QACA1b,EAAA,mBAAArM,EAAAkM,GAYA,GAXA,mBAAAlM,IACAkM,EAAAlM,EACAA,EAAA,IAEAA,EAAAgoB,UAAA,IAAAhoB,EAAAgoB,KAAAhoB,EAAAgoB,KAAA,EACAhoB,EAAAioB,YACAjoB,EAAAkoB,SAAAloB,EAAAioB,WAEAjoB,EAAAmoB,UACAnoB,EAAAooB,OAAApoB,EAAAmoB,SAEA,SAAAnoB,EAAA,CACA,IAAAtD,MAAAkG,QAAA5C,EAAAxC,MACA,OAAA0O,EAAA,IAAArE,UAAA,kCAEA,IAAAwgB,EACA,4BAAApY,OAAA,SAAAoY,GACA,OAAAA,KAAAroB,IACK,GACL,GAAAqoB,EAKA,YAJAnc,EAAAyH,GAAAP,EACA,oBAAAiV,EACA,uCAIA,IAAApT,GAAA3V,QA7nBA,SAAAU,GACA,IAAAxC,EAAA,UAAAwC,EACAA,EAAAxC,KAAA4M,MAAApK,EAAAgoB,KAAAhoB,EAAAojB,MAAApjB,EAAAgoB,MACAhoB,EAAAgoB,KAAA,EAAAhoB,EAAAxC,KAAA4M,MAAApK,EAAAgoB,MAAAhoB,EAAAxC,KACAwC,EAAAxC,OACAwC,EAAAgoB,KAAA,SACAhoB,EAAAojB,MACApjB,EAAAmjB,aACA3lB,EAAAof,UACA5c,EAAAmjB,YAAA,GAqnBAmF,CAAAtoB,GACA,IAAAA,EAAAxC,KAAAE,QACA,OAAA4B,KAAAipB,SAAA,CAA8BnF,MAAA,GAASlX,GAKvC,OAAA5M,KAAAipB,SAAAvoB,EAAAkM,KAGAqV,GAAA3lB,UAAA+V,QAAA,SAAA3R,EAAAkM,GAaA,MAZA,mBAAAlM,IACAkM,EAAAlM,EACAA,EAAA,KAGAA,KAAA,IAKA4mB,YAAA,gBAAA5mB,IAAA4mB,aAAA5mB,EAAAgjB,KAEA,IAAA/C,GAAA3gB,KAAAU,EAAAkM,IAGAqV,GAAA3lB,UAAA4sB,MAAAnc,EAAA,iBAAAH,GAGA,OAFA5M,KAAAgN,SAAA,EACAhN,KAAAoN,KAAA,UACApN,KAAAmpB,OAAAvc,KAGAqV,GAAA3lB,UAAAwT,KAAA/C,EAAA,gBAAAH,GACA,IAAArD,EAAAvJ,KACAA,KAAAopB,MAAA,SAAArgB,EAAA+G,GACA,GAAA/G,EACA,OAAA6D,EAAA7D,GAGA+G,EAAAuZ,QAAAvZ,EAAAuZ,SAAA9f,EAAA1G,KACAiN,EAAAuS,mBAAA9Y,EAAA8Y,iBAAA1M,GAAApM,IACAuG,EAAA0S,QAAAjZ,EAAAiZ,QACA5V,EAAA,KAAAkD,OAIAmS,GAAA3lB,UAAAkT,GAAAzC,EAAA,cAAAH,GACA,OAAA5M,KAAAwX,IAAA5K,KAIAqV,GAAA3lB,UAAA+O,KAAA,WACA,yBAAArL,KAAAspB,MAAAtpB,KAAAspB,QAAAtpB,KAAAwiB,SAGAP,GAAA3lB,UAAA6nB,SACApX,EAAA,oBAAA4H,EAAAjU,EAAAkM,GAcA,GAbA,mBAAAlM,IACAkM,EAAAlM,EACAA,EAAA,IAGAA,KAAA,GAEAtD,MAAAkG,QAAAqR,KACAA,EAAA,CACAtF,KAAAsF,KAIAA,MAAAtF,OAAAjS,MAAAkG,QAAAqR,EAAAtF,MACA,OAAAzC,EAAAyH,GAAAf,IAGA,QAAAhW,EAAA,EAAiBA,EAAAqX,EAAAtF,KAAAjR,SAAqBd,EACtC,oBAAAqX,EAAAtF,KAAA/R,IAAAF,MAAAkG,QAAAqR,EAAAtF,KAAA/R,IACA,OAAAsP,EAAAyH,GAAAJ,KAIA,IAAAsV,EAYA,GAXA5U,EAAAtF,KAAAhN,QAAA,SAAA2S,GACAA,EAAAM,cACAvZ,OAAAmC,KAAA8W,EAAAM,cAAAjT,QAAA,SAAAQ,GACA0mB,KAxqBA,SAAA1mB,GACA,YAAAA,EAAA2mB,OAAA,IACA3mB,EAAA,0EAsqBA4mB,CAAA5mB,GACAmS,EAAAM,aAAAzS,GAAAsiB,cACA7T,EAAA,oBAAAzO,EAAA,cAAAmS,EAAAwC,IAAA,+BAMA+R,EACA,OAAA3c,EAAAyH,GAAAL,EAAAuV,IAGA,cAAA7oB,IAEAA,EAAAkkB,YADA,cAAAjQ,IACAA,EAAAiQ,WAMA,IAAApC,EAAAxiB,KACAU,EAAAkkB,WAAAjP,GAAA6M,IAGA7N,EAAAtF,KAAAgO,KAAAyE,IAjyBA,SAAAzS,GACA,QAAA/R,EAAA,EAAiBA,EAAA+R,EAAAjR,OAAiBd,IAAA,CAClC,IAAA0X,EAAA3F,EAAA/R,GACA,GAAA0X,EAAAqP,gBACArP,EAAAM,kBACK,GAAAN,EAAAM,aAGL,IADA,IAAAoU,EAAA3tB,OAAAmC,KAAA8W,EAAAM,cACAjF,EAAA,EAAqBA,EAAAqZ,EAAAtrB,OAAiBiS,IAAA,CACtC,IAAAgF,EAAAqU,EAAArZ,GACA2E,EAAAM,aAAAD,GAAAjH,EAAA4G,EAAAM,aAAAD,GACA,6DAyxBAsU,CAAAhV,EAAAtF,MAKA,IAAAmN,EAAA7H,EAAAtF,KAAAvL,IAAA,SAAAkR,GACA,OAAAA,EAAAwC,MAGA,OAAAxX,KAAA4pB,UAAAjV,EAAAjU,EAAA,SAAAqI,EAAAuE,GACA,GAAAvE,EACA,OAAA6D,EAAA7D,GASA,GAPArI,EAAAkkB,YAEAtX,IAAAqD,OAAA,SAAAvR,GACA,OAAAA,EAAAmB,UAIAoV,GAAA6M,GACA,QAAAllB,EAAA,EAAAkG,EAAA8J,EAAAlP,OAAqCd,EAAAkG,EAAOlG,IAC5CgQ,EAAAhQ,GAAAkS,GAAAlC,EAAAhQ,GAAAkS,IAAAgN,EAAAlf,GAIAsP,EAAA,KAAAU,OAIA2U,GAAA3lB,UAAAutB,0BACA9c,EAAA,qCAAA+c,EACAld,GACA,IAAAmd,EAAA,IAAA/pB,KAAAzD,YAAAutB,EAAA9pB,KAAAoiB,QAUAlL,GAAAlX,KAAA,6BARA,SAAAgV,GAEA,OADAA,EAAAgV,aAAAhV,EAAAgV,cAAA,IACAhV,EAAAgV,aAAAF,KAGA9U,EAAAgV,aAAAF,IAAA,EACA9U,KAGAxL,KAAA,WACAoD,EAAA,MAAsBuC,GAAA4a,MACjB7C,MAAAta,KAGLqV,GAAA3lB,UAAAgf,QACAvO,EAAA,mBAAArM,EAAAkM,GAEA,mBAAAlM,IACAkM,EAAAlM,EACAA,EAAA,IAGA,IAAA6I,EAAAvJ,KACAiqB,IAAA,eAAA1gB,MAAAqZ,WAEA,SAAAsH,IAEA3gB,EAAA4gB,SAAAzpB,EAAA,SAAAqI,EAAA4D,GACA,GAAA5D,EACA,OAAA6D,EAAA7D,GAEAQ,EAAA0D,YAAA,EACA1D,EAAA6D,KAAA,aACAR,EAAA,KAAAD,GAAA,CAA8BsC,IAAA,MAI9B,GAAA0G,GAAApM,GAEA,OAAA2gB,IAGA3gB,EAAAjF,IAAA,sCAAAyE,EAAAqhB,GACA,GAAArhB,EAEA,aAAAA,EAAA+I,OACAlF,EAAA7D,GAEAmhB,IAGA,IAAAF,EAAAI,EAAAJ,aACA7H,EAAA5Y,EAAAhN,YACA8tB,EAAAtuB,OAAAmC,KAAA8rB,GAAAlmB,IAAA,SAAAjB,GAGA,IAAAynB,EAAAL,EACApnB,EAAA1D,QAAA,IAAA4D,OAAA,IAAAof,EAAAG,QAAA,IAAAzf,EACA,WAAAsf,EAAAmI,EAAA/gB,EAAA6Y,QAAA9G,YAEA1S,QAAA6e,IAAA4C,GAAA7gB,KAAA0gB,EAAAtd,OAUAsV,GAAA5lB,UAAAiuB,QAAA,WACA,IAAAle,EACA,GAAArM,KAAA6N,OACA,KAAAxB,EAAArM,KAAAgf,MAAAqI,SACAhb,EAAArM,KAAA6N,aAGA,KAAAxB,EAAArM,KAAAgf,MAAAqI,SACAhb,KAKA6V,GAAA5lB,UAAA0mB,KAAA,SAAAja,GACA/I,KAAA6N,OAAA9E,EACA/I,KAAAuqB,WAGArI,GAAA5lB,UAAA+mB,MAAA,SAAAlU,GACAnP,KAAA2N,SAAA,EACA3N,KAAAmP,KACAnP,KAAAuqB,WAGArI,GAAA5lB,UAAAsR,QAAA,SAAAvB,GACArM,KAAAgf,MAAApgB,KAAAyN,GACArM,KAAA6N,QACA7N,KAAAuqB,WA4EApgB,IAAQgY,GAAAF,IAiER,IAAAjH,GAAA,oBAAAwP,gBACAA,gBACA,WAAmB,OAASC,MAAA,eAE5BC,GAAAC,MACAC,GAAAC,QAEA1I,GAAAM,SAAA,GACAN,GAAAO,kBAAA,GAEAP,GAAAG,OAAA,UAEA,IAAAwI,GAAA,IAAuB7gB,EAAA,cAEvB,SAAA8gB,GACAhvB,OAAAmC,KAAc+L,EAAA,aAAY3N,WAAA+F,QAAA,SAAAsB,GACC,mBAAZsG,EAAA,aAAY3N,UAAAqH,KAC3BonB,EAAApnB,GAAAmnB,GAAAnnB,GAAA5G,KAAA+tB,OAMA,IAAAE,EAAAD,EAAAE,sBAAA,IAAAzf,EAEAuf,EAAA5Y,GAAA,eAAAhD,GACA6b,EAAAzc,IAAAY,EAAAtM,OACAmoB,EAAAzmB,IAAA4K,EAAAtM,KAAA,IAEAmoB,EAAA1mB,IAAA6K,EAAAtM,MAAAjE,KAAAuQ,KAGA4b,EAAA5Y,GAAA,iBAAAhD,GACA,GAAA6b,EAAAzc,IAAAY,EAAAtM,MAAA,CAGA,IAAAqoB,EAAAF,EAAA1mB,IAAA6K,EAAAtM,MACA6Z,EAAAwO,EAAAvoB,QAAAwM,GACAuN,EAAA,IAIAwO,EAAA5M,OAAA5B,EAAA,GACAwO,EAAA9sB,OAAA,EAEA4sB,EAAAzmB,IAAA4K,EAAAtM,KAAAqoB,GAEAF,EAAAxc,OAAAW,EAAAtM,UAIAkoB,EAAA5Y,GAAA,qBAAAtP,GACA,GAAAmoB,EAAAzc,IAAA1L,GAAA,CAGA,IAAAqoB,EAAAF,EAAA1mB,IAAAzB,GACAmoB,EAAAxc,OAAA3L,GACAqoB,EAAA7oB,QAAA,SAAA8M,GACAA,EAAA/B,KAAA,qBAKA+d,CAAAhJ,IAEAA,GAAAK,QAAA,SAAAhT,EAAAvR,EAAAmtB,GAEAntB,EAAA8kB,UACAZ,GAAAM,SAAAjT,GAAAvR,EACAmtB,GACAjJ,GAAAO,kBAAA9jB,KAAA4Q,KAKA2S,GAAAkJ,OAAA,SAAAptB,GACA,sBAAAA,EACAA,EAAAkkB,QACG,qBAAAlkB,GAAA,IAAAlC,OAAAmC,KAAAD,GAAAG,OACH,UAAA+B,MAAA,wBAAAlC,EAAA,uCAEAlC,OAAAmC,KAAAD,GAAAoE,QAAA,SAAAmN,GACA2S,GAAA7lB,UAAAkT,GAAAvR,EAAAuR,KAMA,OAHAxP,KAAAsrB,aACAnJ,GAAAmJ,WAAAxY,EAAA,GAAiD9S,KAAAsrB,aAEjDnJ,IAGAA,GAAAoJ,SAAA,SAAAC,GACA,SAAAC,EAAA5oB,EAAAnC,GACA,KAAAV,gBAAAyrB,GACA,WAAAA,EAAA5oB,EAAAnC,GAGAA,KAAA,GAEAmC,GAAA,iBAAAA,IAEAA,GADAnC,EAAAmC,GACAA,YACAnC,EAAAmC,MAGAnC,EAAAoS,EAAA,GAAmC2Y,EAAAH,WAAA5qB,GACnCyhB,GAAAnf,KAAAhD,KAAA6C,EAAAnC,GAgBA,OAbEyJ,IAAQshB,EAAAtJ,IAEVsJ,EAAA/I,kBAAAP,GAAAO,kBAAA5X,QACA/O,OAAAmC,KAAAikB,IAAA9f,QAAA,SAAAsB,GACAA,KAAA8nB,IACAA,EAAA9nB,GAAAwe,GAAAxe,MAMA8nB,EAAAH,WAAAxY,EAAA,GAAgD9S,KAAAsrB,WAAAE,GAEhDC,GAGAtJ,GAAAwI,MAAA,SAAAe,EAAAhrB,GACA,OAAAgqB,GAAAgB,EAAAhrB,IAQA,SAAAirB,GAAA3W,EAAA4W,GAEA,IADA,IAAApvB,EAAAwY,EACA1X,EAAA,EAAA0B,EAAA4sB,EAAAxtB,OAA2Cd,EAAA0B,EAAS1B,IAAA,CAGpD,KADAd,IADAovB,EAAAtuB,KAGA,MAGA,OAAAd,EAQA,SAAAqvB,GAAAC,GAIA,IAFA,IAAAC,EAAA,GACAC,EAAA,GACA1uB,EAAA,EAAA0B,EAAA8sB,EAAA1tB,OAAyCd,EAAA0B,EAAS1B,IAAA,CAClD,IAAA2uB,EAAAH,EAAAxuB,GACA,MAAA2uB,EACA3uB,EAAA,UAAAwuB,EAAAxuB,EAAA,GACA0uB,IAAAhe,UAAA,EAAAge,EAAA5tB,OAAA,QAEA2tB,EAAAntB,KAAAotB,GACAA,EAAA,IAGAA,GAAAC,EAIA,OADAF,EAAAntB,KAAAotB,GACAD,EAGA,IAAAG,GAAA,sBACA,SAAAC,GAAAC,GACA,OAAAF,GAAAvpB,QAAAypB,IAAA,EAGA,SAAAC,GAAApuB,GACA,OAAAlC,OAAAmC,KAAAD,GAAA,GASA,SAAAquB,GAAAC,GAKA,IAAAjf,EAAA,GAqCA,OAnCAif,EAAAlqB,QAAA,SAAAmqB,GACAzwB,OAAAmC,KAAAsuB,GAAAnqB,QAAA,SAAA+pB,GACA,IAAAK,EAAAD,EAAAJ,GAKA,GAJA,iBAAAK,IACAA,EAAA,CAAmBC,IAAAD,IAGnBN,GAAAC,GACAK,aAAArvB,MACAkQ,EAAA8e,GAAAK,EAAA3oB,IAAA,SAAAwS,GACA,OAAAgW,GAAA,CAAAhW,MAGAhJ,EAAA8e,GAAAE,GAAA,CAAAG,QAEO,CACP,IAAAE,EAAArf,EAAA8e,GAAA9e,EAAA8e,IAAA,GACArwB,OAAAmC,KAAAuuB,GAAApqB,QAAA,SAAAuqB,GACA,IAAApwB,EAAAiwB,EAAAG,GAEA,cAAAA,GAAA,SAAAA,EAqBA,SAAAA,EAAApwB,EAAAmwB,GACA,YAAAA,EAAAD,IACA,YAEA,IAAAC,EAAAE,KACA,SAAAD,EACApwB,EAAAmwB,EAAAE,OACAF,EAAAE,KAAArwB,GAGAA,GAAAmwB,EAAAE,cACAF,EAAAE,KACAF,EAAAG,IAAAtwB,QAGG,IAAAmwB,EAAAG,IACH,SAAAF,EACApwB,EAAAmwB,EAAAG,aACAH,EAAAG,IACAH,EAAAE,KAAArwB,GAGAA,EAAAmwB,EAAAG,MACAH,EAAAG,IAAAtwB,GAIAmwB,EAAAC,GAAApwB,EA/CAuwB,CAAAH,EAAApwB,EAAAmwB,GACW,QAAAC,GAAA,SAAAA,EAmDX,SAAAA,EAAApwB,EAAAmwB,GACA,YAAAA,EAAAD,IACA,YAEA,IAAAC,EAAAK,KACA,SAAAJ,EACApwB,EAAAmwB,EAAAK,OACAL,EAAAK,KAAAxwB,GAGAA,GAAAmwB,EAAAK,cACAL,EAAAK,KACAL,EAAAM,IAAAzwB,QAGG,IAAAmwB,EAAAM,IACH,SAAAL,EACApwB,EAAAmwB,EAAAM,aACAN,EAAAM,IACAN,EAAAK,KAAAxwB,GAGAA,EAAAmwB,EAAAM,MACAN,EAAAM,IAAAzwB,GAIAmwB,EAAAC,GAAApwB,EA7EA0wB,CAAAN,EAAApwB,EAAAmwB,GACW,QAAAC,EAiFX,SAAApwB,EAAAmwB,GACA,QAAAA,EAEAA,EAAAQ,IAAAvuB,KAAApC,GAEAmwB,EAAAQ,IAAA,CAAA3wB,GArFA4wB,CAAA5wB,EAAAmwB,GACW,QAAAC,EAyFX,SAAApwB,EAAAmwB,UAGAA,EAAAG,WACAH,EAAAE,YACAF,EAAAM,WACAN,EAAAK,YACAL,EAAAQ,IACAR,EAAAD,IAAAlwB,EAhGA6wB,CAAA7wB,EAAAmwB,QAEAA,EAAAC,GAAApwB,UAMA8Q,EAgKA,IAAAggB,IAAA,IACAC,GAAA,EACAC,GAAA,GAEA,SAAAC,GAAAzS,EAAAgC,GAEA,GAAAhC,IAAAgC,EACA,SAGAhC,EAAA0S,GAAA1S,GACAgC,EAAA0Q,GAAA1Q,GAEA,IAAA2Q,EAAAC,GAAA5S,GACA6S,EAAAD,GAAA5Q,GACA,GAAA2Q,EAAAE,GAAA,EACA,OAAAF,EAAAE,EAEA,cAAA7S,GACA,aACA,OAAAA,EAAAgC,EACA,cACA,OAAAhC,EAAAgC,GAAA,IACA,aACA,OAsPA,SAAAhC,EAAAgC,GAIA,OAAAhC,IAAAgC,EAAA,EAAAhC,EAAAgC,EAAA,KA1PA8Q,CAAA9S,EAAAgC,GAEA,OAAA5f,MAAAkG,QAAA0X,GAyOA,SAAAA,EAAAgC,GAEA,IADA,IAAAhe,EAAAzB,KAAA2S,IAAA8K,EAAA5c,OAAA4e,EAAA5e,QACAd,EAAA,EAAiBA,EAAA0B,EAAS1B,IAAA,CAC1B,IAAA+f,EAAAoQ,GAAAzS,EAAA1d,GAAA0f,EAAA1f,IACA,OAAA+f,EACA,OAAAA,EAGA,OAAArC,EAAA5c,SAAA4e,EAAA5e,OAAA,EACA4c,EAAA5c,OAAA4e,EAAA5e,OAAA,KAlPA2vB,CAAA/S,EAAAgC,GA0PA,SAAAhC,EAAAgC,GAGA,IAFA,IAAAgR,EAAAjyB,OAAAmC,KAAA8c,GAAAiT,EAAAlyB,OAAAmC,KAAA8e,GACAhe,EAAAzB,KAAA2S,IAAA8d,EAAA5vB,OAAA6vB,EAAA7vB,QACAd,EAAA,EAAiBA,EAAA0B,EAAS1B,IAAA,CAE1B,IAAA+f,EAAAoQ,GAAAO,EAAA1wB,GAAA2wB,EAAA3wB,IACA,OAAA+f,EACA,OAAAA,EAIA,QADAA,EAAAoQ,GAAAzS,EAAAgT,EAAA1wB,IAAA0f,EAAAiR,EAAA3wB,MAEA,OAAA+f,EAIA,OAAA2Q,EAAA5vB,SAAA6vB,EAAA7vB,OAAA,EACA4vB,EAAA5vB,OAAA6vB,EAAA7vB,OAAA,KA3QA8vB,CAAAlT,EAAAgC,GAKA,SAAA0Q,GAAA/pB,GACA,cAAAA,GACA,gBACA,YACA,aACA,OAAAA,IAAAwqB,KAAAxqB,KAAAwqB,KAAAC,MAAAzqB,GACA,KAEAA,EACA,aACA,IAAA0qB,EAAA1qB,EACA,GAAAvG,MAAAkG,QAAAK,GAAA,CACA,IAAA3E,EAAA2E,EAAAvF,OACAuF,EAAA,IAAAvG,MAAA4B,GACA,QAAA1B,EAAA,EAAuBA,EAAA0B,EAAS1B,IAChCqG,EAAArG,GAAAowB,GAAAW,EAAA/wB,QAGO,IAAAqG,aAAAT,KACP,OAAAS,EAAA2qB,SACO,UAAA3qB,EAEP,QAAA4qB,KADA5qB,EAAA,GACA0qB,EACA,GAAAA,EAAA5qB,eAAA8qB,GAAA,CACA,IAAAjsB,EAAA+rB,EAAAE,QACA,IAAAjsB,IACAqB,EAAA4qB,GAAAb,GAAAprB,MAMA,OAAAqB,EAGA,SAAA6qB,GAAA7qB,GACA,UAAAA,EACA,cAAAA,GACA,cACA,OAAAA,EAAA,IACA,aACA,OA2PA,SAAA8qB,GAEA,OAAAA,EACA,UAKA,IAAAC,EAAAD,EAAAE,gBAAAnqB,MAAA,QACAoqB,EAAAld,SAAAgd,EAAA,OAEAG,EAAAJ,EAAA,EAEA3hB,EAAA+hB,EAAA,QAKAC,GA1VA7vB,IAyVA4vB,GAAAD,KAAAtB,IACA5vB,WA1VAqxB,EA0VA,IA1VAC,EA0VAzB,GApWA,SAAAtuB,EAAA8vB,EAAAC,GAIA,IAHA,IAAAC,EAAA,GACAC,EAAAF,EAAA/vB,EAAAb,OAEA6wB,EAAA7wB,OAAA8wB,GACAD,GAAAF,EAEA,OAAAE,EAIAhqB,CAAAhG,EAAA8vB,EAAAC,GACA/vB,GAFA,IAAAA,EAAA8vB,EAAAC,EA4VAliB,GAAA0gB,GAAAsB,EAGA,IAAAK,EAAA5xB,KAAA6xB,IAAAC,WAAAX,EAAA,KAEAG,IACAM,EAAA,GAAAA,GAGA,IAAAG,EAAAH,EAAAI,QAAA,IAOA,OAJAD,IAAAnwB,QAAA,aAEA2N,GAAA0gB,GAAA8B,EA7RAE,CAAA7rB,GACA,aAOA,OAAAA,EACAxE,QAAA,gBACAA,QAAA,gBACAA,QAAA,gBAEA,aACA,IAAAmE,EAAAlG,MAAAkG,QAAAK,GACA0K,EAAA/K,EAAAK,EAAA5H,OAAAmC,KAAAyF,GACArG,GAAA,EACA0B,EAAAqP,EAAAjQ,OACA0O,EAAA,GACA,GAAAxJ,EACA,OAAAhG,EAAA0B,GACA8N,GAAA2iB,GAAAphB,EAAA/Q,SAGA,OAAAA,EAAA0B,GAAA,CACA,IAAA0wB,EAAArhB,EAAA/Q,GACAwP,GAAA2iB,GAAAC,GACAD,GAAA9rB,EAAA+rB,IAGA,OAAA5iB,EAGA,SAMA,SAAA2iB,GAAA9rB,GAGA,OAAAiqB,GADAjqB,EAAA+pB,GAAA/pB,IACA6pB,GAAAgB,GAAA7qB,GAFA,KAKA,SAAAgsB,GAAA1wB,EAAA3B,GACA,IACAmxB,EADAmB,EAAAtyB,EAGA,GADA,MAAA2B,EAAA3B,GAEAmxB,EAAA,EACAnxB,QACG,CACH,IAAAuxB,EAAA,MAAA5vB,EAAA3B,GACAA,IACA,IAAAuyB,EAAA,GACAC,EAAA7wB,EAAA+O,UAAA1Q,IAAAiwB,IACAqB,EAAAld,SAAAoe,EAAA,IAAAxC,GAMA,IAJAuB,IACAD,MAEAtxB,GAAAiwB,KACA,CACA,IAAAtB,EAAAhtB,EAAA3B,GACA,UAAA2uB,EACA,MAEA4D,GAAA5D,EAEA3uB,IAIAmxB,EADA,KADAoB,IAAArrB,MAAA,MACApG,OACAsT,SAAAme,EAAA,IAGAR,WAAAQ,EAAA,OAAAA,EAAA,IAGAhB,IACAJ,GAAA,IAGA,IAAAG,IAIAH,EAAAY,WAAAZ,EAAA,IAAAG,IAGA,OAAUH,MAAArwB,OAAAd,EAAAsyB,GAKV,SAAA7rB,GAAAgsB,EAAAC,GACA,IAAA/xB,EAAA8xB,EAAAhsB,MAEA,GAAAisB,EAAA5xB,OAAA,CACA,IAAA6xB,EAAAD,IAAA5xB,OAAA,GACAH,IAAAgyB,EAAAC,UAEAF,EAAAjsB,MACAksB,EAAAD,IAAA5xB,OAAA,IAEA,IAAA8xB,EAAAD,EAAAC,QACAC,EAAAF,EAAAhd,MACA,GAAA7V,MAAAkG,QAAA4sB,GACAA,EAAAtxB,KAAAX,QACK,GAAAkyB,IAAAJ,EAAA3xB,OAAA,GAEL8xB,EADAH,EAAAhsB,OACA9F,OAEA8xB,EAAAnxB,KAAAX,IAiHA,SAAA2vB,GAAAxuB,GACA,IACAmD,EADA,uCACAI,eAAAvD,GAEA,OAAAmD,EACA,OAAAnD,EACA,EAEAhC,MAAAkG,QAAAlE,GACA,EAEAmD,EAAA,EAAAA,EAAA,EAAAA,EAAA,EAGAnF,MAAAkG,QAAAlE,GACA,OADA,EAyEA,SAAAgxB,GAAAC,EAAAC,EAAAC,GAKA,GAJAF,IAAA1f,OAAA,SAAA6W,GACA,OAAAgJ,GAAAhJ,EAAAxS,IAAAsb,EAAA9D,SAAA+D,KAGAD,EAAAjT,KAAA,CAEA,IAAAoT,EA9BA,SAAApT,GAEA,SAAAqT,EAAA1b,GACA,OAAAqI,EAAAvZ,IAAA,SAAA6sB,GACA,IACA/E,EAAAC,GADAQ,GAAAsE,IAGA,OADAhF,GAAA3W,EAAA4W,KAKA,gBAAAgF,EAAAC,GACA,IA1mBAlP,EAAAC,EA4mBAkP,EAAArD,GAFAiD,EAAAE,EAAA5b,KACA0b,EAAAG,EAAA7b,MAEA,WAAA8b,EACAA,GA9mBAnP,EAinBAiP,EAAA5b,IAAAwC,IAjnBAoK,EAinBAiP,EAAA7b,IAAAwC,IAhnBAmK,EAAAC,GAAA,EAAAD,EAAAC,EAAA,MA2nBAmP,CAAAT,EAAAjT,MACAgT,IAAAhT,KAAAoT,GACA,iBAAAH,EAAAjT,KAAA,IACA,UA5lBApf,EA4lBAqyB,EAAAjT,KAAA,IA3lBAgP,GAAApuB,MA4lBAoyB,IAAA/S,WA7lBA,IAAArf,EAimBA,aAAAqyB,GAAA,SAAAA,EAAA,CAEA,IAAA5H,EAAA4H,EAAA5H,MAAA,EACA5E,GAAA,UAAAwM,IAAAxM,MAAAuM,EAAAjyB,QAAAsqB,EACA2H,IAAAvlB,MAAA4d,EAAA5E,GAEA,OAAAuM,EAGA,SAAAG,GAAAxb,EAAAwX,EAAA+D,GACA,OAAAA,EAAAS,MAAA,SAAA5E,GACA,IAAAK,EAAAD,EAAAJ,GACAR,EAAAC,GAAAO,GACA6E,EAAAtF,GAAA3W,EAAA4W,GACA,OAAAO,GAAAC,GAoBA,SAAAA,EAAAK,EAAAzX,GAEA,WAAAoX,EACA,OAAAK,EAAAyE,KAAA,SAAAC,GACA,OAAAX,GAAAxb,EAAAmc,EAAAp1B,OAAAmC,KAAAizB,MAIA,YAAA/E,EACA,OAAAoE,GAAAxb,EAAAyX,EAAA1wB,OAAAmC,KAAAuuB,IAIA,OAAAA,EAAA2E,KAAA,SAAAD,GACA,OAAAX,GAAAxb,EAAAmc,EAAAp1B,OAAAmC,KAAAizB,MAjCAE,CAAAjF,EAAAK,EAAAzX,GAGAsc,GAAA7E,EAAAzX,EAAA4W,EAAAqF,KAIA,SAAAK,GAAA7E,EAAAzX,EAAA4W,EAAAqF,GACA,OAAAxE,GAKA1wB,OAAAmC,KAAAuuB,GAAAuE,MAAA,SAAAO,GACA,IAAAC,EAAA/E,EAAA8E,GACA,OAuBA,SAAAA,EAAAvc,EAAAwc,EAAA5F,EAAAqF,GACA,IAAAQ,GAAAF,GACA,UAAApxB,MAAA,qBAAAoxB,EACA,sIAGA,OAAAE,GAAAF,GAAAvc,EAAAwc,EAAA5F,EAAAqF,GA7BArtB,CAAA2tB,EAAAvc,EAAAwc,EAAA5F,EAAAqF,KAgCA,SAAAS,GAAAT,GACA,aAAAA,EAGA,SAAAU,GAAAV,GACA,gBAAAA,EAyBA,SAAAW,GAAAX,EAAAO,GACA,OAAAA,EAAAN,KAAA,SAAA5uB,GACA,OAAA2uB,aAAA7zB,MACA6zB,EAAAtuB,QAAAL,IAAA,EAGA2uB,IAAA3uB,IA0CA,IAAAmvB,GAAA,CAEAI,WAAA,SAAA7c,EAAAwc,EAAA5F,EAAAqF,GACA,QAAA7zB,MAAAkG,QAAA2tB,KAIA,IAAAA,EAAA7yB,SAIA,iBAAA6yB,EAAA,GACAA,EAAAC,KAAA,SAAA5uB,GACA,OAAAkuB,GAAAluB,EAAAkvB,EAAAz1B,OAAAmC,KAAAszB,MAIAP,EAAAC,KAAA,SAAA5uB,GACA,OAAAgvB,GAAAE,EAAAxc,EAAA4W,EAAAtpB,QAIAwvB,UAAA,SAAA9c,EAAAwc,EAAA5F,EAAAqF,GACA,QAAA7zB,MAAAkG,QAAA2tB,KAKA,IAAAA,EAAA7yB,SAIA,iBAAA6yB,EAAA,GACAA,EAAAD,MAAA,SAAA1uB,GACA,OAAAkuB,GAAAluB,EAAAkvB,EAAAz1B,OAAAmC,KAAAszB,MAIAP,EAAAD,MAAA,SAAA1uB,GACA,OAAAgvB,GAAAE,EAAAxc,EAAA4W,EAAAtpB,QAIAoqB,IAAA,SAAA1X,EAAAwc,EAAA5F,EAAAqF,GACA,OAAAU,GAAAV,IAAA,IAAAxD,GAAAwD,EAAAO,IAGA3E,KAAA,SAAA7X,EAAAwc,EAAA5F,EAAAqF,GACA,OAAAU,GAAAV,IAAAxD,GAAAwD,EAAAO,IAAA,GAGA1E,IAAA,SAAA9X,EAAAwc,EAAA5F,EAAAqF,GACA,OAAAU,GAAAV,IAAAxD,GAAAwD,EAAAO,GAAA,GAGAxE,KAAA,SAAAhY,EAAAwc,EAAA5F,EAAAqF,GACA,OAAAU,GAAAV,IAAAxD,GAAAwD,EAAAO,IAAA,GAGAvE,IAAA,SAAAjY,EAAAwc,EAAA5F,EAAAqF,GACA,OAAAU,GAAAV,IAAAxD,GAAAwD,EAAAO,GAAA,GAGAO,QAAA,SAAA/c,EAAAwc,EAAA5F,EAAAqF,GAEA,OAAAO,EACAG,GAAAV,IAGAU,GAAAV,IAGAe,KAAA,SAAAhd,EAAAwc,EAAA5F,EAAAqF,GACA,OAAAS,GAAAT,IA/IA,SAAAA,EAAAO,GACA,IAAAS,EAAAT,EAAA,GACAU,EAAAV,EAAA,GACA,OAAAS,EACA,UAAA9xB,MAAA,sCAGA,GAAAuR,SAAAugB,EAAA,MAAAA,EACA,UAAA9xB,MAAA,6BAGA,GAAAuR,SAAAwgB,EAAA,MAAAA,EACA,UAAA/xB,MAAA,6BAGA,OAAAuR,SAAAuf,EAAA,MAAAA,GAIAA,EAAAgB,IAAAC,EA4HAC,CAAAlB,EAAAO,IAGArE,IAAA,SAAAnY,EAAAwc,EAAA5F,EAAAqF,GACA,OAAAO,EAAAR,MAAA,SAAAoB,GACA,WAAA3E,GAAAwD,EAAAmB,MAGAC,IAAA,SAAArd,EAAAwc,EAAA5F,EAAAqF,GACA,OAAAS,GAAAT,IAAAW,GAAAX,EAAAO,IAGAc,KAAA,SAAAtd,EAAAwc,EAAA5F,EAAAqF,GACA,OAAAS,GAAAT,KAAAW,GAAAX,EAAAO,IAGAe,MAAA,SAAAvd,EAAAwc,EAAA5F,EAAAqF,GACA,OAAAS,GAAAT,IA1HA,SAAAA,EAAAO,GACA,OAAAP,EAAA7yB,SAAAozB,EAyHAgB,CAAAvB,EAAAO,IAGAiB,KAAA,SAAAzd,EAAAwc,EAAA5F,EAAAqF,GACA,OAAA7zB,MAAAkG,QAAA2tB,IApIA,SAAAA,EAAAO,GACA,OAAAA,EAAAR,MAAA,SAAA1uB,GACA,OAAA2uB,EAAAtuB,QAAAL,IAAA,IAkIAowB,CAAAzB,EAAAO,IAGAmB,OAAA,SAAA3d,EAAAwc,EAAA5F,EAAAqF,GACA,OAAAS,GAAAT,IA9HA,SAAAA,EAAAO,GAGA,OAFA,IAAAzuB,OAAAyuB,GAEAjsB,KAAA0rB,GA2HA2B,CAAA3B,EAAAO,IAGAqB,MAAA,SAAA7d,EAAAwc,EAAA5F,EAAAqF,GACA,OA5HA,SAAAA,EAAAO,GAEA,OAAAA,GACA,WACA,cAAAP,EACA,cACA,0BACA,aACA,yBACA,aACA,yBACA,YACA,OAAAA,aAAA7zB,MACA,aACA,MAAgB,oBAAhB,GAAgBM,SAAAsF,KAAAiuB,GAGhB,UAAA9wB,MAAAqxB,EAAA,8FA2GAsB,CAAA7B,EAAAO,KAKA,SAAAuB,GAAA/d,EAAAwX,GAEA,oBAAAA,EAEA,UAAArsB,MAAA,0CAIA,IAIA6yB,EAAA5C,GAAA,CAJA,CACApb,QAGA,CAAiDwX,SALjDA,EAhtBA,SAAAyG,GACA,IAAAnmB,EAAAlB,EAAAqnB,GACAC,GAAA,EACA,SAAApmB,IACAA,EAAAwf,GAAAxf,EAAA,MACAomB,GAAA,GAGA,eAAA7wB,QAAA,SAAA8wB,GACAA,KAAArmB,GAGAA,EAAAqmB,GAAA9wB,QAAA,SAAA+wB,GAEA,IADA,IAAArH,EAAAhwB,OAAAmC,KAAAk1B,GACA91B,EAAA,EAAuBA,EAAAyuB,EAAA3tB,OAAmBd,IAAA,CAC1C,IAAA8uB,EAAAL,EAAAzuB,GACAmvB,EAAA2G,EAAAhH,GACA,iBAAAK,GAAA,OAAAA,IACA2G,EAAAhH,GAAA,CAAkCM,IAAAD,SAOlC,SAAA3f,IAGAA,EAAA,KAAAwf,GAAA,CAAAxf,EAAA,QAKA,IAFA,IAAAif,EAAAhwB,OAAAmC,KAAA4O,GAEAxP,EAAA,EAAiBA,EAAAyuB,EAAA3tB,OAAmBd,IAAA,CACpC,IAAA8uB,EAAAL,EAAAzuB,GACAmvB,EAAA3f,EAAAsf,GAEA,iBAAAK,GAAA,OAAAA,EACAA,EAAA,CAAiBC,IAAAD,GACZ,QAAAA,IAAAyG,IAGLzG,EAAAU,IAAA,CAAAV,EAAAU,MAEArgB,EAAAsf,GAAAK,EAGA,OAAA3f,EAiqBAumB,CAAA7G,IAKwEzwB,OAAAmC,KAAAsuB,IACxE,OAAAwG,GAAA,IAAAA,EAAA50B,OA0BA,SAAAmlB,GAAA7iB,EAAAkM,GACA,GAAAlM,EAAA8rB,UACA9rB,EAAAiQ,QAAA,cAAAjQ,EAAAiQ,OAAA,CACA,IAAA2iB,EAAA,iBAAA5yB,EAAAiQ,OACAjQ,EAAAiQ,OAAA,WACA,OAAA/D,EAAA,IAAAzM,MAAA,gCAAAmzB,EAAA,MAGA1mB,IAGA,SAAA+W,GAAAjjB,GACAA,EAAA6yB,OAAA7yB,EAAAiQ,SACAjQ,EAAAiQ,OAAA,SAGAjQ,EAAA8rB,WAAA9rB,EAAAiQ,SACAjQ,EAAAiQ,OAAA,aAGAjQ,EAAAiQ,QAAA,iBAAAjQ,EAAAiQ,SACA,UAAAjQ,EAAAiQ,OACAjQ,EAAA6yB,KAAAvd,GAAAtV,EAAA6yB,MAEA7yB,EAAAiQ,OAAAqF,GAAAtV,EAAAiQ,SAKA,SAAAiT,GAAA4P,EAAA9yB,GACA,OAAAA,EAAAiQ,QAAA,iBAAAjQ,EAAAiQ,SACAjQ,EAAA+yB,UAAA9d,GAAA6d,EAAArkB,IAGA,SAAAwB,GAAA6iB,EAAA9yB,GACA,IAAAkM,EAAAlM,EAAAkgB,SACA,aAAAlgB,EAAAiQ,OAAA,CACA,IAAAjQ,EAAA6yB,MAAA,iBAAA7yB,EAAA6yB,KAAA,CACA,IAAAxqB,EAAAsL,GAAAL,EACA,iDACA,OAAApH,EAAA7D,GAGA,IAAA2qB,EAAA7d,GAAAnV,EAAA6yB,MACAC,EAAArkB,GAAA7K,IAAA,WAAAovB,EAAA,YAAA3qB,EAAA4qB,GAEA,GAAAH,EAAApS,YACA,OAAAxU,EAAA,MAA+BkF,OAAA,cAG/B,GAAA/I,EACA,OAAA6D,EAAA4H,GAAAzL,IAEA,IAAA6qB,EAAAD,KAAAE,OAAAF,EAAAE,MAAAH,EAAA,KACAC,EAAAE,MAAAH,EAAA,IAAA5vB,IACA,IAAA8vB,EACA,OAAAhnB,EAAAyH,GAAAd,EACAogB,EAAAE,MAAA,qBAAAH,EAAA,GACA,4BAEAhzB,EAAAiQ,OA/DAmG,GAfA,CACA,yBACA,kBACA,yBACA,iCACA,sBACA,OACA,gBAuEA8c,EAvEA,IACA,eACA,mBACA,mBACA,MACA,MACA90B,KAAA,MAEA,IAgEA00B,EAAAhQ,UAAA9iB,UAEG,GAAAA,EAAA8rB,SACH9rB,EAAAiQ,OAAA,SAAAqE,GACA,OAAA+d,GAAA/d,EAAAtU,EAAA8rB,WAEAgH,EAAAhQ,UAAA9iB,OACG,CAEH,IAAA4yB,EAAAzd,GAAAnV,EAAAiQ,QACA6iB,EAAArkB,GAAA7K,IAAA,WAAAgvB,EAAA,YAAAvqB,EAAA4qB,GAEA,GAAAH,EAAApS,YACA,OAAAxU,EAAA,MAA+BkF,OAAA,cAG/B,GAAA/I,EACA,OAAA6D,EAAA4H,GAAAzL,IAEA,IAAA+qB,EAAAH,KAAAI,SAAAJ,EAAAI,QAAAT,EAAA,IACA,IAAAQ,EACA,OAAAlnB,EAAAyH,GAAAd,EACAogB,KAAAI,QAAA,qBAAAT,EAAA,GACA,8BAEA5yB,EAAAiQ,OA5GAmG,GAAA,yBA4GAgd,EA5GiC,IAAuB,IA6GxDN,EAAAhQ,UAAA9iB,MAmBA,SAAAszB,GAAA7xB,GACA,OAAAA,EAAA6B,OAAA,SAAA/F,EAAA+f,GAEA,OADA/f,EAAA+f,IAAA,EACA/f,GACG,IARHkkB,GAAAkJ,OAVA,SAAAlJ,GACAA,EAAAmB,qBAAA,CACAC,YACAI,aACAC,gBACAjT,aAOAwR,GAAA8R,QA1hCA,QAmiCA,IAAAC,GAAAF,GAAA,CACA,MACA,OACA,eACA,WACA,aACA,aACA,aACA,qBACA,aACA,YAEA,kBACA,qBACA,0BACA,4BACA,qBAEA,aAIAG,GAAAH,GAAA,CACA,eAEA,kBACA,qBACA,0BACA,4BACA,uBAGA,SAAAI,GAAA1jB,GACA,aAAAnL,KAAAmL,GACA,OAAA2D,GAAAF,IAEA,IAAA5R,EAAAmO,EAAA/N,QAAA,KACAgf,EAAAjR,EAAA1C,UAAA,EAAAzL,GACAqf,EAAAlR,EAAA1C,UAAAzL,EAAA,GACA,OACA+f,OAAA5Q,SAAAiQ,EAAA,IACAnS,GAAAoS,GAsBA,SAAAyS,GAAArf,EAAAsf,EAAAC,GAOA,IAAAC,EACA/P,EACAgQ,EARAF,IACAA,EAAA,CACA9Y,oBAAA,IAOA,IAAA/a,EAAA,CAAcoR,OAAA,aAKd,GAJAkD,EAAAqP,WACA3jB,EAAAic,SAAA,GAGA2X,EAKA,GAJAtf,EAAAwC,MACAxC,EAAAwC,IAAAsE,MAEA2I,EAAAjJ,GAAAxG,EAAAuf,EAAA9Y,oBACAzG,EAAAqC,KAAA,CAEA,IADAod,EAAAL,GAAApf,EAAAqC,OACA9W,MACA,OAAAk0B,EAEAzf,EAAA2G,UAAA,EACAe,IAAA+X,EAAAnS,OACA9F,IAAA,CAAAiY,EAAAjlB,GAAA,CAA2BsC,OAAA,WAAkB,EAAA2S,EAAA/jB,EAAA,QAE7C8zB,EAAAC,EAAAnS,OAAA,OAEAtN,EAAA2G,UAAA,EACAe,IAAA,EACAF,IAAA,CAAAiI,EAAA/jB,EAAA,MAEA8zB,EAAA,OAQA,GALAxf,EAAAgN,aACAhN,EAAA2G,UAzDA,SAAA+Y,EAAAh0B,GAMA,IALA,IAAAgc,EAAAgY,EAAAta,MAAAsa,EAAAlY,IAAApe,OAAA,EAEAu2B,EAAAD,EAAAlY,IACAA,EAAA,CAAAmY,EAAA,GAAAj0B,EAAA,IAEApD,EAAA,EAAA0B,EAAA21B,EAAAv2B,OAA2Cd,EAAA0B,EAAS1B,IACpDkf,EAAA,CAAAmY,EAAAr3B,GAAA,CAA4BwU,OAAA,WAAkB,CAAA0K,IAG9C,QACAE,MACAF,QA6CAoY,CAAA5f,EAAAgN,WAAAthB,GACA8zB,EAAAxf,EAAAgN,WAAA5H,MACAqK,EAAAzP,EAAAgN,WAAAxF,IAAA,KAEAxH,EAAA2G,UAAA,CAEA,IADA8Y,EAAAL,GAAApf,EAAAqC,OACA9W,MACA,OAAAk0B,EAEAD,EAAAC,EAAAnS,OACAmC,EAAAgQ,EAAAjlB,GACAwF,EAAA2G,UAAA,EACAe,IAAA8X,EACAhY,IAAA,CAAAiI,EAAA/jB,EAAA,MAKAgV,GAAAV,EAAAwC,KAEAxC,EAAAqC,KAAAmd,EAAA,IAAA/P,EAEA,IAAA3X,EAAA,CAAgBkP,SAAA,GAAavH,KAAA,IAC7B,QAAA9Q,KAAAqR,EAEA,GAAAjZ,OAAAO,UAAAmH,eAAAT,KAAAgS,EAAArR,GAAA,CACA,IAAAkxB,EAAA,MAAAlxB,EAAA,GACA,GAAAkxB,IAAAX,GAAAvwB,GAAA,CACA,IAAApD,EAAA8T,GAAAN,EAAApQ,GAEA,MADApD,EAAA8S,QAAAU,EAAAV,QAAA,KAAA1P,EACApD,EACOs0B,IAAAV,GAAAxwB,GACPmJ,EAAAkP,SAAArY,EAAAmH,MAAA,IAAAkK,EAAArR,GAEAmJ,EAAA2H,KAAA9Q,GAAAqR,EAAArR,GAIA,OAAAmJ,EAaA,SAAAgoB,GAAAzf,EAAA0f,EAAAnoB,GACA,IAAAooB,EAXA,SAAAvgB,GACA,IACA,OAAAkD,GAAAlD,GACG,MAAA1P,GAGH,OAAYxE,MAFZ8T,GAAAR,EACA,6CAMAohB,CAAA5f,EAAAZ,MACA,GAAAugB,EAAAz0B,MACA,OAAAqM,EAAAooB,EAAAz0B,OAGA8U,EAAAjX,OAAA42B,EAAA52B,OAEAiX,EAAAZ,KADA,SAAAsgB,EACApc,GAAAqc,EAAA3f,EAAA8P,cACG,WAAA4P,EACHld,GAAAmd,GAEAA,EAEAta,GAAAsa,EAAA,SAAAloB,GACAuI,EAAA6f,OAAA,OAAApoB,EACAF,MAyBA,SAAAuoB,GAAA9f,EAAA0f,EAAAnoB,GACA,GAAAyI,EAAAE,KACA,OAAA3I,IAEA,iBAAAyI,EAAAZ,KACAqgB,GAAAzf,EAAA0f,EAAAnoB,GA1BA,SAAAyI,EAAA0f,EAAAnoB,GACA8N,GAAArF,EAAAZ,KAAA,SAAA2gB,GACA/f,EAAA6f,OAAA,OAAAE,EAEA/f,EAAAjX,OAAAiX,EAAAZ,KAAArJ,MAAAiK,EAAAZ,KAAArW,QAAA,EACA,WAAA22B,EACApb,GAAAtE,EAAAZ,KAAA,SAAAmE,GACAvD,EAAAZ,KAAAmE,EACAhM,MAEK,WAAAmoB,EACLlb,GAAAxE,EAAAZ,KAAA,SAAAqE,GACAzD,EAAAZ,KAAAqE,EACAlM,MAGAA,MAYAyoB,CAAAhgB,EAAA0f,EAAAnoB,GAkDA,SAAA0oB,GAAAC,EAAAtxB,EAAAuxB,EAAA3lB,EACAvS,EAAA6K,EAAAstB,EAAAnB,GAEA,GAlwFA,SAAAzX,EAAAnM,GAOA,IANA,IAKA0L,EALAC,EAAAQ,EAAA/R,QACA4qB,EAAAhlB,EAAAlM,MAAA,KACAmxB,EAAAjkB,SAAAgkB,EAAA,OACAE,EAAAF,EAAA,GAGAtZ,EAAAC,EAAAtY,OAAA,CACA,GAAAqY,EAAAM,MAAAiZ,GAAAvZ,EAAAI,IAAA,KAAAoZ,EACA,SAGA,IADA,IAAAnZ,EAAAL,EAAAI,IAAA,GACAlf,EAAA,EAAA0B,EAAAyd,EAAAre,OAA0Cd,EAAA0B,EAAS1B,IACnD+e,EAAAzd,KAAA,CAAoB8d,IAAAN,EAAAM,IAAA,EAAAF,IAAAC,EAAAnf,KAGpB,SAkvFAu4B,CAAA5xB,EAAAqY,SAAAkZ,EAAAxZ,SAAAtL,OAAA4jB,EAEA,OADAzkB,EAAAvS,GAAAk4B,EACArtB,IAIA,IAAA2tB,EAAA7xB,EAAA8X,eAAA9X,GACA8xB,EAAA,YAAA9xB,IAAA0Y,QACA8D,GAAAxc,EAAA6xB,GACAnZ,EAAA,YAAA6Y,EAAAxZ,SAAAwZ,EAAAxZ,SAAAW,QACA8D,GAAA+U,EAAAxZ,UACAga,EAAA,MAAAzwB,KAAAiwB,EAAAxZ,SAAAtL,KAEA,GAAAqlB,IAAApZ,GAAA2X,GAAA0B,EAAA,CACA,IAAA1e,EAAAke,EAAA/gB,KACA6C,EAAAD,KAAAye,EACAxe,EAAAE,IAAAge,EAAAxZ,SAAAxM,GACAgmB,EAAAnB,GAAA/c,EAAAgd,GAGA,IAAAnV,EAAAe,GAAAjc,EAAAqY,SAAAkZ,EAAAxZ,SAAAM,SAAA,GAAAiZ,GAOA,GALAjB,IACAyB,GAAApZ,GAAA,aAAAwC,EAAA1B,YACAsY,GAAA,aAAA5W,EAAA1B,WACAsY,IAAApZ,GAAA,eAAAwC,EAAA1B,WAEA,CACA,IAAA1U,EAAAsL,GAAAb,GAEA,OADA3D,EAAAvS,GAAAyL,EACAZ,IAGA,IAAA8tB,EAAAT,EAAAxZ,SAAAtL,IACA8kB,EAAAxZ,SAAAM,SAAA6C,EAAA5C,KACAiZ,EAAAnV,YAAAlB,EAAAkB,aAAA,GAEApc,EAAAiyB,UACAV,EAAAxZ,SAAAka,QAAAjyB,EAAAiyB,SAIA,IAAAC,EAAApa,GAAAyZ,EAAAxZ,UACAoa,EAAA3V,GAAA+U,EAAAxZ,SAAAma,GAIAE,EAAAN,IAAAK,EAAA,EACAL,EAAAK,GAAA,IAWAX,EAAAD,EAAAW,EAAAC,EARAH,IAAAE,EAEAC,EAGA3V,GAAA+U,EAAAxZ,SAAAia,IAIA,EAAAI,EAAA/4B,EAAA6K,GAOA,SAAAmuB,GAAAf,EAAAgB,EAAAvR,EAAAwR,EAAAC,EAAA5mB,EACA4lB,EAAA/0B,EAAAg2B,GAGAnB,KAAA,IA0BA,IAAAjB,EAAA5zB,EAAAkkB,UACA+R,EAAA,IAAAnrB,EAEAorB,EAAA,EACAC,EAAAN,EAAAn4B,OAEA,SAAA04B,MACAF,IAAAC,GAAAH,GACAA,IAIAH,EAAAl0B,QAAA,SAAA00B,EAAAC,GAEA,GAAAD,EAAAvf,KAAAkJ,GAAAqW,EAAAvf,KAAA,CACA,IAAAnL,EAAA0qB,EAAA1S,SAAA,2BACAW,EAAA3Y,GAAA0qB,EAAA,CAA4Bp2B,IAAA81B,GAAQ,SAAA1tB,EAAAuE,GACpCuC,EAAAmnB,GAAAjuB,GAAAuE,EACAwpB,UAJA,CASA,IAAAtnB,EAAAunB,EAAA/a,SAAAxM,GACAmnB,EAAApoB,IAAAiB,IACAqnB,IACAF,EAAAryB,IAAAkL,GAAA5Q,KAAA,CAAAm4B,EAAAC,KAEAL,EAAApyB,IAAAiL,EAAA,EAAAunB,EAAAC,QAMAL,EAAAt0B,QAAA,SAAAgN,EAAAG,GACA,IAAAE,EAAA,EAEA,SAAAunB,MACAvnB,EAAAL,EAAAjR,OACA84B,IAEAJ,IAGA,SAAAI,IACA,IAAA16B,EAAA6S,EAAAK,GACAqnB,EAAAv6B,EAAA,GACAw6B,EAAAx6B,EAAA,GAEA,GAAAg6B,EAAAjoB,IAAAiB,GACA8lB,GAAAC,EAAAiB,EAAAlyB,IAAAkL,GAAAunB,EAAAlnB,EACAmnB,EAAAC,EAAAxB,EAAAnB,OACO,CAEP,IAAAnV,EAAAe,GAAA,GAAA6W,EAAA/a,SAAAM,SAAA,GAAAiZ,GACAwB,EAAA/a,SAAAM,SAAA6C,EAAA5C,KACAwa,EAAA1W,YAAAlB,EAAAkB,aAAA,GAhFA,SAAAmV,EAAAwB,EAAApqB,GAEA,IAAAupB,EAAApa,GAAAyZ,EAAAxZ,UACAW,EAAA8D,GAAA+U,EAAAxZ,SAAAma,GACA,kBAAAz1B,GAAAic,EAEA,OADA9M,EAAAmnB,GAAA3iB,GAAAd,EAAA,WACA3G,IAMA,GAFA0nB,GApBA,SAAAkB,GACA,kBAAAA,EAAAxZ,SAAAM,SAAA,GAAAE,IAAA,GAAA1K,OAmBAqlB,CAAA3B,GAEA,CACA,IAAAzsB,EAAAsL,GAAAb,GAEA,OADA3D,EAAAmnB,GAAAjuB,EACA6D,IAKA6oB,EAAAD,EAAAW,EAAAxZ,KAAA,EAFAA,EAAA,IAGAqa,EAAApqB,GA4DAwqB,CAAAL,EAAAC,EAAAC,IAGAC,MAMA,IAAAG,GAAA,EAKAC,GAAA,iBAGAC,GAAA,cAEAC,GAAA,eAGAC,GAAA,mBAIAC,GAAA,aAEAC,GAAA,cAEAC,GAAA,sBAcA,SAAAC,GAAAC,GACA,IACA,OAAAx4B,KAAAC,UAAAu4B,GACG,MAAA/yB,GAEH,OAAW0F,EAAAuQ,EAAQzb,UAAAu4B,IAInB,SAAAC,GAAAnrB,GACA,gBAAAorB,GACA,IAAA3kB,EAAA,gBACA2kB,EAAAjtB,QAAAitB,EAAAjtB,OAAAxK,QACA8S,EAAA2kB,EAAAjtB,OAAAxK,MAAAsC,MAAAm1B,EAAAjtB,OAAAxK,MAAA8S,SAEAzG,EAAAyH,GAAAH,GAAAb,EAAA2kB,EAAA3sB,QAWA,SAAA4sB,GAAAjc,EAAAD,EAAAY,GACA,OACAlI,KAAAojB,GAAA7b,GACAD,aACAmc,eAAAvb,EAAA,QACApK,IAAAyJ,EAAAzJ,IACA/C,GAAAwM,EAAAxM,IAIA,SAAA2oB,GAAAC,GACA,IAAAA,EACA,YAEA,IAAApc,EApDA,SAAA/c,GAIA,IACA,OAAAK,KAAA+4B,MAAAp5B,GACG,MAAA8F,GAEH,OAAW0F,EAAAuQ,EAAQqd,MAAAp5B,IA4CnBq5B,CAAAF,EAAA3jB,MAIA,OAHAuH,EAAAD,WAAAqc,EAAArc,WACAC,EAAAW,QAAA,MAAAyb,EAAAF,eACAlc,EAAAzJ,IAAA6lB,EAAA7lB,IACAyJ,EAKA,SAAAuc,GAAAvjB,GACA,IAAAA,EACA,OAAAA,EAEA,IAAAzS,EAAAyS,EAAAwjB,YAAAC,YAAA,KAIA,OAHAzjB,EAAAwC,IAAAxC,EAAAwjB,YAAAxqB,UAAA,EAAAzL,EAAA,GACAyS,EAAAqC,KAAArC,EAAAwjB,YAAAxqB,UAAAzL,EAAA,UACAyS,EAAAwjB,YACAxjB,EAMA,SAAA0jB,GAAAC,EAAAttB,EAAAutB,EAAAhsB,GACAgsB,EAIAhsB,EAHA+rB,EAEK,iBAAAA,EACLA,EAEA9f,GAAA8f,EAAAttB,GAJA0M,GAAA,MAAiC1M,UAOjCstB,EAEK,iBAAAA,EACL5f,GAAA4f,EAAA,SAAArf,GACA1M,EAAAiL,GAAAyB,MAGA1M,EAAA+rB,GANA/rB,EAAA,IAWA,SAAAisB,GAAA7jB,EAAAtU,EAAAo4B,EAAA3wB,GACA,IAAAiN,EAAArZ,OAAAmC,KAAA8W,EAAAM,cAAA,IACA,IAAAF,EAAAhX,OACA,OAAA+J,OAEA,IAAAuH,EAAA,EAEA,SAAAE,MACAF,IAAA0F,EAAAhX,QAAA+J,GACAA,IAcAiN,EAAA/S,QAAA,SAAAgT,GACA3U,EAAA0U,aAAA1U,EAAAyU,aAXA,SAAAH,EAAAK,GACA,IAAA0jB,EAAA/jB,EAAAM,aAAAD,GACA6f,EAAA6D,EAAA7D,OACA4D,EAAAE,YAAAxB,IAAAlzB,IAAA4wB,GACA+D,UAAA,SAAAl0B,GACAg0B,EAAAJ,KAAA5zB,EAAAgG,OAAA+B,OAAA6rB,KACA/oB,KAMAspB,CAAAlkB,EAAAK,IAEAL,EAAAM,aAAAD,GAAAE,MAAA,EACA3F,OASA,SAAAupB,GAAAtpB,EAAA+oB,GACA,OAAAhwB,QAAA6e,IAAA5X,EAAA/L,IAAA,SAAA0jB,GACA,GAAAA,EAAAxS,KAAAwS,EAAAxS,IAAAM,aAAA,CACA,IAAA8jB,EAAAr9B,OAAAmC,KAAAspB,EAAAxS,IAAAM,cACA,OAAA1M,QAAA6e,IAAA2R,EAAAt1B,IAAA,SAAAuR,GACA,IAAA0jB,EAAAvR,EAAAxS,IAAAM,aAAAD,GACA,YAAA0jB,EAAA,CAGA,IAAAJ,EAAAI,EAAAJ,KACAttB,EAAA0tB,EAAA5T,aACA,WAAAvc,QAAA,SAAAC,GACA6vB,GAAAC,EAAAttB,EAAAutB,EAAA,SAAAnkB,GACA+S,EAAAxS,IAAAM,aAAAD,GAAAvC,EACA1E,EAAA2qB,EAAA,2BACA,CAAetkB,SAEf5L,gBAQA,SAAAwwB,GAAAxc,EAAAzM,EAAA0oB,GAEA,IAAAQ,EAAA,GACAC,EAAAT,EAAAE,YAAAzB,IACAiC,EAAAV,EAAAE,YAAAxB,IACAiC,EAAAX,EAAAE,YAAAvB,IACA9R,EAAA9I,EAAAze,OAEA,SAAAwR,MACA+V,GAMA,WACA,IAAA2T,EAAAl7B,OACA,OAEAk7B,EAAAj3B,QAAA,SAAA6yB,GACA,IAAAwE,EAAAD,EAAAxmB,MAAA,aAAA0S,MACAgU,YAAAC,MACA1E,EAAA,KAAAA,EAAA,cACAwE,EAAAT,UAAA,SAAAl0B,GACA,IAAA4gB,EAAA5gB,EAAAgG,OAAA+B,OACA6Y,GAEA6T,EAAAhrB,OAAA0mB,MAhBA2E,GAsBAhd,EAAAxa,QAAA,SAAAqO,GACA,IAAAuC,EAAAsmB,EAAAtmB,MAAA,eACAtP,EAAAyM,EAAA,KAAAM,EACAuC,EAAAoZ,OAAA1oB,GAAAs1B,UAAA,SAAAl0B,GACA,IAAAwN,EAAAxN,EAAAgG,OAAA+B,OACA,oBAAAyF,EACA,OAAA3C,IAEA2pB,EAAA/qB,OAAA+D,GAEAknB,EAAAxmB,MAAA,OACA6mB,WAAAH,YAAAI,KAAAxnB,IAEA0mB,UAAA,SAAAe,GACA,IAAAC,EAAAD,EAAAjvB,OAAA+B,OACA,GAAAmtB,EAAA,CACA,IAAA/E,EAAA+E,EAAAz9B,MAAA09B,UAAA11B,MAAA,SACA80B,EAAA16B,KAAAs2B,GACAuE,EAAAjrB,OAAAyrB,EAAAE,YACAF,EAAAG,gBAEAxqB,QAOA,SAAAyqB,GAAAC,EAAAC,EAAAC,GACA,IACA,OACA1B,IAAAwB,EAAAG,YAAAF,EAAAC,IAEG,MAAAzxB,GACH,OACAxI,MAAAwI,IAKA,IAAAyqB,GAAA,IAAAriB,EAEA,SAAAupB,GAAAnG,EAAA5f,EAAAjU,EAAAskB,EAAAsV,EAAA1tB,GAWA,IAVA,IACAksB,EACA6B,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EARA1E,EAAA5hB,EAAAtF,KAUA/R,EAAA,EAAA0B,EAAAu3B,EAAAn4B,OAAwCd,EAAA0B,EAAS1B,IAAA,CACjD,IAAA0X,EAAAuhB,EAAAj5B,GACA0X,EAAAwC,KAAAkJ,GAAA1L,EAAAwC,OAGAxC,EAAAuhB,EAAAj5B,GAAA+2B,GAAArf,EAAAtU,EAAAkkB,UAAA2P,IACAh0B,QAAAy6B,IACAA,EAAAhmB,GAIA,GAAAgmB,EACA,OAAApuB,EAAAouB,GAGA,IAAAE,GAAA,EACAC,EAAA,EACAtrB,EAAA,IAAAzS,MAAAm5B,EAAAn4B,QACAo4B,EAAA,IAAAhrB,EACA4vB,GAAA,EACArG,EAAA/P,EAAAqW,MAAAC,YAAA,gBA6CA,SAAAC,IACAL,GAAA,EACAM,IAQA,SAAAA,IACAP,GAAAC,IAKAD,EAAAQ,UAAAN,EACAJ,EAAAtjB,IAAAwjB,IAqCA,SAAAra,IACAwa,IAIA5H,GAAA3gB,OAAAmS,EAAAqW,MAAAx4B,MACA+J,EAAA,KAAAiD,IAsDA,SAAA4lB,EAAAD,EAAAW,EAAAC,EAAAsF,EACAC,EAAAtF,EAAAW,EAAApqB,GAEA4oB,EAAAxZ,SAAAD,WAAAoa,EACAX,EAAAxZ,SAAAW,QAAAyZ,EAEA,IAAAphB,EAAAwgB,EAAA/gB,KAUA,GATAO,EAAAwC,IAAAge,EAAAxZ,SAAAxM,GACAwF,EAAAqC,KAAAme,EAAAxZ,SAAAtL,IAEAgrB,IACA1mB,EAAAqP,UAAA,GAGArP,EAAAM,cACAvZ,OAAAmC,KAAA8W,EAAAM,cAAAlX,OAEA,OAqEA,SAAAo3B,EAAAW,EAAAC,EACAuF,EAAA3E,EAAApqB,GAGA,IAAAoI,EAAAwgB,EAAA/gB,KAEA/E,EAAA,EACA0F,EAAArZ,OAAAmC,KAAA8W,EAAAM,cAEA,SAAAsmB,IACAlsB,IAAA0F,EAAAhX,QACAy9B,EAAArG,EAAAW,EAAAC,EACAuF,EAAA3E,EAAApqB,GAIA,SAAAkvB,IACApsB,IACAksB,IAGAxmB,EAAA/S,QAAA,SAAAsB,GACA,IAAA0R,EAAAmgB,EAAA/gB,KAAAa,aAAA3R,GACA,GAAA0R,EAAAE,KAOA7F,IACAksB,QARA,CACA,IAAAnnB,EAAAY,EAAAZ,YACAY,EAAAZ,KACAY,EAAA+P,OAAA1T,SAAAykB,EAAA,IACA,IAAAjB,EAAA7f,EAAA6f,QAgDA,SAAAA,EAAAzgB,EAAA7H,GAGAiuB,EAAAlV,MAAAuP,GACA+D,UAAA,SAAAl0B,GACA,IAAA4gB,EAAA5gB,EAAAgG,OAAA+B,OACA,GAAA6Y,EACA,OAAA/Y,IAEA,IAAAmvB,EAAA,CACA7G,SACAyD,KAAAlkB,GAEAunB,EAAAnB,EAAApjB,IAAAskB,GACAC,EAAA/C,UAAArsB,GA7DAqvB,CAAA/G,EAAAzgB,EAAAqnB,MAjGAI,CAAA1G,EAAAW,EAAAC,EACAuF,EAAA3E,EAAApqB,GAGAuuB,GAAA9E,EACAmF,IAEAK,EAAArG,EAAAW,EAAAC,EACAuF,EAAA3E,EAAApqB,GAGA,SAAAivB,EAAArG,EAAAW,EAAAC,EACAuF,EAAA3E,EAAApqB,GAEA,IAAAoI,EAAAwgB,EAAA/gB,KACAuH,EAAAwZ,EAAAxZ,SAMA,SAAAmgB,EAAAp3B,GACA,IAAAq3B,EAAA5G,EAAAnV,aAAA,GAEAsb,GAAA3W,EAAA3C,kBACA+Z,IAAA5uB,OApqHA,SAAAwO,GACA,IAAAa,EAAA,GAQA,OAPAD,GAAAZ,EAAAM,SAAA,SAAAa,EAAAT,EACA4D,EAAA3f,EAAAD,GACA,cAAAA,EAAAoR,QAAAqL,IACAN,EAAAje,KAAA8d,EAAA,IAAA4D,GACA5f,EAAAoR,OAAA,aAGA+K,EA2pHAwf,CAAA7G,EAAAxZ,YAGAogB,KAAAh+B,QACAi7B,GAAA+C,EAAA5G,EAAAxZ,SAAAxM,GAAAspB,GAGA9c,EAAAzJ,IAAAxN,EAAAgG,OAAA+B,OAGA,IAAAwvB,EAAArE,GAAAjc,EAAAma,EACAC,GACAuE,EAAAljB,IAAA6kB,GACArD,UAAAsD,EAeA,SAAAA,IACA1sB,EAAAmnB,GAAA,CACA/nB,IAAA,EACAO,GAAAwM,EAAAxM,GACAkB,IAAAsL,EAAAtL,KAEA8lB,EAAAjyB,IAAAixB,EAAAxZ,SAAAxM,GAAAgmB,EAAAxZ,UAgDA,SAAAwZ,EAAAjjB,EAAA3F,GAEA,IAAA4vB,EAAA,EACAC,EAAA1gC,OAAAmC,KAAAs3B,EAAA/gB,KAAAa,cAAA,IAEA,IAAAmnB,EAAAr+B,OACA,OAAAwO,IAGA,SAAAgD,MACA4sB,IAAAC,EAAAr+B,QACAwO,IAIA,SAAA9E,EAAAuN,GACA,IAAA6f,EAAAM,EAAA/gB,KAAAa,aAAAD,GAAA6f,OACAvgB,EAAAmmB,EAAArjB,IAAA,CACAlF,MACA2nB,UAAAhF,EAAA,KAAA3iB,IAGAoC,EAAAskB,UAAArpB,EACA+E,EAAA+nB,QAAA,SAAA33B,GAIAA,EAAA43B,iBACA53B,EAAA63B,kBACAhtB,KAGA,QAAAtS,EAAA,EAAmBA,EAAAm/B,EAAAr+B,OAAsBd,IACzCwK,EAAA20B,EAAAn/B,IAhFAu/B,CAAArH,EAAAxZ,EAAAzJ,IAAA3F,GA3CAoI,EAAAwjB,YAAAxc,EAAAxM,GAAA,KAAAwM,EAAAtL,WACAsE,EAAAwC,WACAxC,EAAAqC,KA4CA,IAAA2kB,EAAApB,EAAAnjB,IAAAzC,GAEAgnB,EAAA/C,UAAAkD,EACAH,EAAAU,QAzBA,SAAA33B,GAEAA,EAAA43B,iBACA53B,EAAA63B,kBACAhC,EAAA3nB,MAAA,eACAoZ,OAAArX,EAAAwjB,aACAS,UAAA,SAAAl0B,GACA61B,EAAAnjB,IAAAzC,EAAAjQ,EAAAgG,OAAA+B,QACAmsB,UAAAkD,KArtBA,SAAA5F,EAAAxB,EAAAnoB,GAEA,IAAA2pB,EAAAn4B,OACA,OAAAwO,IAGA,IACAkwB,EADAC,EAAA,EA4BA,SAAA5hB,IACA4hB,IACAxG,EAAAn4B,SAAA2+B,IACAD,EACAlwB,EAAAkwB,GAEAlwB,KA/BA2pB,EAAAl0B,QAAA,SAAAmzB,GACA,IAAApgB,EAAAogB,EAAA/gB,MAAA+gB,EAAA/gB,KAAAa,aACAvZ,OAAAmC,KAAAs3B,EAAA/gB,KAAAa,cAAA,GACA0nB,EAAA,EAEA,IAAA5nB,EAAAhX,OACA,OAAA+c,IAGA,SAAA8hB,EAAAl0B,GACA+zB,EAAA/zB,IACAi0B,IACA5nB,EAAAhX,QACA+c,IAIA,QAAAxX,KAAA6xB,EAAA/gB,KAAAa,aACAkgB,EAAA/gB,KAAAa,aAAA7R,eAAAE,IACAwxB,GAAAK,EAAA/gB,KAAAa,aAAA3R,GACAoxB,EAAAkI,KAydAC,CAAA3G,EAAAxB,EAAA,SAAAhsB,GACA,GAAAA,EACA,OAAA6D,EAAA7D,IAKA,WAEA,IAMAo0B,EAAA9C,GAAAC,EANA,CACAhD,GAAAC,GACAC,GACAG,GAAAF,GACAC,IAEA,aACA,GAAAyF,EAAA58B,MACA,OAAAqM,EAAAuwB,EAAA58B,QAEAu4B,EAAAqE,EAAArE,KACAsE,QAAArF,GAAAnrB,GACAksB,EAAAuE,UAAAtF,GAAAnrB,GACAksB,EAAAwE,WAAA1c,EACA+Z,EAAA7B,EAAAE,YAAA1B,IACAsD,EAAA9B,EAAAE,YAAAzB,IACAsD,EAAA/B,EAAAE,YAAAxB,IACAsD,EAAAhC,EAAAE,YAAAvB,KACAsD,EAAAjC,EAAAE,YAAAtB,KAEApzB,IAAAozB,IAAAuB,UAAA,SAAAl0B,GACAk2B,EAAAl2B,EAAAgG,OAAA+B,OACA0uB,KA2FA,SAAA+B,GAGA,IAAAC,EAAA,GAWA,GAVAjH,EAAAl0B,QAAA,SAAAmzB,GACAA,EAAA/gB,MAAA+gB,EAAA/gB,KAAAa,cACAvZ,OAAAmC,KAAAs3B,EAAA/gB,KAAAa,cAAAjT,QAAA,SAAAo7B,GACA,IAAApoB,EAAAmgB,EAAA/gB,KAAAa,aAAAmoB,GACApoB,EAAAE,MACAioB,EAAA5+B,KAAAyW,EAAA6f,aAKAsI,EAAAp/B,OACA,OAAAm/B,IAEA,IACAx0B,EADA2G,EAAA,EAQA8tB,EAAAn7B,QAAA,SAAA6yB,IAzCA,SAAAA,EAAAtoB,GAEAiuB,EAAAv2B,IAAA4wB,GACA+D,UAAA,SAAAl0B,GACA,GAAAA,EAAAgG,OAAA+B,OAOAF,QAPA,CACA,IAAA7D,EAAAsL,GAAAD,GACA,uCACA8gB,GACAnsB,EAAA+I,OAAA,IACAlF,EAAA7D,KAiCA20B,CAAAxI,EAAA,SAAAyI,GACAA,IAAA50B,IACAA,EAAA40B,KAPAjuB,IAAA8tB,EAAAp/B,QACAm/B,EAAAx0B,OA9GA60B,CAAA,SAAA70B,GACA,GAAAA,EAEA,OADAqyB,GAAA,EACAxuB,EAAA7D,IA0BA,WAEA,IAAAwtB,EAAAn4B,OACA,OAGA,IAAAy/B,EAAA,EAEA,SAAAjuB,MACAiuB,IAAAtH,EAAAn4B,QAvBAk4B,GAAA/B,EAAAuJ,WAAAvH,EAAAvR,EAAAwR,EACAsC,EAAAjpB,EAAA4lB,EAAA/0B,EAAA66B,GA2BA,SAAAwC,EAAA/D,GACA,IAAAhe,EAAAmc,GAAA6B,EAAAjvB,OAAA+B,QAEAkP,GACAwa,EAAAjyB,IAAAyX,EAAAxM,GAAAwM,GAEApM,IAGA,QAAAtS,EAAA,EAAA0B,EAAAu3B,EAAAn4B,OAA0Cd,EAAA0B,EAAS1B,IAAA,CACnD,IAAAk4B,EAAAe,EAAAj5B,GACA,GAAAk4B,EAAAhe,KAAAkJ,GAAA8U,EAAAhe,KACA5H,QADA,CAIA,IAAA+E,EAAAgmB,EAAAr2B,IAAAkxB,EAAAxZ,SAAAxM,IACAmF,EAAAskB,UAAA8E,IAtDAC,KAnCAC,KAiVA,SAAAC,GAAAlF,EAAAmF,EAAAta,EAAAua,EAAAC,GAWA,IAIAC,EACAC,EACAC,EAEA,SAAAC,EAAA15B,GACAw5B,EAAAx5B,EAAAgG,OAAA+B,OACAwxB,GACAD,EAAAC,EAAAC,EAAAC,GAIA,SAAAE,EAAA35B,GACAu5B,EAAAv5B,EAAAgG,OAAA+B,OACAyxB,GACAF,EAAAC,EAAAC,EAAAC,GA8BA,SAAAG,EAAA55B,GACA,IAAAk1B,EAAAl1B,EAAAgG,OAAA+B,OACA,IAAAmtB,EACA,OAAAoE,IAGAA,EAAA,CAAApE,EAAAt2B,KAAA,CAAAs2B,EAAAz9B,OAAAy9B,IA/DA,IAAAmE,IACAA,EAAA,KAQA,mBAAApF,EAAA4F,QACA,mBAAA5F,EAAA6F,YACAT,EAAA,IAAAva,GAwDA2a,EAAA,CAAoBpE,SApCpB,WACA,IAAAkE,EAAAlgC,OACA,OAAAigC,IAGA,IACAS,EADAC,EAAAT,IAAAlgC,OAAA,GAEA,GAAA+/B,KAAAa,MACA,IACAF,EAAAnF,YAAAC,MAAAmF,EAAAZ,EAAAa,OACA,EAAAb,EAAAc,WACO,MAAAl6B,GACP,iBAAAA,EAAAlC,MAAA,IAAAkC,EAAAm6B,KACA,OAAAb,SAIAS,EAAAnF,YAAAwF,WAAAJ,GAAA,GAEAZ,EAAAW,EACAR,EAAA,KACAC,EAAA,KACAvF,EAAA4F,OAAAT,EAAAC,GAAAnF,UAAAwF,EACAzF,EAAA6F,WAAAV,EAAAC,GAAAnF,UAAAyF,IAcA1F,EAAA4F,OAAAT,EAAAC,GAAAnF,UAAAwF,EACAzF,EAAA6F,WAAAV,EAAAC,GAAAnF,UAAAyF,GACG7a,EACHmV,EAAAc,WAAAqE,EAAA,QAAAlF,UAAA0F,EAEA3F,EAAAc,WAAAqE,GAAAlF,UAAA0F,EA+EA,SAAAS,GAAA1+B,EAAA45B,EAAA1tB,GACA,IAQAuxB,EACAkB,EATAjlB,EAAA,aAAA1Z,KAAAkoB,SACAvO,EAAA,WAAA3Z,KAAAooB,OACAnlB,EAAA,QAAAjD,KAAAiD,IACAzF,EAAA,SAAAwC,KAAAxC,KACAwqB,EAAAhoB,EAAAgoB,MAAA,EACA5E,EAAA,iBAAApjB,EAAAojB,MAAApjB,EAAAojB,OAAA,EACAwb,GAAA,IAAA5+B,EAAA6+B,cAIA,IAAArhC,IAEAmhC,GADAlB,EAzCA,SAAA/jB,EAAAC,EAAAilB,EAAA37B,EAAAkgB,GACA,IACA,GAAAzJ,GAAAC,EACA,OAAAwJ,EACA8V,YAAAC,MAAAvf,EAAAD,GAAAklB,GAAA,GAEA3F,YAAAC,MAAAxf,EAAAC,GAAA,GAAAilB,GAEK,GAAAllB,EACL,OAAAyJ,EACA8V,YAAA6F,WAAAplB,GAEAuf,YAAAwF,WAAA/kB,GAEK,GAAAC,EACL,OAAAwJ,EACA8V,YAAAwF,WAAA9kB,GAAAilB,GAEA3F,YAAA6F,WAAAnlB,GAAAilB,GAEK,GAAA37B,EACL,OAAAg2B,YAAAI,KAAAp2B,GAEG,MAAAoB,GACH,OAAYxE,MAAAwE,GAEZ,YAeA06B,CAAArlB,EAAAC,EAAAilB,EAAA37B,EAAAjD,EAAAmjB,cACAsa,EAAA59B,SAEA,cAAA8+B,EAAAx8B,MAAA,IAAAw8B,EAAAH,MAGA,OAAAtyB,EAAAyH,GAAAH,GACAmrB,EAAAx8B,KAAAw8B,EAAAhsB,UAIA,IAAAknB,EAAA,CAAAjD,GAAAC,GAAAG,IAEAh3B,EAAA0U,aACAmlB,EAAA37B,KAAA44B,IAEA,IAAA2F,EAAA9C,GAAAC,EAAAC,EAAA,YACA,GAAA4C,EAAA58B,MACA,OAAAqM,EAAAuwB,EAAA58B,OAEA,IAAAu4B,EAAAqE,EAAArE,IACAA,EAAAwE,WAgIA,WACA58B,EAAA0U,YACA+jB,GAAAtpB,EAAAnP,EAAA4Y,QAAA9P,KAAAk2B,GAEAA,KAnIA5G,EAAAsE,QAAArF,GAAAnrB,GACA,IAKA6uB,EACAkE,EANAhF,EAAA7B,EAAAE,YAAA1B,IACAiC,EAAAT,EAAAE,YAAAzB,IACAwD,EAAAjC,EAAAE,YAAAtB,IACAkI,EAAArG,EAAAtmB,MAAA,eACApD,EAAA,GAiDA,SAAAgwB,EAAA1J,EAAAna,GACA,IAAAwL,EAAA,CACAhY,GAAAwM,EAAAxM,GACA7L,IAAAqY,EAAAxM,GACAhT,MAAA,CACAkU,IAAAylB,IAGAna,EAAAW,QAEAze,IACA2R,EAAAjR,KAAA4oB,GAEAA,EAAAhrB,MAAAmgB,SAAA,EACA6K,EAAAxS,IAAA,MAEK0T,KAAA,IACL7Y,EAAAjR,KAAA4oB,GACA9mB,EAAAyU,cAhCA,SAAA6G,EAAAwL,EAAA2O,GACA,IAAAxyB,EAAAqY,EAAAxM,GAAA,KAAA2mB,EACAyJ,EAAAt7B,IAAAX,GAAAs1B,UAAA,SAAAl0B,GAEA,GADAyiB,EAAAxS,IAAAujB,GAAAxzB,EAAAgG,OAAA+B,SAAA,GACApM,EAAA+c,UAAA,CACA,IAAAA,EAAAF,GAAAvB,GACAyB,EAAArf,SACAopB,EAAAxS,IAAAyM,WAAAhE,GAGAob,GAAArR,EAAAxS,IAAAtU,EAAAo4B,IAuBAgH,CAAA9jB,EAAAwL,EAAA2O,IAKA,SAAArlB,EAAAivB,GACA,QAAAziC,EAAA,EAAA0B,EAAA+gC,EAAA3hC,OAA6Cd,EAAA0B,GAC7C6Q,EAAAzR,SAAA0lB,EADsDxmB,IAAA,CAItD,IAAA0iC,EAAAD,EAAAziC,GACA,GAAA0iC,EAAAz/B,OAAArC,EAEA2R,EAAAjR,KAAAohC,OAFA,CAKA,IAAAhkB,EAAAmc,GAAA6H,GAEAH,EADA7jB,EAAAD,WACAC,KAIA,SAAAqiB,EAAA4B,EAAAF,EAAA9F,GACAA,IAGAnpB,EAAAivB,GACAlwB,EAAAzR,OAAA0lB,GACAmW,EAAAG,YAYA,SAAAsF,IACA,IAAAQ,EAAA,CACAC,WAAA1E,EACA59B,OAAA6C,EAAAgoB,KACA2H,KAAAxgB,GAIAnP,EAAAujB,iBAAAxd,IAAAk5B,IACAO,EAAAjc,WAAA0b,GAEA/yB,EAAA,KAAAszB,GAYA,OA/HAnF,EAAAz2B,IAAAozB,IAAAuB,UAAA,SAAAl0B,GACA02B,EAAA12B,EAAAgG,OAAA+B,OAAA2uB,UAIA/6B,EAAAujB,YAQA,SAAA+U,EAAAoH,GAaApH,EAAAc,WAAA,aAAAb,UAZA,SAAAl0B,GACA,IAAAk1B,EAAAl1B,EAAAgG,OAAA+B,OACAuzB,OAAA55B,EACAwzB,KAAAt2B,MACA08B,EAAApG,EAAAt2B,KAEA,OAAAy8B,EAAA,CACAr1B,OAAA,CACA+B,OAAA,CAAAuzB,OAhBAC,CAAA/G,EAAA,SAAAx0B,GACAA,EAAAgG,OAAA+B,QAAA/H,EAAAgG,OAAA+B,OAAA1O,OAAA,IACAuhC,EAAA56B,EAAAgG,OAAA+B,OAAA,MAuHAuyB,GAAA,IAAAvb,OAAA,EAGA5lB,EA7NA,SAAAA,EAAAy8B,EAAA0D,GAEA,IAAAE,EAAA,IAAAnhC,MAAAc,EAAAE,QACAunB,EAAA,EACAznB,EAAAmE,QAAA,SAAAsB,EAAAsP,GACA0nB,EAAAr2B,IAAAX,GAAAs1B,UAAA,SAAAe,GACAA,EAAAjvB,OAAA+B,OACAyxB,EAAAtrB,GAAA+mB,EAAAjvB,OAAA+B,OAEAyxB,EAAAtrB,GAAA,CAA8BtP,MAAApD,MAAA,eAE9BolB,IACAznB,EAAAE,QACAigC,EAAAngC,EAAAqgC,EAAA,OAiNAgC,CAAA7/B,EAAAxC,KAAAy8B,EAAA0D,IAEA,IAAAva,EA1PA,SAAAkV,EAAAmF,EAAAiC,GACA,sBAAApH,EAAA4F,OAAA,CAMA,IAAA3nB,EAAA,GAgBA+hB,EAAAc,WAAAqE,GAAAlF,UAdA,SAAAl0B,GACA,IAAAk1B,EAAAl1B,EAAAgG,OAAA+B,OACAmtB,GACAhjB,EAAArY,KAAAq7B,EAAAz9B,OACAy9B,EAAAG,YAEAgG,EAAA,CACAr1B,OAAA,CACA+B,OAAAmK,WAdA+hB,EAAA4F,OAAAT,GAAAlF,UAAAmH,EAwPAxB,CAAAjE,EAAAwD,EAtCA,SAAAp5B,GACA,IAAAkS,EAAAlS,EAAAgG,OAAA+B,OACApM,EAAAmjB,aACA5M,IAAAqG,WAEAxM,EAAAmG,UAqCAinB,GAAAvD,EAAAwD,EAAAz9B,EAAAmjB,WAAAC,EAAA4E,EAAA2V,GAkDA,IAAAmC,IAAA,EACAxhB,GAAA,GAaA,SAAAyhB,MACAD,IAAAxhB,GAAA5gB,SAGAoiC,IAAA,EACAxhB,GAAAqI,OAAArI,IAgBA,SAAA3M,GAAA3R,EAAAskB,EAAAhT,EAAAsoB,GAGA,IAFA55B,EAAAkL,EAAAlL,IAEA+iB,WAAA,CACA,IAAAjU,EAAAwC,EAAA,IAAA8J,KAGA,OAFA0X,GAAAzhB,YAAAC,EAAAxC,EAAAwV,EAAAtkB,GACA8yB,GAAA3gB,OAAAb,GACA,CACAiP,OAAA,WACAuS,GAAA7gB,eAAAX,EAAAxC,KAKA,IAAAkxB,EAAAhgC,EAAA+yB,SAAA,IAAAloB,EAAA7K,EAAA+yB,SAEA/yB,EAAA8R,MAAA9R,EAAA8R,OAAA,EACA,IAAA2O,EAAAzgB,EAAA8R,MAEAsR,EAAA,UAAApjB,IAAAojB,OAAA,EACA,IAAAA,IACAA,EAAA,GAGA,IAKAgV,EACA8B,EACAD,EACAiF,EARA/vB,EAAA,GACA8wB,EAAA,EACAhwB,EAAA+D,GAAAhU,GACAkgC,EAAA,IAAAp1B,EA0FA,SAAAq1B,EAAA7rB,EAAAzC,EAAAyJ,EAAA7T,GACA,GAAA6T,EAAAzJ,QAEA,OAAApK,IAGA,GAAA6T,EAAAD,aAAA/G,EAAAqC,KAEA,OAAAlP,EAAA6T,EAAAhH,GAIA,IAAA8rB,EAAA9rB,EAAAwC,IAAA,KAAAwE,EAAAD,WACA6jB,EAAAt7B,IAAAw8B,GACA7H,UAAA,SAAAl0B,GACAoD,EAAA6T,EAAAuc,GAAAxzB,EAAAgG,OAAA+B,UAqBA,SAAAywB,IACA78B,EAAAkgB,SAAA,MACA/Q,UACAsX,SAAAhG,IAcA,IAAA4f,EAAA,CAAAzJ,GAAAC,IACA72B,EAAA0U,aACA2rB,EAAAniC,KAAA44B,IAEA,IAAA2F,EAAA9C,GAAAC,EAAAyG,EAAA,YACA,GAAA5D,EAAA58B,MACA,OAAAG,EAAAkgB,SAAAuc,EAAA58B,QAEAu4B,EAAAqE,EAAArE,KACAsE,QAAArF,GAAAr3B,EAAAkgB,UACAkY,EAAAwE,WApBA,YACA58B,EAAA+iB,YAAA/iB,EAAA0U,YAGA+jB,GAAAtpB,GAAArG,KAAA+zB,GAEAA,KAgBA3C,EAAA9B,EAAAE,YAAAzB,IACAoD,EAAA7B,EAAAE,YAAA1B,IACAsI,EAAAhF,EAAA3nB,MAAA,eAKAirB,GAAAtD,EAHAl6B,EAAA8R,QAAA9R,EAAAmjB,WACA8V,YAAAwF,WAAAz+B,EAAA8R,OAAA,QAEA9R,EAAAmjB,WAAAC,EA3JA,SAAAmc,EAAAF,EAAA9F,GACA,GAAAA,GAAAgG,EAAA7hC,OAAA,CAIA,IAAA4iC,EAAA,IAAA5jC,MAAA6iC,EAAA7hC,QACA6iC,EAAA,IAAA7jC,MAAA6iC,EAAA7hC,QA+DAsR,EAAA,EACAqwB,EAAA19B,QAAA,SAAA7F,EAAAc,IAgCA,SAAA0X,EAAAzC,EAAApK,GACA,GAAAu4B,MAAAnyB,IAAAyG,EAAAwC,KACA,OAAArP,IAGA,IAAA6T,EAAA4kB,EAAAt8B,IAAA0Q,EAAAwC,KACA,GAAAwE,EACA,OAAA6kB,EAAA7rB,EAAAzC,EAAAyJ,EAAA7T,GAGAwyB,EAAAr2B,IAAA0Q,EAAAwC,KAAAyhB,UAAA,SAAAl0B,GACAiX,EAAAmc,GAAApzB,EAAAgG,OAAA+B,QACA8zB,EAAAr8B,IAAAyQ,EAAAwC,IAAAwE,GACA6kB,EAAA7rB,EAAAzC,EAAAyJ,EAAA7T,IA1CA+4B,CAFA3I,GAAA/7B,GACAyjC,EAAA3iC,GACA,SAAA0e,EAAAmlB,GACAF,EAAA3jC,GAAA0e,EACAglB,EAAA1jC,GAAA6jC,IACAzxB,IAAAuwB,EAAA7hC,QArCA,WAEA,IADA,IAAAmpB,EAAA,GACAjqB,EAAA,EAAA0B,EAAAgiC,EAAA5iC,OAA+Cd,EAAA0B,GAC/C2hC,IAAA7c,EADwDxmB,IAAA,CAIxD,IAAA6jC,EAAAH,EAAA1jC,GACA,GAAA6jC,EAAA,CAGA,IAAAnlB,EAAAilB,EAAA3jC,GACAiqB,EAAA3oB,KAAAwiC,EAAAplB,EAAAmlB,KAGAv4B,QAAA6e,IAAAF,GAAA/d,KAAA,SAAA6I,GACA,QAAA/U,EAAA,EAAA0B,EAAAqT,EAAAjU,OAA6Cd,EAAA0B,EAAS1B,IACtD+U,EAAA/U,IACAoD,EAAAgS,SAAAL,EAAA/U,MAGO4pB,MAAAxmB,EAAAkgB,UAEP+f,IAAA7c,GACAmW,EAAAG,WAeAiH,OArEA,SAAAD,EAAAplB,EAAAmlB,GACA,IAAApsB,EAAArU,EAAA6gB,cAAA4f,EAAAnlB,EAAAtb,GACAygB,EAAApM,EAAAxC,IAAAyJ,EAAAzJ,IAEA,IAAA+uB,EAAA3wB,EAAAoE,GACA,uBAAAusB,EACA14B,QAAAE,OAAAw4B,GAGAA,GAGAX,IACAjgC,EAAA4mB,aACAzX,EAAAjR,KAAAmW,GAIArU,EAAA0U,aAAA1U,EAAAyU,aACA,IAAAvM,QAAA,SAAAC,GACAgwB,GAAAsI,EAAAzgC,EAAAo4B,EAAA,WACAK,GAAA,CAAApkB,GAAArU,EAAA4Y,QAAA9P,KAAA,WACAX,EAAAkM,SAKAnM,QAAAC,QAAAkM,IAjBAnM,QAAAC,aA4IA,IACA04B,GADAC,GAAA,IAAAh2B,EAEAi2B,GAAA,IAAAj2B,EAEA,SAAAk2B,GAAAhhC,EAAAkM,GACA,IAAAoY,EAAAhlB,MAlNA,SAAA2hC,EAAA/0B,EAAAuV,GACAnD,GAAApgB,KAAA,WACA+iC,EAAA,SAAA54B,EAAAuE,IArBA,SAAAjB,EAAAtD,EAAAuE,EAAA6U,GACA,IACA9V,EAAAtD,EAAAuE,GACG,MAAAvE,GAIHoZ,EAAA/U,KAAA,QAAArE,IAeA64B,CAAAh1B,EAAA7D,EAAAuE,EAAA6U,GACAqe,IAAA,EACMx2B,IAAQ,WACdy2B,WAIAA,KA0MAoB,CAAA,SAAAC,IAKA,SAAA9c,EAAAtkB,EAAAkM,GAEA,IAAAoF,EAAAtR,EAAAmC,KAEAy3B,EAAA,KA4BA,SAAAyH,EAAAjJ,EAAAlsB,GACA,IAAA+tB,EAAA7B,EAAAE,YAAA1B,IACAqD,EAAAqH,YAAA,mCAA8DC,QAAA,IAE9DtH,EAAAb,aAAAb,UAAA,SAAAe,GACA,IAAAC,EAAAD,EAAAjvB,OAAA+B,OACA,GAAAmtB,EAAA,CACA,IAAAje,EAAAie,EAAAz9B,MACAmgB,EAAA8D,GAAAzE,GACAA,EAAAkc,eAAAvb,EAAA,QACAge,EAAAljB,IAAAuE,GACAie,EAAAG,gBAEAxtB,KAYA,SAAAs1B,EAAApJ,EAAA3wB,GACA,IAAAg6B,EAAArJ,EAAAE,YAAArB,IACAgD,EAAA7B,EAAAE,YAAA1B,IACAiC,EAAAT,EAAAE,YAAAzB,IAEA0C,EAAAU,EAAAb,aACAG,EAAAhB,UAAA,SAAAe,GACA,IAAAC,EAAAD,EAAAjvB,OAAA+B,OACA,GAAAmtB,EAAA,CACA,IAAAje,EAAAie,EAAAz9B,MACA4T,EAAA4L,EAAAxM,GACA4yB,EAAA1hB,GAAAtQ,GACAM,EAAAqL,GAAAC,GACA,GAAAomB,EAAA,CACA,IAAAtB,EAAA1wB,EAAA,KAAAM,EAGA0J,EAAAhK,EAAA,KACAiK,EAAAjK,EAAA,MACA6C,EAAAsmB,EAAAtmB,MAAA,eACAovB,EAAA1I,YAAAC,MAAAxf,EAAAC,GAAA,MACAioB,EAAArvB,EAAA6mB,WAAAuI,GACAC,EAAArJ,UAAA,SAAAl0B,GAEA,GADAu9B,EAAAv9B,EAAAgG,OAAA+B,OAKa,CACb,IAAA2H,EAAA6tB,EAAA9lC,MACAiY,EAAA+jB,cAAAsI,GACAqB,EAAA1qB,IAAAhD,GAEA8kB,EAAA/qB,OAAA8zB,EAAAnI,YACAmI,EAAAlI,gBARAO,EAAAnsB,OAAAyrB,EAAAE,YACAF,EAAAG,iBAWAH,EAAAG,gBAEOjyB,GACPA,KAcA,SAAAo6B,EAAAzJ,EAAAlsB,GACA,IAAA2sB,EAAAT,EAAAE,YAAAzB,IACAiC,EAAAV,EAAAE,YAAAxB,IACAiC,EAAAX,EAAAE,YAAAvB,IAKA9iB,EAAA6kB,EAAA7T,QACAhR,EAAAskB,UAAA,SAAAl0B,GACA,IAAA4gB,EAAA5gB,EAAAgG,OAAA+B,OACA,IAAA6Y,EACA,OAAA/Y,IAGA2sB,EAAAO,aAAAb,UAAA,SAAAl0B,GACA,IAAAk1B,EAAAl1B,EAAAgG,OAAA+B,OACA,IAAAmtB,EACA,OAAArtB,IAMA,IAJA,IAAAoI,EAAAilB,EAAAz9B,MACA+V,EAAA0nB,EAAAE,WACAzQ,EAAA3tB,OAAAmC,KAAA8W,EAAAM,cAAA,IACAktB,EAAA,GACAnyB,EAAA,EAAuBA,EAAAqZ,EAAAtrB,OAAiBiS,IAAA,CACxC,IAAAgF,EAAAL,EAAAM,aAAAoU,EAAArZ,IACAmyB,EAAAntB,EAAA6f,SAAA,EAEA,IAAAsI,EAAAzhC,OAAAmC,KAAAskC,GACA,IAAAnyB,EAAA,EAAmBA,EAAAmtB,EAAAp/B,OAAoBiS,IAAA,CACvC,IAAA6kB,EAAAsI,EAAAntB,GACAopB,EAAAhiB,IAAA,CACAlF,MACA2nB,UAAAhF,EAAA,KAAA3iB,IAGA0nB,EAAAG,aAWA,SAAAqI,EAAA3J,GAaA,IAAA8B,EAAA9B,EAAAE,YAAAzB,IACAoD,EAAA7B,EAAAE,YAAA1B,IACA2C,EAAAU,EAAAb,aACAG,EAAAhB,UAAA,SAAAl0B,GACA,IAAAk1B,EAAAl1B,EAAAgG,OAAA+B,OACA,GAAAmtB,EAAA,CAGA,IAQA7f,EACAC,EACA1F,EAGA+tB,EAbA1mB,EAnBA,SAAAoc,GACA,IAAAA,EAAA3jB,KAGA,OADA2jB,EAAAzb,QAAA,MAAAyb,EAAAF,eACAE,EAEA,OAAAD,GAAAC,GAaAuK,CAAA1I,EAAAz9B,OAsCA,GApCAwf,EAAAD,WAAAC,EAAAD,YACAA,GAAAC,GAmCAA,EAAAzJ,IACA,OAAAqwB,IA/BAxoB,EAAA4B,EAAAxM,GAAA,KACA6K,EAAA2B,EAAAxM,GAAA,MACAmF,EAAAimB,EAAA3nB,MAAA,eAAA6mB,WACAH,YAAAC,MAAAxf,EAAAC,IAEAqoB,EAAA,EACA/tB,EAAAskB,UAAA,SAAAl0B,GACA,IAAAk1B,EAAAl1B,EAAAgG,OAAA+B,OACA,IAAAmtB,EAEA,OADAje,EAAAzJ,IAAAmwB,EACAE,IAEA,IAAArwB,EAAA0nB,EAAAE,WACA5nB,EAAAmwB,IACAA,EAAAnwB,GAEA0nB,EAAAG,YAIA,SAAAwI,IACA,IAAAtG,EAAArE,GAAAjc,EACAA,EAAAD,WAAAC,EAAAW,SAEAhI,EAAAgmB,EAAAljB,IAAA6kB,GACA3nB,EAAAskB,UAAA,WACAgB,EAAAG,cAjNApV,EAAAqW,MAAA,KA8NArW,EAAApP,SAAA,EACAoP,EAAA3Z,KAAA,WACA,aAGA2Z,EAAAxN,IAAAjL,EAAA,SAAAK,GACAA,EAAA,KAAAoY,EAAAqW,MAAAwH,cAGA7d,EAAA4E,UAAA,SAAAjV,EAAAmuB,EAAAl2B,GACA8tB,GAAAh6B,EAAAiU,EAAAmuB,EAAA9d,EAAAsV,EAAA1tB,IAKAoY,EAAA8C,KAAA,SAAAtY,EAAA9O,EAAAkM,GACA,IAAAoI,EACAgH,EACAjT,EACA+vB,EAAAp4B,EAAAC,IACA,IAAAm4B,EAAA,CACA,IAAAqE,EAAA9C,GAAAC,EACA,CAAAhD,GAAAC,GAAAC,IAAA,YACA,GAAA2F,EAAA58B,MACA,OAAAqM,EAAAuwB,EAAA58B,OAEAu4B,EAAAqE,EAAArE,IAGA,SAAAyE,IACA3wB,EAAA7D,EAAA,CAAqBiM,MAAAgH,WAAArb,IAAAm4B,IAGrBA,EAAAE,YAAA1B,IAAAhzB,IAAAkL,GAAAypB,UAAA,SAAAl0B,GAOA,KANAiX,EAAAmc,GAAApzB,EAAAgG,OAAA+B,SAQA,OADA/D,EAAAsL,GAAAd,EAAA,WACAgqB,IAGA,IAAA7sB,EACA,GAAAhQ,EAAAgQ,IAQAA,EAAAhQ,EAAAknB,OAt3IA,SAAAlX,EAAAsL,GAGA,IAFA,IACAI,EADAC,EAAAL,EAAAM,SAAAxR,QAEAsR,EAAAC,EAAAtY,OAAA,CACA,IAAA2Y,EAAAN,EAAAM,IACAH,EAAAH,EAAAI,IACAhN,EAAA+M,EAAA,GACA7b,EAAA6b,EAAA,GACAE,EAAAF,EAAA,GACAY,EAAA,IAAAV,EAAAre,OAEAyf,EAAAzB,EAAAyB,QAAAzB,EAAAyB,QAAA/S,QAAA,GAGA,GAFA+S,EAAAjf,KAAA,CAAkB4Q,KAAAkN,MAAAhc,SAElByc,EACA,QAAA7f,EAAA,EAAA0B,EAAA6e,EAAAzf,OAA2Cd,EAAA0B,EAAS1B,IAAA,CACpD,IAAAylC,EAAAllB,EAAAvgB,GAGA,GAFAylC,EAAArmB,IAAA,IAAAqmB,EAAAvzB,KAEAkB,EAEA,OAAAgM,EAAA,IAAAlN,EAKA,QAAAa,EAAA,EAAA7M,EAAAiZ,EAAAre,OAAwCiS,EAAA7M,EAAO6M,IAC/CgM,EAAAzd,KAAA,CAAoB8d,MAAA,EAAAF,IAAAC,EAAApM,GAAAwN,YAKpB,UAAA1d,MAAA,4CAAA6b,EAAAxM,GAAA,SAAAkB,GAs1IAkX,CAAAlnB,EAAAgQ,IAAAsL,GAAAtb,EAAAgQ,QARA,CACAA,EAAAsL,EAAAD,WACA,IAAAY,EAAA8D,GAAAzE,GACA,GAAAW,EAEA,OADA5T,EAAAsL,GAAAd,EAAA,WACAgqB,IAMA,IAAAvE,EAAAF,EAAAE,YAAAzB,IACA5zB,EAAAqY,EAAAxM,GAAA,KAAAkB,EAEAsoB,EAAA/lB,MAAA,eAAA3O,IAAAX,GAAAs1B,UAAA,SAAAl0B,GAKA,IAJAiQ,EAAAjQ,EAAAgG,OAAA+B,UAEAkI,EAAAujB,GAAAvjB,KAEAA,EAEA,OADAjM,EAAAsL,GAAAd,EAAA,WACAgqB,IAEAA,OAKAvY,EAAAuD,eAAA,SAAAnY,EAAA4yB,EAAAC,EAAAviC,EAAAkM,GACA,IAAAksB,EACA,GAAAp4B,EAAAC,IACAm4B,EAAAp4B,EAAAC,QACK,CACL,IAAAw8B,EAAA9C,GAAAC,EACA,CAAAhD,GAAAC,GAAAC,IAAA,YACA,GAAA2F,EAAA58B,MACA,OAAAqM,EAAAuwB,EAAA58B,OAEAu4B,EAAAqE,EAAArE,IAEA,IAAA5D,EAAA+N,EAAA/N,OACA7pB,EAAA43B,EAAA9d,aAEA2T,EAAAE,YAAAxB,IAAAlzB,IAAA4wB,GAAA+D,UAAA,SAAAl0B,GACA,IAAA4zB,EAAA5zB,EAAAgG,OAAA+B,OAAA6rB,KACAD,GAAAC,EAAAttB,EAAA3K,EAAA4Y,OAAA,SAAA4pB,GACAt2B,EAAA,KAAAs2B,OAKAle,EAAAoE,MAAA,SAAAxc,GACA,IAAA+yB,EACAlE,EAEA0B,EAAA9C,GAAAC,EAAA,CAAA5C,GAAAH,IAAA,YACA,GAAA4F,EAAA58B,MACA,OAAAqM,EAAAuwB,EAAA58B,OAEA,IAAAu4B,EAAAqE,EAAArE,IACAA,EAAAE,YAAAtB,IAAApzB,IAAAozB,IAAAuB,UAAA,SAAAl0B,GACA02B,EAAA12B,EAAAgG,OAAA+B,OAAA2uB,UAEA3C,EAAAE,YAAAzB,IAAAuC,WAAA,aAAAb,UAAA,SAAAl0B,GACA,IAAAk1B,EAAAl1B,EAAAgG,OAAA+B,OACA6yB,EAAA1F,IAAAt2B,IAAA,GAGAm1B,EAAAwE,WAAA,WACA1wB,EAAA,MACAu2B,UAAA1H,EACAxX,WAAA0b,EAEAyD,sBAAApe,EAAAqW,MAAAC,YAAA,sBAKAtW,EAAAiE,SAAA,SAAAvoB,EAAAkM,GACAwyB,GAAA1+B,EAAA45B,EAAA1tB,IAGAoY,EAAAhB,SAAA,SAAAtjB,GACA,OAAA2R,GAAA3R,EAAAskB,EAAAhT,EAAAsoB,IAGAtV,EAAAmE,OAAA,SAAAvc,GAGA0tB,EAAApR,QACAsY,GAAAhzB,OAAAwD,GACApF,KAGAoY,EAAAe,iBAAA,SAAA3V,EAAAxD,GACA,IAAAuwB,EAAA9C,GAAAC,EAAA,CAAAhD,IAAA,YACA,GAAA6F,EAAA58B,MACA,OAAAqM,EAAAuwB,EAAA58B,OAEA,IAAAu4B,EAAAqE,EAAArE,IACAnkB,EAAAmkB,EAAAE,YAAA1B,IAAAhzB,IAAA8L,GACAuE,EAAAskB,UAAA,SAAAe,GACA,IAAAhlB,EAAAmjB,GAAA6B,EAAAjvB,OAAA+B,QACAkI,EAGApI,EAAA,KAAAoI,EAAAsH,UAFA1P,EAAAyH,GAAAd,MAUAyR,EAAA6B,cAAA,SAAAzW,EAAAyM,EAAAjQ,GACA,IAAA2tB,EAAA,CACAjD,GACAC,GACAC,GACAC,IAEA0F,EAAA9C,GAAAC,EAAAC,EAAA,aACA,GAAA4C,EAAA58B,MACA,OAAAqM,EAAAuwB,EAAA58B,OAEA,IAAAu4B,EAAAqE,EAAArE,IAEA6B,EAAA7B,EAAAE,YAAA1B,IAEAqD,EAAAr2B,IAAA8L,GAAA6oB,UAAA,SAAAe,GACA,IAAAhe,EAAAmc,GAAA6B,EAAAjvB,OAAA+B,QACA8P,GAAAZ,EAAAM,SAAA,SAAAa,EAAAT,EACA4D,EAAA3f,EAAAD,GACA,IAAAgQ,EAAAgM,EAAA,IAAA4D,GACA,IAAAzD,EAAAla,QAAA+N,KACAhQ,EAAAoR,OAAA,aAGAunB,GAAAxc,EAAAzM,EAAA0oB,GACA,IAAA3C,EAAAna,EAAAD,WACAY,EAAAX,EAAAW,QACAmc,EAAAE,YAAA1B,IAAA7f,IACAwgB,GAAAjc,EAAAma,EAAAxZ,KAEAmc,EAAAsE,QAAArF,GAAAnrB,GACAksB,EAAAwE,WAAA,WACA1wB,MAKAoY,EAAA0C,UAAA,SAAAlY,EAAA5C,GACA,IAAAuwB,EAAA9C,GAAAC,EAAA,CAAA3C,IAAA,YACA,GAAAwF,EAAA58B,MACA,OAAAqM,EAAAuwB,EAAA58B,OAEA,IAAAk2B,EAAA0G,EAAArE,IACAnkB,EAAA8hB,EAAAuC,YAAArB,IAAArzB,IAAAkL,GAEAmF,EAAA+nB,QAAA3E,GAAAnrB,GACA+H,EAAAskB,UAAA,SAAAl0B,GACA,IAAAiQ,EAAAjQ,EAAAgG,OAAA+B,OACAkI,UAGAA,EAAA,YACApI,EAAA,KAAAoI,IAHApI,EAAAyH,GAAAd,MAQAyR,EAAAZ,UAAA,SAAApP,EAAAtU,EAAAkM,GACA,mBAAAlM,IACAkM,EAAAlM,EACAA,EAAA,WAEAsU,EAAAgN,WACA,IAAAqhB,EAAAruB,EAAAqC,KACA7H,EAAAwF,EAAAwC,IAIAxC,EAAAqC,KAHAgsB,EAGA,MAAA3xB,SAAA2xB,EAAA7+B,MAAA,eAFA,MAKA,IACA3C,EADA40B,EAAA/1B,EAAAC,IAEA,IAAA81B,EAAA,CACA,IAAA0G,EAAA9C,GAAAC,EAAA,CAAA3C,IAAA,aACA,GAAAwF,EAAA58B,MACA,OAAAqM,EAAAuwB,EAAA58B,QAEAk2B,EAAA0G,EAAArE,KACA4D,QAAA3E,GAAAnrB,GACA6pB,EAAA6G,WAAA,WACAz7B,GACA+K,EAAA,KAAA/K,IAKA,IACA8S,EADA2uB,EAAA7M,EAAAuC,YAAArB,IAEA0L,GACA1uB,EAAA2uB,EAAAh/B,IAAAkL,IACAypB,UAAA,SAAAl0B,GACA,IAAAw+B,EAAAx+B,EAAAgG,OAAA+B,OACA,GAAAy2B,KAAAlsB,OAAAgsB,EAES,CACT,IAAA1uB,EAAA2uB,EAAA7rB,IAAAzC,GACAL,EAAAskB,UAAA,WACAp3B,EAAA,CAAmBoN,IAAA,EAAAO,GAAAwF,EAAAwC,IAAA9G,IAAAsE,EAAAqC,MACnB3W,EAAAC,KACAiM,EAAA,KAAA/K,SANA+K,EAAAyH,GAAAb,OAYAmB,EAAA2uB,EAAAx7B,IAAAkN,IACA0nB,QAAA,SAAA33B,GAEA6H,EAAAyH,GAAAb,IACAzO,EAAA43B,iBACA53B,EAAA63B,mBAEAjoB,EAAAskB,UAAA,WACAp3B,EAAA,CAAeoN,IAAA,EAAAO,GAAAwF,EAAAwC,IAAA9G,IAAAsE,EAAAqC,MACf3W,EAAAC,KACAiM,EAAA,KAAA/K,MAMAmjB,EAAAV,aAAA,SAAAtP,EAAAtU,EAAAkM,GACA,mBAAAlM,IACAkM,EAAAlM,EACAA,EAAA,IAEA,IAaAmB,EAbA40B,EAAA/1B,EAAAC,IACA,IAAA81B,EAAA,CACA,IAAA0G,EAAA9C,GAAAC,EAAA,CAAA3C,IAAA,aACA,GAAAwF,EAAA58B,MACA,OAAAqM,EAAAuwB,EAAA58B,QAEAk2B,EAAA0G,EAAArE,KACAwE,WAAA,WACAz7B,GACA+K,EAAA,KAAA/K,IAKA,IAAA2N,EAAAwF,EAAAwC,IACA8rB,EAAA7M,EAAAuC,YAAArB,IACAhjB,EAAA2uB,EAAAh/B,IAAAkL,GAEAmF,EAAA+nB,QAAA3E,GAAAnrB,GACA+H,EAAAskB,UAAA,SAAAl0B,GACA,IAAAw+B,EAAAx+B,EAAAgG,OAAA+B,OACAy2B,KAAAlsB,OAAArC,EAAAqC,MAGAisB,EAAA90B,OAAAgB,GACA3N,EAAA,CAAeoN,IAAA,EAAAO,KAAAkB,IAAA,OACfhQ,EAAAC,KACAiM,EAAA,KAAA/K,IALA+K,EAAAyH,GAAAd,MAWAyR,EAAAmF,SAAA,SAAAzpB,EAAAkM,GACA4mB,GAAAzS,mBAAA/O,GAGA,IAAAwxB,EAAA/B,GAAAn9B,IAAA0N,GACAwxB,KAAA12B,SACA02B,EAAA12B,OAAAoc,QACAsY,GAAAhzB,OAAAwD,IAEA,IAAA2C,EAAA8uB,UAAAC,eAAA1xB,GAEA2C,EAAAskB,UAAA,WAEAwI,GAAAjzB,OAAAwD,GACAd,KAAAc,KAAAjB,qBACAA,aAAAiB,GAEApF,EAAA,MAAsBqC,IAAA,KAGtB0F,EAAA+nB,QAAA3E,GAAAnrB,IAGA,IAAA+2B,EAAAnC,GAAAl9B,IAAA0N,GAEA,GAAA2xB,EAGA,OAFArJ,EAAAqJ,EAAArJ,IACAtV,EAAAqW,MAAAsI,EAAA/5B,OACWI,IAAQ,WACnB4C,EAAA,KAAAoY,KAIA,IAAArQ,EAAA8uB,UAAAG,KAAA5xB,EAAAqlB,IACAoK,GAAAl9B,IAAAyN,EAAA2C,GAEAA,EAAAkvB,gBAAA,SAAA9+B,GACA,IAAAoK,EAAApK,EAAAgG,OAAA+B,OACA,GAAA/H,EAAA++B,WAAA,EACA,OAlkBA,SAAA30B,GACA,IAAAwrB,EAAAxrB,EAAA40B,kBAAAzM,GAAA,CAAoD0M,QAAA,OACpD70B,EAAA40B,kBAAAxM,GAAA,CAAwC0M,eAAA,IACxCjC,YAAA,6BAAkDC,QAAA,IAClD9yB,EAAA40B,kBAAAvM,GAAA,CAAwCwM,QAAA,WACxC70B,EAAA40B,kBAAArM,GAAA,CAAsCsM,QAAA,KAAAC,eAAA,IACtC90B,EAAA40B,kBAAAnM,IAGA+C,EAAAqH,YAAA,mCAA8DC,QAAA,IAG9D9yB,EAAA40B,kBAAApM,GAAA,CAAuCqM,QAAA,QAGvC,IAAAvK,EAAAtqB,EAAA40B,kBAAAtM,GACA,CAAOwM,eAAA,IACPxK,EAAAuI,YAAA,aACAvI,EAAAuI,YAAA,yBAA0DC,QAAA,IAgjB1DiC,CAAA/0B,GAIA,IAAA2pB,EAAA/zB,EAAAo/B,cAAA1J,YAIA11B,EAAA++B,WAAA,GA/hBA,SAAA30B,GACAA,EAAA40B,kBAAApM,GAAA,CAAuCqM,QAAA,QACvChC,YAAA,6BAAkDC,QAAA,IA8hBlDmC,CAAAj1B,GAEApK,EAAA++B,WAAA,GA7eA,SAAA30B,GACA,IAAAsqB,EAAAtqB,EAAA40B,kBAAAtM,GACA,CAAOwM,eAAA,IACPxK,EAAAuI,YAAA,aACAvI,EAAAuI,YAAA,yBAA0DC,QAAA,IA0e1DoC,CAAAl1B,GAGA,IAAAm1B,EAAA,CACAvC,EACAG,EACAK,EACAE,GAGAnlC,EAAAyH,EAAA++B,YAEA,SAAA7oB,IACA,IAAAspB,EAAAD,EAAAhnC,EAAA,GACAA,IACAinC,GACAA,EAAAzL,EAAA7d,GAIAA,IAGAtG,EAAAskB,UAAA,SAAAl0B,IAEAu1B,EAAAv1B,EAAAgG,OAAA+B,QAEA03B,gBAAA,WACAlK,EAAApR,QACAsY,GAAAhzB,OAAAwD,IAGAsoB,EAAA8C,QAAA,SAAAr4B,GACAuM,EAAA,wCAAAvM,EAAAgG,OAAAxK,OACA+5B,EAAApR,QACAsY,GAAAhzB,OAAAwD,IAUA,IAOAipB,EACAQ,EACAH,EACAuH,EAVA/J,EAAAwB,EAAAG,YAAA,CACA/C,GACAE,GACAN,IACA,aAEAmN,GAAA,EAMA,SAAAC,SACA,IAAApJ,GAAAmJ,IAGAzf,EAAAqW,MAAA,CACAx4B,KAAAmP,EACA6wB,aACAvH,eAGAkG,GAAAj9B,IAAAyN,EAAA,CACAsoB,MACA1wB,OAAAob,EAAAqW,QAEAzuB,EAAA,KAAAoY,IAGA,SAAA2f,IACA,YAAAlJ,QAAA,IAAAR,EAAA,CAGA,IAAA2J,EAAA5yB,EAAA,MACA4yB,KAAA3J,EACA4H,EAAA5H,EAAA2J,GAEA3J,EAAA2J,GAAA/B,EAAA/mB,KAEAmf,EAAAQ,WACA3C,EAAAE,YAAAtB,IAAAjgB,IAAAwjB,IAMAnC,EAAAE,YAAAtB,IAAApzB,IAAAozB,IAAAuB,UAAA,SAAAl0B,GACAk2B,EAAAl2B,EAAAgG,OAAA+B,QAAA,CAAoC0C,GAAAkoB,IACpCiN,KA36BA,SAAA7L,EAAA3wB,GACA2wB,EAAAE,YAAA1B,IAAArkB,MAAA,kBACA0S,MAAAgU,YAAAI,KAAA,MAAAd,UAAA,SAAAl0B,GACAoD,EAAApD,EAAAgG,OAAA+B,SA86BA+3B,CAAA/L,EAAA,SAAAnT,GACA8V,EAAA9V,EACAgf,MAMApD,KAEAA,GAr9BA,SAAAzI,GACA,WAAAlwB,QAAA,SAAAC,GACA,IAAAi8B,EAAA/sB,GAAA,MACApD,EAAAmkB,EAAAE,YAAApB,IAAAngB,IAAAqtB,EAAA,OAEAnwB,EAAAskB,UAAA,WACA,IAAA8L,EAAAC,UAAAC,UAAArhC,MAAA,iBACAshC,EAAAF,UAAAC,UAAArhC,MAAA,UAGAiF,EAAAq8B,IAAAH,GACArzB,SAAAqzB,EAAA,aAGApwB,EAAA+nB,QAAA5D,EAAAsE,QAAA,SAAAr4B,GAGAA,EAAA43B,iBACA53B,EAAA63B,kBACA/zB,GAAA,MAEGqe,MAAA,WACH,WA+7BAie,CAAArM,IAGAyI,GAAA/3B,KAAA,SAAAlH,GACAg5B,EAAAh5B,EACAoiC,MAKA5L,EAAAwE,WAAA,WACAmH,GAAA,EACAC,KAEA5L,EAAAsE,QAAArF,GAAAnrB,IAGA+H,EAAA+nB,QAAA,WACA,IAAA78B,EAAA,8DACAyR,EAAA,QAAAzR,GACA+M,EAAAyH,GAAAH,GAAArU,KA3tBAulC,CAAApgB,EAAAtkB,EAAAohC,IACGl1B,EAAAoY,EAAAzoB,aA8tBHmlC,GAAA3e,MAAA,WAMA,IAGA,0BAAA0gB,WAAA,oBAAA9J,YACG,MAAA50B,GACH,WA4DA,IAAAsgC,GAAA,GACAC,GAAA,GACAC,GAAA,IACAC,GAAA,IAEAC,GAAA,GAEA,SAAAC,GAAAle,GACA,IACAkC,GADAlC,EAAAxS,KAAAwS,EAAAvY,IACAqG,aACAoU,GAGA3tB,OAAAmC,KAAAwrB,GAAArnB,QAAA,SAAAo7B,GACA,IAAApoB,EAAAqU,EAAA+T,GACApoB,EAAAZ,KAAAoE,GAAAxD,EAAAZ,KAAAY,EAAA8P,gBAIA,SAAAwgB,GAAAn2B,GACA,iBAAAjK,KAAAiK,GACA,WAAAo2B,mBAAAp2B,EAAA1E,MAAA,IAEA,UAAAvF,KAAAiK,GACA,UAAAo2B,mBAAAp2B,EAAA1E,MAAA,IAEA86B,mBAAAp2B,GAGA,SAAAq2B,GAAA7wB,GACA,OAAAA,EAAAM,cAAAvZ,OAAAmC,KAAA8W,EAAAM,cAIA1M,QAAA6e,IAAA1rB,OAAAmC,KAAA8W,EAAAM,cAAAxR,IAAA,SAAAH,GACA,IAAAs/B,EAAAjuB,EAAAM,aAAA3R,GACA,GAAAs/B,EAAAxuB,MAAA,iBAAAwuB,EAAAxuB,KACA,WAAA7L,QAAA,SAAAC,GACAgR,GAAAopB,EAAAxuB,KAAA5L,KACOW,KAAA,SAAAsP,GACPmqB,EAAAxuB,KAAAqE,OATAlQ,QAAAC,UAyBA,SAAAi9B,GAAAjjC,EAAAnC,GAEA,GAZA,SAAAA,GACA,IAAAA,EAAA4hB,OACA,SAEA,IAAAyjB,EAAA1vB,GAAA3V,EAAA4hB,QAAAyjB,SACA,eAAAA,GAAA,UAAAA,EAOAC,CAAAtlC,GAAA,CACA,IAAAsR,EAAAtR,EAAAmC,KAAAlF,OAAA+C,EAAA4hB,OAAAlkB,QAGAyE,EADAnC,EAAA4hB,OAAAnjB,QAAA,YACAymC,mBAAA5zB,GAGA,IAAAwE,EAAAH,GAAAxT,IACA2T,EAAAyvB,MAAAzvB,EAAA0vB,YACA1vB,EAAA2vB,KAAA,CAAgBC,SAAA5vB,EAAAyvB,KAAAC,SAAA1vB,EAAA0vB,WAKhB,IAAAnwB,EAAAS,EAAAgI,KAAArf,QAAA,iBAAAqF,MAAA,KAUA,OARAgS,EAAArH,GAAA4G,EAAAhS,OAEA,IAAAyS,EAAArH,GAAAxM,QAAA,OACA6T,EAAArH,GAAAy2B,mBAAApvB,EAAArH,KAGAqH,EAAAgI,KAAAzI,EAAAjX,KAAA,KAEA0X,EAIA,SAAA6vB,GAAA3lC,EAAA8d,GACA,OAAA8nB,GAAA5lC,IAAAyO,GAAA,IAAAqP,GAIA,SAAA8nB,GAAA5lC,EAAA8d,GAGA,IAAA+nB,EAAA7lC,EAAA8d,KAAA,OAIA,OAAA9d,EAAAqlC,SAAA,MAAArlC,EAAA8lC,MACA9lC,EAAA+lC,KAAA,IAAA/lC,EAAA+lC,KAAA,IACA,IAAA/lC,EAAA8d,KAAA+nB,EAAA/nB,EAGA,SAAAkoB,GAAAC,GACA,UAAA5qC,OAAAmC,KAAAyoC,GAAA7iC,IAAA,SAAAyqB,GACA,OAAAA,EAAA,IAAAqX,mBAAAe,EAAApY,MACGzvB,KAAA,KAcH,SAAA8nC,GAAAlmC,EAAAkM,GAGA,IAAAoY,EAAAhlB,KAEAwmC,EAAAV,GAAAplC,EAAAmC,KAAAnC,GACAmmC,EAAAR,GAAAG,EAAA,IAEA9lC,EAAAkL,EAAAlL,GAEA,IAqFAomC,EArFAC,EAAA,SAAArb,EAAAsb,GAKA,IAHAA,KAAA,IACAC,QAAAD,EAAAC,SAAA,IAAArc,GAEAlqB,EAAAylC,MAAAK,EAAAL,KAAA,CACA,IAAAe,EAAAxmC,EAAAylC,MAAAK,EAAAL,KACAlnC,EAAAioC,EAAAd,SAAA,IAAAc,EAAAhB,SACAiB,EAAAtvB,GAAAuvB,SAAAxB,mBAAA3mC,KACA+nC,EAAAC,QAAA1iC,IAAA,yBAAA4iC,GAGA,IAAAF,EAAAvmC,EAAAumC,SAAA,GAWA,OAVAlrC,OAAAmC,KAAA+oC,GAAA5kC,QAAA,SAAAsB,GACAqjC,EAAAC,QAAA3uB,OAAA3U,EAAAsjC,EAAAtjC,MAnCA,SAAAjD,GACA,IAAA2mC,EAAA,oBAAArC,qBAAAC,UACAD,UAAAC,UAAAppB,cAAA,GACAyrB,GAAA,IAAAD,EAAA1kC,QAAA,QACA4kC,GAAA,IAAAF,EAAA1kC,QAAA,WACA6kC,GAAA,IAAAH,EAAA1kC,QAAA,QACA8kC,IAAA,WAAA/mC,IAAA,QAAAA,EAAA6Q,OACA,OAAA+1B,GAAAC,GAAAC,IAAAC,EAgCAC,CAAAV,KACAtb,KAAA,IAAAA,EAAA/oB,QAAA,wBAAAO,KAAAykC,QAGAjnC,EAAAiqB,OAAAD,IACAgB,EAAAsb,IAGA,SAAAY,EAAA/kC,EAAAwJ,GACA,OAAAU,EAAAlK,EAA4BiH,IAAY,SAAA/K,GACxC8oC,IAAAr+B,KAAA,WACA,OAAA6C,EAAAtM,MAAAC,KAAAjB,KACOmoB,MAAA,SAAAniB,GACPhG,EAAAgF,KACA6I,CAAA7H,QAEKhI,KAAAioB,GAGL,SAAA8iB,EAAApc,EAAAsb,EAAAp6B,GAEA,IAAAE,EAAA,GAYA,OAVAk6B,KAAA,IACAC,QAAAD,EAAAC,SAAA,IAAArc,GAEAoc,EAAAC,QAAA3iC,IAAA,iBACA0iC,EAAAC,QAAA1iC,IAAA,mCAEAyiC,EAAAC,QAAA3iC,IAAA,WACA0iC,EAAAC,QAAA1iC,IAAA,6BAGAwiC,EAAArb,EAAAsb,GAAAx9B,KAAA,SAAAu+B,GAGA,OAFAj7B,EAAAmC,GAAA84B,EAAA94B,GACAnC,EAAAgF,OAAAi2B,EAAAj2B,OACAi2B,EAAAjQ,SACKtuB,KAAA,SAAAsuB,GAEL,GADAhrB,EAAA2H,KAAAqjB,GACAhrB,EAAAmC,GAAA,CACAnC,EAAA2H,KAAA3C,OAAAhF,EAAAgF,OACA,IAAA/I,EAAAyL,GAAA1H,EAAA2H,MACA,GAAA7H,EACA,OAAAA,EAAA7D,GAEA,MAAAA,EAcA,GAVA3L,MAAAkG,QAAAwJ,EAAA2H,QACA3H,EAAA2H,KAAA3H,EAAA2H,KAAA3Q,IAAA,SAAAkkC,GACA,OAAAA,EAAAznC,OAAAynC,EAAApiB,QACApR,GAAAwzB,GAEAA,MAKAp7B,EAGA,OAAAE,EAFAF,EAAA,KAAAE,EAAA2H,QASA,SAAAozB,IACA,OAAAnnC,EAAAunC,WACAr/B,QAAAC,UAMAi+B,KAIAA,EAAAgB,EAAAjB,GAAA3f,MAAA,SAAAne,GACA,OAAAA,KAAA+I,QAAA,MAAA/I,EAAA+I,QAEAD,EAAA,uDACAi2B,EAAAjB,EAAA,CAAiCt1B,OAAA,SAEjC3I,QAAAE,OAAAC,KAEKme,MAAA,SAAAne,GAIL,SAAAA,MAAA+I,QAAA,MAAA/I,EAAA+I,SAGAlJ,QAAAE,OAAAC,MAGAme,MAAA,WACA4f,EAAA,OAGAA,GAuTA,SAAAoB,EAAAnjB,GACA,OAAAA,EAAAvgB,MAAA,KAAAV,IAAA8hC,oBAAA9mC,KAAA,KArTEkL,IAAQ,WACV4C,EAAA,KAAAoY,KAGAA,EAAApP,SAAA,EAGAoP,EAAA3Z,KAAA,WACA,cAGA2Z,EAAAxV,GAAAo4B,EAAA,cAAAh7B,GACAm6B,EAAAT,GAAAE,EAAA,KAAAh9B,KAAA,SAAAu+B,GACA,OAAAA,EAAAjQ,SACKtuB,KAAA,SAAAsD,GACL,IAAAq7B,EAAAr7B,KAAAgP,KACAhP,EAAAgP,KAAA0qB,EAAAr3B,GAAAk3B,GAAAG,EAAA,IACA55B,EAAA,KAAAu7B,KACKjhB,MAAA,SAAAne,GACL6D,EAAA7D,OAMAic,EAAA8B,QAAA8gB,EAAA,mBAAAlnC,EAAAkM,GACA,mBAAAlM,IACAkM,EAAAlM,EACAA,EAAA,IAEAA,EAAAkL,EAAAlL,GAEAonC,EAAAzB,GAAAG,EAAA,aAA2Cj1B,OAAA,SAAe/H,KAAA,YAC1D,SAAA4+B,IACApjB,EAAAlV,KAAA,SAAA/G,EAAAuE,GAIAA,MAAA+6B,gBACAz7B,EAAA,MAA4BqC,IAAA,IAE5BgL,WAAAmuB,EAAA1nC,EAAA4nC,UAAA,OAKAF,OAIApjB,EAAA9V,QAAAnC,EAAA,mBAAArM,EAAAkM,GACA,IAAArD,EAAAvJ,KAEA,SAAAuoC,EAAApgC,GACA,IAAAw+B,EAAA,GACAjmC,EAAAmc,OACA8pB,EAAA9pB,MAAA,GAEAnc,EAAA0U,cAEAuxB,EAAAvxB,aAAA,GAEA1U,EAAAknB,SACA+e,EAAA/e,QAAA,GAEAkgB,EAAAzB,GAAAG,EAAA,YAAAE,GAAAC,IAAA,CACAp1B,OAAA,OACAonB,KAAAr5B,KAAAC,UAAA,CAA8B8P,KAAA3O,EAAA2O,SACvB7F,KAAA,SAAAsD,GACPpM,EAAA0U,aAAA1U,EAAA4Y,QACAxM,EAAA2H,KAAA5E,QAAAxN,QAAA,SAAAiL,GACAA,EAAA+B,KAAAhN,QAAAqjC,MAGAv9B,EAAA,KAAA2E,EAAA2H,QACOyS,MAAA/e,GAIP,SAAAqgC,IAEA,IAAApK,EAAAkH,GACAmD,EAAAlrC,KAAAud,KAAApa,EAAA2O,KAAAjR,OAAAggC,GACA1uB,EAAA,EACAG,EAAA,IAAAzS,MAAAqrC,GAEA,SAAAC,EAAAC,GACA,gBAAA5/B,EAAAuE,GAEAuC,EAAA84B,GAAAr7B,EAAAuC,UACAH,IAAA+4B,GACA77B,EAAA,MAA4BiD,QAAA2F,GAAA3F,MAK5B,QAAAvS,EAAA,EAAqBA,EAAAmrC,EAAgBnrC,IAAA,CACrC,IAAAsrC,EAAAx6B,EAAA1N,EAAA,0CACAkoC,EAAAv5B,KAAA3O,EAAA2O,KAAAvE,MAAAxN,EAAA8gC,EACA7gC,KAAA2S,IAAAxP,EAAA2O,KAAAjR,QAAAd,EAAA,GAAA8gC,IACAlvB,EAAA3F,EAAAq/B,EAAAF,EAAAprC,KAKA,IAAAupC,EAAAP,GAAAE,EAAA,IACAqC,EAAApD,GAAAoB,GAGA,kBAAAgC,EAEAN,EAAA,SAAAx/B,EAAAuE,GACAvE,GACA08B,GAAAoB,IAAA,EACAh1B,EACA9I,EAAA+I,OACA,uEAGA02B,MAEA/C,GAAAoB,IAAA,EACAj6B,EAAA,KAAAU,MAGKu7B,EACLN,EAAA37B,GAEA47B,MAOAxjB,EAAAoE,MAAA,SAAAxc,GACAi7B,IAAAr+B,KAAA,WACA,OAAAu9B,EAAAV,GAAAG,EAAA,OACKh9B,KAAA,SAAAu+B,GACL,OAAAA,EAAAjQ,SACKtuB,KAAA,SAAAsG,GACLA,EAAA02B,KAAAH,GAAAG,EAAA,IACA55B,EAAA,KAAAkD,KACKoX,MAAAta,IAGLoY,EAAA2F,MAAA,SAAAnM,EAAAwoB,GACA,OAAAa,IAAAr+B,KAAA,WACA,OAAAu9B,EAAAV,GAAAG,EAAAhoB,GAAAwoB,MAOAhiB,EAAA1gB,IAAAsjC,EAAA,eAAAp4B,EAAA9O,EAAAkM,GAEA,mBAAAlM,IACAkM,EAAAlM,EACAA,EAAA,IAKA,IAAAimC,EAAA,GAoCA,SAAAmC,EAAA9zB,GACA,IAAA0U,EAAA1U,EAAAM,aACAyzB,EAAArf,GAAA3tB,OAAAmC,KAAAwrB,GACA,GAAAA,GAAAqf,EAAA3qC,OA4CA,OAriBA,SAAA4qC,EAAAllB,GACA,WAAAlb,QAAA,SAAAC,EAAAC,GACA,IAIAC,EAJAy3B,EAAA,EACAxU,EAAA,EACA7Q,EAAA,EACAnc,EAAAgqC,EAAA5qC,OAQA,SAAA6qC,MACA9tB,IAAAnc,EAEA+J,EACAD,EAAAC,GAEAF,IAGAqgC,IAIA,SAAA9I,IACAI,IACAyI,IAIA,SAAAE,EAAAC,GACA5I,IACAz3B,KAAAqgC,EACAH,IAGA,SAAAC,IACA,KAAA1I,EAAA1c,GAAAkI,EAAAhtB,GA9BAwhC,IACAwI,EAAAhd,OAAAxiB,KAAA42B,EAAA+I,GAkCAD,MAyfAG,CARAN,EAAAjlC,IAAA,SAAA25B,GACA,kBACA,OA/BA,SAAAA,GACA,IAAApoB,EAAAqU,EAAA+T,GACAjf,EAAAmnB,GAAA3wB,EAAAwC,KAAA,IAAA0wB,EAAAzK,GACA,QAAAzoB,EAAAqC,KACA,OAAA0vB,EAAAV,GAAAG,EAAAhoB,IAAAhV,KAAA,SAAAu+B,GACA,gBAAAhqC,KAAAurC,QAIAvB,EAAA/uB,OAHA+uB,EAAA1uB,WAKS7P,KAAA,SAAAwP,GACT,OAAAtY,EAAA4Y,aAEA,IAAAvb,KAAAurC,UACAtwB,EAAA3N,KAAAgK,EAAA8P,cAEAnM,GAEA,IAAApQ,QAAA,SAAAC,GACAgR,GAAAb,EAAAnQ,OAESW,KAAA,SAAAiL,UACTY,EAAAE,YACAF,EAAAjX,OACAiX,EAAAZ,SAMA80B,CAAA9L,MAMA,IAtFA/8B,EAAAkL,EAAAlL,IAKAmc,OACA8pB,EAAA9pB,MAAA,GAGAnc,EAAAqnB,YACA4e,EAAA5e,WAAA,GAGArnB,EAAAknB,SACA+e,EAAA/e,QAAA,GAGAlnB,EAAA+P,YACA,QAAA/P,EAAA+P,YACA/P,EAAA+P,UAAAnR,KAAAC,UAAAmB,EAAA+P,YAEAk2B,EAAAl2B,UAAA/P,EAAA+P,WAGA/P,EAAAgQ,MACAi2B,EAAAj2B,IAAAhQ,EAAAgQ,KAGAhQ,EAAA+c,YACAkpB,EAAAlpB,UAAA/c,EAAA+c,WAIA/c,EAAAujB,aACA0iB,EAAA1iB,WAAAvjB,EAAAujB,YAGAzU,EAAAm2B,GAAAn2B,GAgEAs4B,EADAzB,GAAAG,EAAAh3B,EAAAk3B,GAAAC,KACAn9B,KAAA,SAAA8D,GACA,OAAA1E,QAAAC,UAAAW,KAAA,WACA,GAAA9I,EAAA0U,YACA,OAfAo0B,EAeAl8B,EAAAmH,KAdArX,MAAAkG,QAAAkmC,GACA5gC,QAAA6e,IAAA+hB,EAAA1lC,IAAA,SAAAkR,GACA,GAAAA,EAAA/F,GACA,OAAA65B,EAAA9zB,EAAA/F,OAIA65B,EAAAU,GARA,IAAAA,IAiBOhgC,KAAA,WACPoD,EAAA,KAAAU,EAAAmH,UAEKyS,MAAA,SAAAniB,GACLA,EAAAqL,MAAAZ,EACA5C,EAAA7H,OAMAigB,EAAAM,OAAAsiB,EAAA,kBAAAriB,EAAAC,EAAA9kB,EAAAyH,GACA,IAAA6M,EACA,iBAAAwQ,GAEAxQ,EAAA,CACAwC,IAAA+N,EACAlO,KAAAmO,GAEA,mBAAA9kB,IACAyH,EAAAzH,EACAA,EAAA,MAIAsU,EAAAuQ,EACA,mBAAAC,GACArd,EAAAqd,EACA9kB,EAAA,KAEAyH,EAAAzH,EACAA,EAAA8kB,IAIA,IAAA9U,EAAAsE,EAAAqC,MAAA3W,EAAAgQ,IAGAo3B,EAFAzB,GAAAG,EAAAb,GAAA3wB,EAAAwC,MAAA,QAAA9G,EAEA,CAAoBa,OAAA,UAAiBpJ,GAAA+e,MAAA/e,KAQrC6c,EAAAwD,cAAAof,EAAA,yBAAAx3B,EAAA2U,EACArkB,EAAAkM,GACA,mBAAAlM,IACAkM,EAAAlM,EACAA,EAAA,IAEA,IAGA+oC,EAHA9C,EAAAjmC,EAAAgQ,IAAA,QAAAhQ,EAAAgQ,IAAA,GACAgb,EAAA2a,GAAAG,EAAAb,GAAAv1B,IAAA,IACA83B,EAAAnjB,GAAA4hB,EAEAI,EAAArb,EAAA,CAAmBna,OAAA,QAAc/H,KAAA,SAAAu+B,GAEjC,GADA0B,EAAA1B,EAAAd,QAAA3iC,IAAA,gBACAyjC,EAAA94B,GAGA,gBAAAlR,KAAAurC,QAIAvB,EAAA/uB,OAHA+uB,EAAA1uB,SAHA,MAAA0uB,IASKv+B,KAAA,SAAAwP,QAEL,IAAAjb,KAAAurC,UACAtwB,EAAA3N,KAAAo+B,GAEA78B,EAAA,KAAAoM,KACKkO,MAAA,SAAAne,GACL6D,EAAA7D,OAKAic,EAAAK,iBAAAuiB,EAAA,4BAAAx3B,EACA2U,EACArU,EACA9D,GAGAk7B,EAFAzB,GAAAG,EAAAb,GAAAv1B,GAAA,IACA83B,EAAAnjB,IAAA,QAAArU,EACA,CAAoBa,OAAA,UAAiB3E,GAAAsa,MAAAta,KAMrCoY,EAAAF,cAAA8iB,EAAA,yBAAAx3B,EAAA2U,EACArU,EAAAsI,EACA3N,EAAAuB,GACA,mBAAAvB,IACAuB,EAAAvB,EACAA,EAAA2N,EACAA,EAAAtI,EACAA,EAAA,MAEA,IAAAlB,EAAAm2B,GAAAv1B,GAAA,IAAA83B,EAAAnjB,GACA2G,EAAA2a,GAAAG,EAAAh3B,GAKA,GAJAkB,IACAgb,GAAA,QAAAhb,GAGA,iBAAAsI,EAAA,CAEA,IAAAM,EACA,IACAA,EAAA3B,GAAAqB,GACO,MAAAjQ,GACP,OAAA6D,EAAAyH,GAAAR,EACA,4CAEAmF,EAAAM,EAAAX,GAAAW,EAAAjO,GAAA,GAIAy8B,EAAApc,EAAA,CACAub,QAAA,IAAArc,GAAA,CAAsB8e,eAAAr+B,IACtBkG,OAAA,MACAonB,KAAA3f,GACKpM,GAAAsa,MAAAta,KAKLoY,EAAA4E,UAAA,SAAAjV,EAAAjU,EAAAkM,GAIA+H,EAAAiQ,UAAAlkB,EAAAkkB,UAEAijB,IAAAr+B,KAAA,WACA,OAAAZ,QAAA6e,IAAA9S,EAAAtF,KAAAvL,IAAA+hC,OACKr8B,KAAA,WAEL,OAAAs+B,EAAAzB,GAAAG,EAAA,eACAj1B,OAAA,OACAonB,KAAAr5B,KAAAC,UAAAoV,IACO/H,KACFsa,MAAAta,IAKLoY,EAAAL,KAAA,SAAA3P,EAAAtU,EAAAkM,GACAi7B,IAAAr+B,KAAA,WACA,OAAAq8B,GAAA7wB,KACKxL,KAAA,WACL,OAAAs+B,EAAAzB,GAAAG,EAAAb,GAAA3wB,EAAAwC,MAAA,CACAjG,OAAA,MACAonB,KAAAr5B,KAAAC,UAAAyV,OAEKxL,KAAA,SAAAsD,GACLF,EAAA,KAAAE,EAAA2H,QACKyS,MAAA,SAAAne,GACLA,EAAAqH,MAAA4E,KAAAwC,IACA5K,EAAA7D,MAOAic,EAAAyD,QAAAmf,EAAA,mBAAAlnC,EAAAkM,GACA,mBAAAlM,IACAkM,EAAAlM,EACAA,EAAA,IAKA,IACAi4B,EADAgO,EAAA,GAEAp1B,EAAA,OALA7Q,EAAAkL,EAAAlL,IAOA+c,YACAkpB,EAAAlpB,WAAA,GAIA/c,EAAAujB,aACA0iB,EAAA1iB,YAAA,GAGAvjB,EAAAmjB,aACA8iB,EAAA9iB,YAAA,GAGAnjB,EAAAyU,eACAwxB,EAAAxxB,cAAA,GAIAzU,EAAA0U,cACAuxB,EAAAvxB,aAAA,GAGA1U,EAAAiD,MACAgjC,EAAAhjC,IAAArE,KAAAC,UAAAmB,EAAAiD,MAGAjD,EAAAioB,YACAjoB,EAAAkoB,SAAAloB,EAAAioB,WAGAjoB,EAAAkoB,WACA+d,EAAA/d,SAAAtpB,KAAAC,UAAAmB,EAAAkoB,WAGAloB,EAAAmoB,UACAnoB,EAAAooB,OAAApoB,EAAAmoB,SAGAnoB,EAAAooB,SACA6d,EAAA7d,OAAAxpB,KAAAC,UAAAmB,EAAAooB,cAGA,IAAApoB,EAAA6+B,gBACAoH,EAAApH,gBAAA7+B,EAAA6+B,oBAGA,IAAA7+B,EAAAojB,QACA6iB,EAAA7iB,MAAApjB,EAAAojB,YAGA,IAAApjB,EAAAgoB,OACAie,EAAAje,KAAAhoB,EAAAgoB,MAGA,IAAAihB,EAAAjD,GAAAC,QAEA,IAAAjmC,EAAAxC,OACAqT,EAAA,OACAonB,EAAA,CAAcz6B,KAAAwC,EAAAxC,OAGd4pC,EAAAzB,GAAAG,EAAA,YAAAmD,GAAA,CACAp4B,SACAonB,KAAAr5B,KAAAC,UAAAo5B,KACKnvB,KAAA,SAAAsD,GACLpM,EAAAyU,cAAAzU,EAAA0U,aAAA1U,EAAA4Y,QACAxM,EAAA2H,KAAA4b,KAAAhuB,QAAAqjC,IAEA94B,EAAA,KAAAE,EAAA2H,QACKyS,MAAAta,KAMLoY,EAAAhB,SAAA,SAAAtjB,GAMA,IAAA09B,EAAA,eAAA19B,IAAAkpC,WAAAvE,KAEA3kC,EAAAkL,EAAAlL,IAEA+iB,YAAA,cAAA/iB,IACAA,EAAAmpC,UAAArE,IAGA,IAAAsE,EAAA,YAAAppC,IAAAqpC,QAAA,IAGA,YAAArpC,KAAAqpC,SACAD,EAAAppC,EAAAqpC,QAAAxE,KACAuE,EAAAppC,EAAAqpC,QAAAxE,IAIA,cAAA7kC,KAAAmpC,WACAC,EAAAppC,EAAAmpC,UAAAtE,KACAuE,EAAAppC,EAAAmpC,UAAAtE,IAGA,IAAAoB,EAAA,GACA,YAAAjmC,KAAAqpC,UACApD,EAAAoD,QAAArpC,EAAAqpC,SAGA,IAAAjmB,OAAA,IAAApjB,EAAAojB,OAAApjB,EAAAojB,MACAkmB,EAAAlmB,EAqDA,GAnDApjB,EAAAe,QACAklC,EAAAllC,MAAAf,EAAAe,QAGAf,EAAAyU,cAAAzU,EAAAiQ,QAAA,mBAAAjQ,EAAAiQ,UACAg2B,EAAAxxB,cAAA,GAGAzU,EAAA0U,cACAuxB,EAAAvxB,aAAA,GAGA1U,EAAA+iB,aACAkjB,EAAAsD,KAAA,YAGAvpC,EAAAwpC,eACAvD,EAAAuD,aAAAxpC,EAAAwpC,cAGAxpC,EAAA+c,YACAkpB,EAAAlpB,WAAA,GAGA/c,EAAAmjB,aACA8iB,EAAA9iB,YAAA,GAIAnjB,EAAAujB,aACA0iB,EAAA1iB,YAAA,GAGA,cAAAvjB,GAEAA,EAAAmpC,YACAlD,EAAAkD,UAAAnpC,EAAAmpC,WAIAnpC,EAAAiQ,QAAA,iBAAAjQ,EAAAiQ,SACAg2B,EAAAh2B,OAAAjQ,EAAAiQ,QAGAjQ,EAAA6yB,MAAA,iBAAA7yB,EAAA6yB,OACAoT,EAAAh2B,OAAA,QACAg2B,EAAApT,KAAA7yB,EAAA6yB,MAKA7yB,EAAAoU,cAAA,iBAAApU,EAAAoU,aACA,QAAAq1B,KAAAzpC,EAAAoU,aAEApU,EAAAoU,aAAArR,eAAA0mC,KACAxD,EAAAwD,GAAAzpC,EAAAoU,aAAAq1B,IAKA,IACAxR,EADApnB,EAAA,MAGA7Q,EAAA+yB,SAGAkT,EAAAh2B,OAAA,WACAY,EAAA,OACAonB,EAAA,CAAclF,QAAA/yB,EAAA+yB,UAGd/yB,EAAA8rB,WAEAma,EAAAh2B,OAAA,YACAY,EAAA,OACAonB,EAAA,CAAcnM,SAAA9rB,EAAA8rB,WAGd,IACA4d,EADAC,EAAA,IAAArvB,GAKAuuB,EAAA,SAAA/2B,EAAA5F,GACA,IAAAlM,EAAA4pC,QAAA,CAGA3D,EAAAn0B,QAGA,iBAAAm0B,EAAAn0B,QACAm0B,EAAAn0B,MAAAlT,KAAAC,UAAAonC,EAAAn0B,QAGA9R,EAAAmjB,WACAC,IACA6iB,EAAA7iB,MAAAkmB,GAGArD,EAAA7iB,UAAAkmB,EAAA5L,EACAA,EAAA4L,EAIA,IAAAte,EAAA2a,GAAAG,EAAA,WAAAE,GAAAC,IACA4D,EAAA,CACAC,OAAAH,EAAAG,OACAj5B,SACAonB,KAAAr5B,KAAAC,UAAAo5B,IAEAyR,EAAA53B,EAGA9R,EAAA4pC,SAKAzC,IAAAr+B,KAAA,WACA,OAAAs+B,EAAApc,EAAA6e,EAAA39B,KACOsa,MAAAta,KAMPiD,EAAA,CAAmBA,QAAA,IAEnB46B,EAAA,SAAA1hC,EAAAuE,GACA,IAAA5M,EAAA4pC,QAAA,CAGA,IAAAI,EAAA,EAEA,GAAAp9B,KAAAuC,QAAA,CACA66B,EAAAp9B,EAAAuC,QAAAzR,OACAyR,EAAAsX,SAAA7Z,EAAA6Z,SACA,IAAAjG,EAAA,KACAC,EAAA,KAGA,iBAAA7T,EAAA4T,UACAA,EAAA5T,EAAA4T,SAEA,iBAAArR,EAAAsX,UAAA,iBAAAtX,EAAAsX,WACAhG,EAAAtR,EAAAsX,UAIAzmB,EAAAoU,aACAxH,EAAAuC,QAAAvC,EAAAuC,QAAAc,OAAA,SAAA2B,GACA03B,IACA,IAAAnoC,EAAA6S,GAAAhU,EAAAgU,CAAApC,GAUA,OATAzQ,IACAnB,EAAAyU,cAAAzU,EAAA0U,aAAA1U,EAAA4Y,QACAosB,GAAApzB,GAEA5R,EAAA4mB,aACAzX,UAAAjR,KAAA0T,GAEA5R,EAAAgS,SAAAJ,EAAA4O,EAAAC,IAEAtf,SAEO,GAAAkH,EAKP,OAFArI,EAAA4pC,SAAA,OACA5pC,EAAAkgB,SAAA7X,GAMAuE,KAAA6Z,WACAijB,EAAA98B,EAAA6Z,UAGA,IAAAwjB,EAAA7mB,GAAAkmB,GAAA,GACA18B,GAAAo9B,EAAAtM,GACA19B,EAAA,aAEAA,EAAA+iB,YAAAK,GAAAkmB,GAAA,IAAAW,EAKAjqC,EAAAkgB,SAAA,KAAA/Q,GAHQ7F,IAAQ,WAAcu/B,EAAAa,EAAAK,OAU9B,OAHAlB,EAAA7oC,EAAA8R,OAAA,EAAAi4B,GAGA,CACAxpB,OAAA,WACAvgB,EAAA4pC,SAAA,EACAD,EAAA5f,WAQAzF,EAAAU,SAAAkiB,EAAA,oBAAAjzB,EAAAjU,EAAAkM,GAEA,mBAAAlM,IACAkM,EAAAlM,EACAA,EAAA,IAIAonC,EAAAzB,GAAAG,EAAA,eACAj1B,OAAA,OACAonB,KAAAr5B,KAAAC,UAAAoV,IACK/H,GAAAsa,MAAAta,KAGLoY,EAAAmE,OAAA,SAAAvc,GACAA,KAGAoY,EAAAmF,SAAA,SAAA6c,EAAAp6B,GACAk7B,EAAAzB,GAAAG,EAAA,KAAmCj1B,OAAA,WAAiB/H,KAAA,SAAAsuB,GACpDlrB,EAAA,KAAAkrB,KACK5Q,MAAA,SAAAne,GAEL,MAAAA,EAAA+I,OACAlF,EAAA,MAAwBqC,IAAA,IAExBrC,EAAA7D,MAgBA,SAAA6hC,GAAAv3B,GACArT,KAAA8R,OAAA,IACA9R,KAAA6C,KAAA,oBACA7C,KAAAqT,UACArT,KAAAO,OAAA,EACA,IACAJ,MAAA0qC,kBAAA7qC,KAAA4qC,IACG,MAAA7lC,KAKH,SAAA+lC,GAAAz3B,GACArT,KAAA8R,OAAA,IACA9R,KAAA6C,KAAA,YACA7C,KAAAqT,UACArT,KAAAO,OAAA,EACA,IACAJ,MAAA0qC,kBAAA7qC,KAAA8qC,IACG,MAAA/lC,KAKH,SAAAgmC,GAAA13B,GACArT,KAAA8R,OAAA,IACA9R,KAAA6C,KAAA,gBACA7C,KAAAqT,UACArT,KAAAO,OAAA,EACA,IACAJ,MAAA0qC,kBAAA7qC,KAAA+qC,IACG,MAAAhmC,KAKH,SAAAimC,GAAAriC,EAAAiE,GAYA,OAXAA,GACAjE,EAAAa,KAAA,SAAA8D,GACMtD,IAAQ,WACd4C,EAAA,KAAAU,MAEK,SAAApF,GACC8B,IAAQ,WACd4C,EAAA1E,OAIAS,EA2BA,SAAAsiC,GAAAjsB,EAAAksB,GACA,kBACA,IAAAnsC,EAAAJ,UACAwsC,EAAAnrC,KACA,OAAAgf,EAAAlX,IAAA,WACA,OAAAojC,EAAAnrC,MAAAorC,EAAApsC,MAOA,SAAAqsC,GAAA/8B,GACA,IAAAg9B,EAAA,IAAA9/B,EAAA8C,GACAvB,EAAA,IAAA1P,MAAAiuC,EAAAjgC,MACA6H,GAAA,EAIA,OAHAo4B,EAAAhpC,QAAA,SAAA7F,GACAsQ,IAAAmG,GAAAzW,IAEAsQ,EAGA,SAAAw+B,GAAAxnC,GACA,IAAAgJ,EAAA,IAAA1P,MAAA0G,EAAAsH,MACA6H,GAAA,EAIA,OAHAnP,EAAAzB,QAAA,SAAA7F,EAAAmH,GACAmJ,IAAAmG,GAAAtP,IAEAmJ,EAGA,SAAAy+B,GAAA1oC,GAIA,WAAAkoC,GAHA,WAAAloC,EACA,gEAKA,SAAA2oC,GAAAv0B,GAEA,IADA,IAAAnK,EAAA,EACAxP,EAAA,EAAA0B,EAAAiY,EAAA7Y,OAAsCd,EAAA0B,EAAS1B,IAAA,CAC/C,IAAAmxB,EAAAxX,EAAA3Z,GACA,oBAAAmxB,EAAA,CACA,IAAArxB,MAAAkG,QAAAmrB,GAcA,MAAA8c,GAAA,QAZAz+B,EAAA,iBAAAA,EAAA,CAAAA,KACA,QAAAuD,EAAA,EAAAo7B,EAAAhd,EAAArwB,OAA0CiS,EAAAo7B,EAAUp7B,IAAA,CACpD,IAAAq7B,EAAAjd,EAAApe,GACA,oBAAAq7B,EACA,MAAAH,GAAA,aACW,IAAAz+B,EAAAuD,GACXvD,EAAAlO,KAAA8sC,GAEA5+B,EAAAuD,IAAAq7B,OAMK,iBAAA5+B,EACLA,GAAA2hB,EAEA3hB,EAAA,IAAA2hB,EAGA,OAAA3hB,EArJA85B,GAAA7jB,MAAA,WACA,UAkBA5Y,IAAQygC,GAAAzqC,OAYRgK,IAAQ2gC,GAAA3qC,OAYRgK,IAAQ4gC,GAAA5qC,OA6GR,IAAAkH,GAAAiK,EAAAvU,KAAA,YACAuG,GAAAlG,MAAAkG,QACAgrB,GAAAhvB,KAAA+4B,MAEA,SAAAsT,GAAAn/B,EAAAY,GACA,OAAA0J,GACA,WAAAtK,EAAArN,QAAA,QAAgC,SAChC,CACAiO,OACAo+B,OACAnkC,OACA/D,WACAgrB,YAWA,SAAAsd,KACA5rC,KAAA2I,QAAA,IAAAC,QAAA,SAAA8D,GAAiDA,MAcjD,SAAAnN,GAAA0zB,GACA,IAAAA,EACA,kBAIA,cAAAA,GACA,eAGA,aAEA,OAAAA,EAAAv1B,WACA,QAEA,OAAA4B,KAAAC,UAAA0zB,IAUA,SAAA4Y,GAAAC,EAAApY,EAAAE,EAAAmY,EAAAC,EAAAC,GACA,IAEAC,EAFAC,EANA,SAAAvY,EAAAmY,GAEA,OAAAxsC,GAAAq0B,GAAAr0B,GAAAwsC,GAAA,YAIAK,CAAAxY,EAAAmY,GAGA,IAAAC,IAEAE,EAAAJ,EAAAO,aAAAP,EAAAO,cAAA,IACAF,GACA,OAAAD,EAAAC,GAIA,IAAAG,EAAAR,EAAAh8B,OAAAtG,KAAA,SAAAsG,GAEA,IAAAy8B,EAAAz8B,EAAAuZ,QAAA,YACA2iB,EAAA,OAAAzwB,GAAA4wB,IAkBA,OAAAj1B,GAAA40B,EAAA,UAAAG,EAdA,SAAAj3B,GACAA,EAAA6e,MAAA7e,EAAA6e,OAAA,GACA,IAAA2Y,EAAA9Y,GACA,IAAA8Y,EAAA7pC,QAAA,OACA6pC,EAAA9Y,EAAA,IAAAA,GAEA,IAAA+Y,EAAAz3B,EAAA6e,MAAA2Y,GAAAx3B,EAAA6e,MAAA2Y,IAAA,GAEA,IAAAC,EAAAF,GAIA,OADAE,EAAAF,IAAA,EACAv3B,IAEAxL,KAAA,WACA,OAAAsiC,EAAAjiB,0BAAA0iB,GAAA/iC,KAAA,SAAA8D,GACA,IAAA6B,EAAA7B,EAAA6B,GACAA,EAAAkT,iBAAA,EACA,IAAAkR,EAAA,CACA1wB,KAAA0pC,EACAp9B,KACA28B,WACAtpB,QAAAspB,EAAAtpB,QACAoR,SACAmY,aAEA,OAAAxY,EAAApkB,GAAA7K,IAAA,kBAAA4iB,MAAA,SAAAne,GAEA,SAAAA,EAAA+I,OACA,MAAA/I,IAESS,KAAA,SAAAkjC,GAOT,OANAnZ,EAAAhhB,IAAAm6B,IAAAn6B,IAAA,EACA25B,GACA3Y,EAAApkB,GAAA/C,KAAA,8BACA8/B,EAAAC,KAGA5Y,UASA,OAHA2Y,IACAA,EAAAC,GAAAG,GAEAA,EAvGAV,GAAAtvC,UAAAwL,IAAA,SAAAojC,GAMA,OALAlrC,KAAA2I,QAAA3I,KAAA2I,QAAAue,MAAA,cAEG1d,KAAA,WACH,OAAA0hC,MAEAlrC,KAAA2I,SAEAijC,GAAAtvC,UAAAihC,OAAA,WACA,OAAAv9B,KAAA2I,SAiGA,IAAAgkC,GAAA,GACAC,GAAA,IAAAhB,GACAiB,GAAA,GAEA,SAAAC,GAAAjqC,GAGA,WAAAA,EAAAF,QAAA,MAAAE,OAAA2B,MAAA,KASA,SAAAuoC,GAAA59B,EAAApK,GACA,IACAoK,EAAA/B,KAAA,QAAArI,GACG,MAAAgE,GACHuI,EAAA,QACA,qMAIAA,EAAA,QAAAvM,IA+4BA,IAAAioC,GAAA,CACAC,KAAA,SAAA/uC,EAAA+Y,GACA,OAAAu0B,GAAAv0B,IAGAi2B,OAAA,SAAAhvC,EAAA+Y,GACA,OAAAA,EAAA7Y,QAGA+uC,OAAA,SAAAjvC,EAAA+Y,GAWA,OACAu0B,OAAAv0B,GACA/G,IAAA3S,KAAA2S,IAAAnQ,MAAA,KAAAkX,GACAxF,IAAAlU,KAAAkU,IAAA1R,MAAA,KAAAkX,GACA0O,MAAA1O,EAAA7Y,OACAgvC,OAbA,SAAAn2B,GAEA,IADA,IAAAo2B,EAAA,EACA/vC,EAAA,EAAA0B,EAAAiY,EAAA7Y,OAA0Cd,EAAA0B,EAAS1B,IAAA,CACnD,IAAAmxB,EAAAxX,EAAA3Z,GACA+vC,GAAA5e,IAEA,OAAA4e,EAOAD,CAAAn2B,MA+CA,IACAq2B,GA17BA,SAAArB,EAAAsB,EAAAC,EAAAC,GAEA,SAAAC,EAAAv+B,EAAA9C,EAAA2I,GAGA,IACA3I,EAAA2I,GACK,MAAAjQ,GACLgoC,GAAA59B,EAAApK,IAIA,SAAA4oC,EAAAx+B,EAAA9C,EAAAnO,EAAA+Y,EAAA22B,GAKA,IACA,OAAczqC,OAAAkJ,EAAAnO,EAAA+Y,EAAA22B,IACT,MAAA7oC,GAEL,OADAgoC,GAAA59B,EAAApK,GACA,CAAcxE,MAAAwE,IAId,SAAA8oC,EAAAzuC,EAAA0uC,GACA,IAAAC,EAAAtgB,GAAAruB,EAAAuE,IAAAmqC,EAAAnqC,KACA,WAAAoqC,IAAAtgB,GAAAruB,EAAA5C,MAAAsxC,EAAAtxC,OAGA,SAAAwxC,EAAAn+B,EAAAiU,EAAA4E,GAEA,OADAA,KAAA,EACA,iBAAA5E,EACAjU,EAAA/E,MAAA4d,EAAA5E,EAAA4E,GACKA,EAAA,EACL7Y,EAAA/E,MAAA4d,GAEA7Y,EAGA,SAAAo+B,EAAAzmB,GACA,IAAAllB,EAAAklB,EAAAhrB,MAIA,OADA8F,GAAA,iBAAAA,KAAAkV,KAAAgQ,EAAAhY,GAiBA,SAAA0+B,EAAAxtC,GACA,gBAAA4M,GAIA,OAHA5M,EAAAyU,cAAAzU,EAAA0U,aAAA1U,EAAA4Y,QAfA,SAAAhM,GACAA,EAAA+iB,KAAAhuB,QAAA,SAAAmlB,GACA,IAAAkC,EAAAlC,EAAAxS,KAAAwS,EAAAxS,IAAAM,aACAoU,GAGA3tB,OAAAmC,KAAAwrB,GAAArnB,QAAA,SAAAo7B,GACA,IAAApoB,EAAAqU,EAAA+T,GACA/T,EAAA+T,GAAAhpB,KAAAoE,GAAAxD,EAAAZ,KAAAY,EAAA8P,kBAQAugB,CAAAp4B,GAEAA,GAIA,SAAA6gC,EAAAC,EAAA1tC,EAAAimC,EAAA0H,GAEA,IAAA/rC,EAAA5B,EAAA0tC,QACA,IAAA9rC,IACA+rC,IACA/rC,EAAAsjC,mBAAAtmC,KAAAC,UAAA+C,KAEAqkC,EAAA/nC,KAAAwvC,EAAA,IAAA9rC,IAIA,SAAAgsC,EAAAC,GACA,YAAAA,EAAA,CACA,IAAAC,EAAAnvC,OAAAkvC,GAEA,OAAAngB,MAAAogB,QAAA98B,SAAA68B,EAAA,IAGAA,EAFAC,GA2BA,SAAAC,EAAAzH,EAAA36B,GACA,IAAAqiC,EAAA1H,EAAAnjB,WAAA,oBACA8qB,EAAA3H,EAAAnjB,WAAA,oBAEA,YAAAmjB,EAAA0H,SACA,IAAA1H,EAAA2H,IACAlhB,GAAAuZ,EAAA0H,GAAA1H,EAAA2H,IAAA,EACA,UAAA/D,GAAA,mGAEK,GAAAv+B,EAAArI,SAAA,IAAAgjC,EAAAhjC,OAAA,CACL,GAAAgjC,EAAA7xB,aACA,UAAAy1B,GAAA,6CACO,GAAA5D,EAAA9oC,MAAA8oC,EAAA9oC,KAAAE,OAAA,IACP4oC,EAAA4H,QAAA5H,EAAA6H,YACA,UAAAjE,GAAA,6DAIA,+BAAAvoC,QAAA,SAAAysC,GACA,IAAAvuC,EAhCA,SAAAgG,GACA,GAAAA,EAAA,CACA,oBAAAA,EACA,WAAAqkC,GAAA,+BACArkC,EAAA,KAEA,GAAAA,EAAA,EACA,WAAAqkC,GAAA,wCACArkC,EAAA,MAwBAwoC,CAAA/H,EAAA8H,IACA,GAAAvuC,EACA,MAAAA,IA+IA,SAAAyuC,EAAAxyC,GACA,gBAAA0L,GAEA,SAAAA,EAAA4J,OACA,OAAAtV,EAEA,MAAA0L,GAQA,SAAA+mC,EAAA7+B,EAAAmjB,EAAA2b,GACA,IAAAC,EAAA,cAAA/+B,EACAg/B,EAAA,CAA0B53B,IAAA23B,EAAAjxC,KAAA,IAC1BmxC,EAAAH,EAAA5qC,IAAA8L,GACAk/B,EAAAD,EAAA,GA+DA,OAnZA,SAAAh9B,GAGA,WAAAA,EAAAjU,QAAA,MAAAmH,KAAA8M,EAAA,GAAA3B,KAqVA6+B,CAHAF,EAAA,IAMAzmC,QAAAC,QAAAumC,GAEA7b,EAAApkB,GAAA7K,IAAA6qC,GAAAjoB,MAAA8nB,EAAAI,KAsDA5lC,KAAA,SAAAyxB,GACA,OApDA,SAAAA,GACA,OAAAA,EAAA/8B,KAAAE,OAIAm1B,EAAApkB,GAAAsZ,QAAA,CACAvqB,KAAA+8B,EAAA/8B,KACAiX,cAAA,IAJAvM,QAAAC,QAAA,CAAgCwnB,KAAA,KAiDhCmf,CAAAvU,GAAAzxB,KAAA,SAAAimC,GACA,OA1CA,SAAAxU,EAAAwU,GAIA,IAHA,IAAAC,EAAA,GACAC,EAAA,IAAApkC,EAEAjO,EAAA,EAAA0B,EAAAywC,EAAApf,KAAAjyB,OAAkDd,EAAA0B,EAAS1B,IAAA,CAC3D,IACA0X,EADAy6B,EAAApf,KAAA/yB,GACA0X,IACA,GAAAA,IAGA06B,EAAA9wC,KAAAoW,GACA26B,EAAA7nC,IAAAkN,EAAAwC,KACAxC,EAAAqP,UAAAirB,EAAA/gC,IAAAyG,EAAAwC,MACAxC,EAAAqP,UAAA,CACA,IAAAurB,EAAAN,EAAAhrC,IAAA0Q,EAAAwC,KACA,UAAAo4B,IACA56B,EAAAxY,MAAAozC,EAAApzC,QAIA,IAAAqzC,EAAAvE,GAAAgE,GAiBA,OAhBAO,EAAAxtC,QAAA,SAAAsB,GACA,IAAAgsC,EAAAphC,IAAA5K,GAAA,CAEA,IAAAmsC,EAAA,CACAt4B,IAAA7T,GAEAisC,EAAAN,EAAAhrC,IAAAX,GACA,UAAAisC,IACAE,EAAAtzC,MAAAozC,EAAApzC,OAEAkzC,EAAA9wC,KAAAkxC,MAGA7U,EAAA/8B,KAAAktC,GAAAyE,EAAAriC,OAAAytB,EAAA/8B,OACAwxC,EAAA9wC,KAAAq8B,GAEAyU,EAKAK,CAAA9U,EAAAwU,OAyBA,SAAAO,EAAAzc,GACA,IAAAG,EAAA,iBAAAH,MAAA1wB,KACAmc,EAAA2tB,GAAAjZ,GAIA,OAHA1U,IACAA,EAAA2tB,GAAAjZ,GAAA,IAAAkY,IAEA5sB,EAGA,SAAAixB,EAAA1c,GACA,OAAA0X,GAAA+E,EAAAzc,GAAA,WACA,OAIA,SAAAA,GAEA,IAAA2c,EACAl7B,EAYA4e,EAAA2Z,EAAAha,EAAAK,OAVA,SAAAjwB,EAAAnH,GACA,IAAA2G,EAAA,CAAoBqM,GAAAwF,EAAAwC,IAAA7T,IAAA+pB,GAAA/pB,IAGpB,MAAAnH,IACA2G,EAAA3G,MAAAkxB,GAAAlxB,IAEA0zC,EAAAtxC,KAAAuE,KAKAgtC,EAAA5c,EAAAhhB,KAAA,EAEA,SAAAgP,EAAA2tB,EAAA38B,GACA,kBACA,OAtDA,SAAAghB,EAAA2b,EAAA38B,GAEA,OAAAghB,EAAApkB,GAAA7K,IADA,kBAEA4iB,MAAA8nB,EAAA,CAAyBx3B,IAFzB,iBAEyBjF,IAAA,KACzB/I,KAAA,SAAAkjC,GACA,IAAAhM,EAAA4K,GAAA4D,GACA,OAAAtmC,QAAA6e,IAAAiZ,EAAA58B,IAAA,SAAAsM,GACA,OAAA6+B,EAAA7+B,EAAAmjB,EAAA2b,MACS1lC,KAAA,SAAA4mC,GACT,IAAAC,EAAA76B,GAAA46B,GAIA,OAHA1D,EAAAn6B,MACA89B,EAAAzxC,KAAA8tC,GAEAnZ,EAAApkB,GAAAgV,SAAA,CAAmC9U,KAAAghC,QAyCnCC,CAAA/c,EAAA2b,EAAA38B,IAIA,IAAAyM,EAAA,IAAA4sB,GAEA,SAAA2E,IACA,OAAAhd,EAAAuY,SAAAz5B,QAAA,CACAiV,aAAA,EACA7J,WAAA,EACAtI,cAAA,EACA1T,MAAA,WACA+Q,MAAA29B,EACArsB,MAAA+oB,KACOrjC,KAAAsH,GAGP,SAAAA,EAAAi3B,GACA,IAAAl4B,EAAAk4B,EAAAl4B,QACA,GAAAA,EAAAzR,OAAA,CAGA,IAAA8wC,EAQA,SAAAr/B,GAEA,IADA,IAAAq/B,EAAA,IAAA1jC,EACAlO,EAAA,EAAA0B,EAAA6Q,EAAAzR,OAA2Cd,EAAA0B,EAAS1B,IAAA,CACpD,IAAAyX,EAAAlF,EAAAvS,GACA,SAAAyX,EAAAC,IAAAwC,IAAA,IACA04B,EAAA,IACAl7B,EAAAD,EAAAC,KAEAqP,UACAqpB,EAAAna,EAAAuY,SAAAlY,EAAA5e,GAEAk7B,EAAA7yB,KAAAwwB,GAEA,IAAAyB,EAAAkB,EAAAN,GACAhB,EAAA3qC,IAAAwQ,EAAAC,IAAAwC,IAAA,CACA83B,EACAv6B,EAAA1C,UAGA89B,EAAAp7B,EAAAxC,IAEA,OAAA28B,EA7BAuB,CAAA5gC,GAEA,GADAmP,EAAAlX,IAAAyZ,EAAA2tB,EAAAiB,MACAtgC,EAAAzR,OAAAyuC,IAGA,OAAA0D,KA2BA,SAAAC,EAAAN,GAGA,IAFA,IACAnR,EADAuQ,EAAA,IAAA9jC,EAEAlO,EAAA,EAAA0B,EAAAkxC,EAAA9xC,OAA8Cd,EAAA0B,EAAS1B,IAAA,CACvD,IAAAozC,EAAAR,EAAA5yC,GACAqzC,EAAA,CAAAD,EAAA/sC,IAAA+sC,EAAAlhC,IACAlS,EAAA,OAAAmwB,GAAAijB,EAAA/sC,IAAAo7B,IACA4R,EAAA/xC,KAAAtB,GAEAgyC,EAAA/qC,IAAAkrB,GAAAkhB,GAAAD,GACA3R,EAAA2R,EAAA/sC,IAEA,OAAA2rC,EAGA,OAAAiB,IAAA/mC,KAAA,WACA,OAAAwV,EAAAue,WACK/zB,KAAA,WACL+pB,EAAAhhB,IAAA49B,IAjGAS,CAAArd,IADA0X,GAwJA,SAAA4F,EAAAtd,EAAA7yB,GACA,OAAAuqC,GAAA+E,EAAAzc,GAAA,WACA,OAIA,SAAAA,EAAA7yB,GACA,IAAAowC,EACAC,EAAAxd,EAAAwY,YAAA,IAAArrC,EAAAsD,OACA0kB,EAAAhoB,EAAAgoB,MAAA,EAOA,SAAAsoB,EAAAC,GAEA,OADAA,EAAA97B,cAAA,EACAoe,EAAApkB,GAAAsZ,QAAAwoB,GAAAznC,KAAA,SAAA8D,GAEA,OADAwjC,EAAAxjC,EAAA6yB,WACA7yB,EAAA+iB,KAAAvsB,IAAA,SAAAgJ,GAMA,aAAAA,EAAAkI,KAAA,iBAAAlI,EAAAkI,IAAAxY,OACA,OAAAsQ,EAAAkI,IAAAxY,MAAA,CACA,IAAA0B,EAAAnC,OAAAmC,KAAA4O,EAAAkI,IAAAxY,OAAA6gB,OAGA6zB,EAAA,qBACA,KAAAhzC,EAAAgzC,GAAAhzC,EAAAgzC,GACA,OAAApkC,EAAAkI,IAAAxY,MAIA,IAAA20C,EA/7JA,SAAAlyC,GAMA,IALA,IAAA8wB,EAAA,GACAC,EAAA,GACA1yB,EAAA,IAGA,CACA,IAAAswB,EAAA3uB,EAAA3B,KACA,UAAAswB,EAQA,OAAAA,GACA,QACAmC,EAAAnxB,KAAA,MACA,MACA,QACAmxB,EAAAnxB,KAAA,MAAAK,EAAA3B,IACAA,IACA,MACA,QACA,IAAA8zC,EAAAzhB,GAAA1wB,EAAA3B,GACAyyB,EAAAnxB,KAAAwyC,EAAA3iB,KACAnxB,GAAA8zC,EAAAhzC,OACA,MACA,QAGA,IAFA,IAAAizC,EAAA,KAEA,CACA,IAAAplB,EAAAhtB,EAAA3B,GACA,UAAA2uB,EACA,MAEAolB,GAAAplB,EACA3uB,IAKA+zC,IAAAlyC,QAAA,sBACAA,QAAA,qBACAA,QAAA,qBAEA4wB,EAAAnxB,KAAAyyC,GACA,MACA,QACA,IAAAC,EAAA,CAA4BphB,QAAA,GAAAjd,MAAA8c,EAAA3xB,QAC5B2xB,EAAAnxB,KAAA0yC,EAAAphB,SACAF,EAAApxB,KAAA0yC,GACA,MACA,QACA,IAAAC,EAAA,CAA0BrhB,QAAA,GAAYjd,MAAA8c,EAAA3xB,QACtC2xB,EAAAnxB,KAAA2yC,EAAArhB,SACAF,EAAApxB,KAAA2yC,GACA,MAEA,QACA,UAAApxC,MACA,4DACAytB,OAvDA,CACA,OAAAmC,EAAA3xB,OACA,OAAA2xB,EAAAhsB,MAEAA,GAAAgsB,EAAAC,KAm7JAwhB,CAAA1kC,EAAAkI,IAAAwC,KACA,OACA7T,IAAAwtC,EAAA,GACA3hC,GAAA2hC,EAAA,GACA30C,MAAA,UAAAsQ,EAAAkI,IAAAlI,EAAAkI,IAAAxY,MAAA,UAMA,SAAAi1C,EAAAphB,GACA,IAAAqhB,EAcA,GAZAA,EADAX,EAnGA,SAAAxd,EAAA1jB,EAAAm3B,GACA,IAAAA,EAAA6H,oBACA7H,EAAA6H,YAGA,IAAA8C,EAAA3K,EAAA4H,OAAA5H,EAAA6H,YAEA9C,EAAAyB,EAAAja,EAAAwY,WAEA6F,EAAA,GACAC,EAAAzjB,MAAA4Y,EAAA6H,aAAAxvC,OAAAyyC,kBACA9K,EAAA6H,YACAh/B,EAAAxN,QAAA,SAAA0C,GACA,IAAAgtC,EAAAH,IAAAxzC,OAAA,GACA4zC,EAAAL,EAAA5sC,EAAApB,IAAA,KAOA,GAJAguC,GAAAv0C,MAAAkG,QAAA0uC,KACAA,IAAAlnC,MAAA,EAAA+mC,IAGAE,GAAA,IAAAtkB,GAAAskB,EAAAC,YAGA,OAFAD,EAAA7zC,KAAAU,KAAA,CAAAmG,EAAApB,IAAAoB,EAAAyK,UACAuiC,EAAA96B,OAAArY,KAAAmG,EAAAvI,OAGAo1C,EAAAhzC,KAAA,CACAV,KAAA,EAAA6G,EAAApB,IAAAoB,EAAAyK,KACAyH,OAAA,CAAAlS,EAAAvI,OACAw1C,eAGAniC,EAAA,GACA,QAAAvS,EAAA,EAAA0B,EAAA4yC,EAAAxzC,OAAwCd,EAAA0B,EAAS1B,IAAA,CACjD,IAAAyH,EAAA6sC,EAAAt0C,GACA20C,EAAAtE,EAAApa,EAAAuY,SAAAC,EAAAhnC,EAAA7G,KAAA6G,EAAAkS,QAAA,GACA,GAAAg7B,EAAA1xC,OAAA0xC,EAAA1xC,iBAAAwqC,GAEA,MAAAkH,EAAA1xC,MAEAsP,EAAAjR,KAAA,CAEApC,MAAAy1C,EAAA1xC,MAAA,KAAA0xC,EAAA9uC,OACAQ,IAAAoB,EAAAitC,WAIA,OAAY3hB,KAAA2d,EAAAn+B,EAAAm3B,EAAAljB,MAAAkjB,EAAAte,OAqDZwpB,CAAA3e,EAAAlD,EAAA3vB,GAEA,CACAy/B,WAAA2Q,EACAjzC,OAAA6qB,EACA2H,QAIA3vB,EAAAujB,aACAytB,EAAAztB,WAAAsP,EAAAhhB,KAEA7R,EAAAyU,aAAA,CACA,IAAAurB,EAAA0K,GAAA/a,EAAAvsB,IAAAmqC,IAEA,OAAA1a,EAAAuY,SAAArjB,QAAA,CACAvqB,KAAAwiC,EACAvrB,cAAA,EACAsI,UAAA/c,EAAA+c,UACArI,YAAA1U,EAAA0U,YACAkE,OAAA5Y,EAAA4Y,SACS9P,KAAA,SAAA2oC,GACT,IAAAC,EAAA,IAAA5mC,EAWA,OAVA2mC,EAAA9hB,KAAAhuB,QAAA,SAAAmlB,GACA4qB,EAAA7tC,IAAAijB,EAAAhY,GAAAgY,EAAAxS,OAEAqb,EAAAhuB,QAAA,SAAAmlB,GACA,IAAApX,EAAA69B,EAAAzmB,GACAxS,EAAAo9B,EAAA9tC,IAAA8L,GACA4E,IACAwS,EAAAxS,SAGA08B,IAGA,OAAAA,EAIA,QAhFA,IAAAhxC,EAAAxC,MAAAwC,EAAAxC,KAAAE,SAEAsC,EAAAojB,MAAA,SACApjB,EAAAxC,WA6EA,IAAAwC,EAAAxC,KAAA,CACA,IAAAA,EAAAwC,EAAAxC,KACAm0C,EAAAn0C,EAAA4F,IAAA,SAAAH,GACA,IAAAstC,EAAA,CACAroB,SAAA6G,GAAA,CAAA9rB,IACAmlB,OAAA2G,GAAA,CAAA9rB,EAAA,MAMA,OAHAjD,EAAAujB,aACAgtB,EAAAhtB,YAAA,GAEA+sB,EAAAC,KAEA,OAAAroC,QAAA6e,IAAA4qB,GAAA7oC,KAAAgM,IAAAhM,KAAAioC,GAEA,IAOA7oB,EACAE,EARAmoB,EAAA,CACAptB,WAAAnjB,EAAAmjB,YAyBA,GAtBAnjB,EAAAujB,aACAgtB,EAAAhtB,YAAA,GAIA,cAAAvjB,IACAkoB,EAAAloB,EAAAioB,WAEA,aAAAjoB,IACAkoB,EAAAloB,EAAAkoB,UAEA,YAAAloB,IACAooB,EAAApoB,EAAAmoB,SAEA,WAAAnoB,IACAooB,EAAApoB,EAAAooB,aAEA,IAAAF,IACAqoB,EAAAroB,SAAAloB,EAAAmjB,WACA4L,GAAA,CAAA7G,EAAA,KACA6G,GAAA,CAAA7G,UAEA,IAAAE,EAAA,CACA,IAAAwW,GAAA,IAAA5+B,EAAA6+B,cACA7+B,EAAAmjB,aACAyb,MAGA2R,EAAAnoB,OAAA2G,GACA6P,EAAA,CAAAxW,EAAA,IAAoC,CAAAA,IAEpC,YAAApoB,EAAAiD,IAAA,CACA,IAAA2uC,EAAA7iB,GAAA,CAAA/uB,EAAAiD,MACA4uC,EAAA9iB,GAAA,CAAA/uB,EAAAiD,IAAA,KACAstC,EAAAptB,YACAotB,EAAAnoB,OAAAwpB,EACArB,EAAAroB,SAAA2pB,IAEAtB,EAAAroB,SAAA0pB,EACArB,EAAAnoB,OAAAypB,GASA,OANAxB,IACA,iBAAArwC,EAAAojB,QACAmtB,EAAAntB,MAAApjB,EAAAojB,OAEAmtB,EAAAvoB,QAEAsoB,EAAAC,GAAAznC,KAAAioC,GA3JAe,CAAAjf,EAAA7yB,IADAuqC,GA+NA,SAAAwH,EAAAtjC,EAAA9C,EAAA3L,GAEA,sBAAAyO,EAAAujC,OACA,OA1gBA,SAAAvjC,EAAA9C,EAAA3L,GACA,WAAAkI,QAAA,SAAAC,EAAAC,GACAqG,EAAAujC,OAAArmC,EAAA3L,EAAA,SAAAqI,EAAAuE,GACA,GAAAvE,EACA,OAAAD,EAAAC,GAEAF,EAAAyE,OAogBAqlC,CAAAxjC,EAAA9C,EAAA3L,GAEA,GAAAiV,GAAAxG,GACA,OA9nBA,SAAAA,EAAA9C,EAAA3L,GAEA,IACAi4B,EAEA1pB,EAAA6C,EAHA60B,EAAA,GAEAp1B,EAAA,MA+BA,GAxBA48B,EAAA,SAAAztC,EAAAimC,GACAwH,EAAA,eAAAztC,EAAAimC,GACAwH,EAAA,cAAAztC,EAAAimC,GACAwH,EAAA,QAAAztC,EAAAimC,GACAwH,EAAA,aAAAztC,EAAAimC,GACAwH,EAAA,QAAAztC,EAAAimC,GACAwH,EAAA,cAAAztC,EAAAimC,GACAwH,EAAA,OAAAztC,EAAAimC,GACAwH,EAAA,QAAAztC,EAAAimC,GACAwH,EAAA,YAAAztC,EAAAimC,GACAwH,EAAA,WAAAztC,EAAAimC,GAAA,GACAwH,EAAA,YAAAztC,EAAAimC,GAAA,GACAwH,EAAA,SAAAztC,EAAAimC,GAAA,GACAwH,EAAA,UAAAztC,EAAAimC,GAAA,GACAwH,EAAA,gBAAAztC,EAAAimC,GACAwH,EAAA,MAAAztC,EAAAimC,GAAA,GACAwH,EAAA,aAAAztC,EAAAimC,GAIAA,EAAA,MADAA,IAAA7nC,KAAA,MACA,OAAA6nC,OAIA,IAAAjmC,EAAAxC,KAAA,CACA,IAIA00C,EACA,QAAAhN,mBAAAtmC,KAAAC,UAAAmB,EAAAxC,OACA00C,EAAAx0C,OAAAuoC,EAAAvoC,OAAA,GANA,IASAuoC,IAAA,MAAAA,EAAA,YAAAiM,GAEArhC,EAAA,OACA,iBAAAlF,EACAssB,EAAA,CAAkBz6B,KAAAwC,EAAAxC,MAElBmO,EAAAnO,KAAAwC,EAAAxC,MAMA,oBAAAmO,EAAA,CACA,IAAA0J,EAAA+2B,GAAAzgC,GACA,OAAA8C,EAAAwb,MAAA,WAAA5U,EAAA,aAAAA,EAAA,GAAA4wB,EAAA,CACAM,QAAA,IAAArc,GAAA,CAAwB8e,eAAA,qBACxBn4B,SACAonB,KAAAr5B,KAAAC,UAAAo5B,KACOnvB,KAAA,SAAAu+B,GAGP,OAFA94B,EAAA84B,EAAA94B,GACA6C,EAAAi2B,EAAAj2B,OACAi2B,EAAAjQ,SACOtuB,KAAA,SAAAsD,GACP,IAAAmC,EAEA,MADAnC,EAAAgF,SACA0C,GAAA1H,GASA,OANAA,EAAAujB,KAAAhuB,QAAA,SAAAmlB,GAEA,GAAAA,EAAAhrB,OAAAgrB,EAAAhrB,MAAA+D,OAAA,yBAAAinB,EAAAhrB,MAAA+D,MACA,UAAAJ,MAAAqnB,EAAAtf,UAGA4E,IACOtD,KAAA0kC,EAAAxtC,IAaP,OATAi4B,KAAA,GACA58B,OAAAmC,KAAAmO,GAAAhK,QAAA,SAAAsB,GACAvG,MAAAkG,QAAA+I,EAAA1I,IACAg1B,EAAAh1B,GAAA0I,EAAA1I,GAEAg1B,EAAAh1B,GAAA0I,EAAA1I,GAAAjG,aAIAyR,EAAAwb,MAAA,aAAAgc,EAAA,CACAM,QAAA,IAAArc,GAAA,CAAsB8e,eAAA,qBACtBn4B,OAAA,OACAonB,KAAAr5B,KAAAC,UAAAo5B,KACKnvB,KAAA,SAAAu+B,GAGL,OAFA94B,EAAA84B,EAAA94B,GACA6C,EAAAi2B,EAAAj2B,OACAi2B,EAAAjQ,SACKtuB,KAAA,SAAAsD,GACL,IAAAmC,EAEA,MADAnC,EAAAgF,SACA0C,GAAA1H,GAEA,OAAAA,IACKtD,KAAA0kC,EAAAxtC,IAmhBLmyC,CAAA1jC,EAAA9C,EAAA3L,GAGA,oBAAA2L,EAoBA,OAlBAoiC,EAAA/tC,EAAA2L,GAEAugC,GAAA9kC,IAAA,WAQA,OAPA+jC,GACA18B,EACA,sBACA9C,EAAAvI,IACAuI,EAAArI,QACA,EACAioC,GACAziC,KAAA,SAAA+pB,GACA,OApiCA5qB,EAoiCAsnC,EAAA1c,GAAA/pB,KAAA,WACA,OAAAqnC,EAAAtd,EAAA7yB,KAriCAoyC,EAsiCW,WACX,OAAAvf,EAAApkB,GAAAmM,WAtiCA3S,EAAAa,KAAA,SAAA8D,GACA,OAAAwlC,IAAAtpC,KAAA,WACA,OAAA8D,KAEG,SAAApF,GACH,OAAA4qC,IAAAtpC,KAAA,WACA,MAAAtB,MAPA,IAAAS,EAAAmqC,MA2iCAlG,GAAArP,SAGA,IAAAiP,EAAAngC,EACA0J,EAAA+2B,GAAAN,GACAuG,EAAAh9B,EAAA,GACA2d,EAAA3d,EAAA,GACA,OAAA5G,EAAA7K,IAAA,WAAAyuC,GAAAvpC,KAAA,SAAAwL,GACA,IAAA3I,EAAA2I,EAAA6e,OAAA7e,EAAA6e,MAAAH,GAEA,IAAArnB,EAEA,UAAAy+B,GAAA,QAAA91B,EAAAwC,IAAA,sBACAkc,GAaA,OAVA+Z,EAAAz4B,EAAA0e,GACA+a,EAAA/tC,EAAA2L,GAEAw/B,GACA18B,EACAq9B,EACAngC,EAAAvI,IACAuI,EAAArI,QACA,EACAioC,GACAziC,KAAA,SAAA+pB,GACA,aAAA7yB,EAAAsyC,OAAA,iBAAAtyC,EAAAsyC,OACA,iBAAAtyC,EAAAsyC,OACchpC,IAAQ,WACtBimC,EAAA1c,KAGAsd,EAAAtd,EAAA7yB,IAEAuvC,EAAA1c,GAAA/pB,KAAA,WACA,OAAAqnC,EAAAtd,EAAA7yB,SA2BA,IAtnCA2L,EAkoCA,OACAwI,MAhCA,SAAAxI,EAAA3L,EAAAkM,GACA,IAAAuC,EAAAnP,KACA,mBAAAU,IACAkM,EAAAlM,EACAA,EAAA,IAEAA,IArvBA,SAAAA,GAIA,OAHAA,EAAAmuC,YAAAP,EAAA5tC,EAAAmuC,aACAnuC,EAAAojB,MAAAwqB,EAAA5tC,EAAAojB,OACApjB,EAAAgoB,KAAA4lB,EAAA5tC,EAAAgoB,MACAhoB,EAivBAuyC,CAAAvyC,GAAA,GAEA,mBAAA2L,IACAA,EAAA,CAAavI,IAAAuI,IAGb,IAAA1D,EAAAC,QAAAC,UAAAW,KAAA,WACA,OAAAipC,EAAAtjC,EAAA9C,EAAA3L,KAGA,OADAsqC,GAAAriC,EAAAiE,GACAjE,GAiBAuqC,aApoCA7mC,EAsnCA,WACA,IAAA8C,EAAAnP,KAEA,yBAAAmP,EAAAgkC,aAxlBA,SAAAhkC,GACA,WAAAvG,QAAA,SAAAC,EAAAC,GACAqG,EAAAgkC,aAAA,SAAApqC,EAAAuE,GACA,GAAAvE,EACA,OAAAD,EAAAC,GAEAF,EAAAyE,OAmlBA8lC,CAAAjkC,GAEAwG,GAAAxG,GAjKA,SAAAA,GACA,OAAAA,EAAAwb,MAAA,iBACAsc,QAAA,IAAArc,GAAA,CAAsB8e,eAAA,qBACtBn4B,OAAA,SACK/H,KAAA,SAAAu+B,GACL,OAAAA,EAAAjQ,SA6JAub,CAAAlkC,GAzJA,SAAAA,GACA,OAAAA,EAAA7K,IAAA,UAAA2nC,GAAAziC,KAAA,SAAAyxB,GACA,IAAAqY,EAAA,IAAA9nC,EACAzP,OAAAmC,KAAA+8B,EAAApH,OAAAxxB,QAAA,SAAAmqC,GACA,IAAAz2B,EAAA+2B,GAAAN,GACAuG,EAAA,WAAAh9B,EAAA,GACA2d,EAAA3d,EAAA,GACA8d,EAAAyf,EAAAhvC,IAAAyuC,GACAlf,IACAA,EAAA,IAAAtoB,EACA+nC,EAAA/uC,IAAAwuC,EAAAlf,IAEAA,EAAA/rB,IAAA4rB,KAEA,IAAAhzB,EAAA,CACAxC,KAAAotC,GAAAgI,GACAn+B,cAAA,GAEA,OAAAhG,EAAAsZ,QAAA/nB,GAAA8I,KAAA,SAAA8D,GACA,IAAAimC,EAAA,GACAjmC,EAAA+iB,KAAAhuB,QAAA,SAAAmlB,GACA,IAAAgsB,EAAAhsB,EAAA7jB,IAAAqK,UAAA,GACAslC,EAAAhvC,IAAAkjB,EAAA7jB,KAAAtB,QAAA,SAAAqxB,GACA,IAAA8Y,EAAAgH,EAAA,IAAA9f,EAEAuH,EAAApH,MAAA2Y,KAGAA,EAAA9Y,GAEA,IAAA+f,EAAA13C,OAAAmC,KAAA+8B,EAAApH,MAAA2Y,IAEAkH,EAAAlsB,EAAAxS,KAAAwS,EAAAxS,IAAA6e,OACArM,EAAAxS,IAAA6e,MAAAH,GACA+f,EAAApxC,QAAA,SAAAsxC,GACAJ,EAAAI,GACAJ,EAAAI,IAAAD,QAIA,IAEAE,EAFA73C,OAAAmC,KAAAq1C,GAAA5iC,OACA,SAAAgjC,GAAiC,OAAAJ,EAAAI,KACjC7vC,IAAA,SAAA6vC,GACA,OAAA1I,GAAA+E,EAAA2D,GAAA,WACA,WAAAxkC,EAAA5S,YAAAo3C,EAAAxkC,EAAAiT,QAAA9G,WADA2vB,KAIA,OAAAriC,QAAA6e,IAAAmsB,GAAApqC,KAAA,WACA,OAAkByF,IAAA,QAGb+/B,EAAA,CAAc//B,IAAA,KAwGnB4kC,CAAA1kC,IA9nCSrF,IAAY,SAAA/K,GACrB,IAAAoJ,EAAApJ,EAAAgF,MACA4E,EAAA0D,EAAAtM,MAAAC,KAAAjB,GAIA,MAHA,mBAAAoJ,GACA6iC,GAAAriC,EAAAR,GAEAQ,MA0sCAmrC,CADA,UA9BA,SAAAlgB,EAAAxmB,GAEA,sBAAAwmB,GAAA,IAAAA,EAAAx1B,OAAA,CACA,IAAA21C,EAAAngB,EACA,gBAAA5e,GACA,OAAA++B,EAAA/+B,EAAA5H,IAGA,OAAAu+B,GAAA/X,EAAAl2B,WAAA0P,IAIA,SAAA2+B,GACA,IAAAiI,EAAAjI,EAAAruC,WACAu2C,EA1BA,SAAAD,GACA,WAAAzuC,KAAAyuC,GACA,OAAAhH,GAAAC,KACG,aAAA1nC,KAAAyuC,GACH,OAAAhH,GAAAE,OACG,aAAA3nC,KAAAyuC,GACH,OAAAhH,GAAAG,OACG,QAAA5nC,KAAAyuC,GACH,UAAA7zC,MAAA6zC,EAAA,wCAkBAE,CAAAF,GACA,OAAAC,GAGAtI,GAAAqI,IAIA,SAAArgB,EAAAD,GACA,IAAArnB,EAAAsnB,EAAAE,OAAAF,EAAAE,MAAAH,GACA,oBAAArnB,EAAAvI,IACA,UAAAgnC,GAAA,QAAAnX,EAAAnc,IAAA,6BACAkc,EAAA,0CAAArnB,EAAAvI,OAeA,IAAAqwC,GAAA,CACAt/B,MATA,SAAAxI,EAAA3L,EAAAkM,GACA,OAAA0gC,GAAAz4B,MAAA7R,KAAAhD,KAAAqM,EAAA3L,EAAAkM,IASAsmC,YANA,SAAAtmC,GACA,OAAA0gC,GAAA4F,YAAAlwC,KAAAhD,KAAA4M,KAQA,SAAAwnC,GAAA1jC,GACA,YAAAnL,KAAAmL,GASA,SAAA2jC,GAAAllC,EAAA6F,GACA,IAAA+zB,EAAAhtC,OAAAmC,KAAA8W,EAAAM,cACA,OAAA1M,QAAA6e,IAAAshB,EAAAjlC,IAAA,SAAA25B,GACA,OAAAtuB,EAAAqZ,cAAAxT,EAAAwC,IAAAimB,EAAA,CAAgD/sB,IAAAsE,EAAAqC,UAuDhD,SAAAi9B,GAAAC,EAAAxpC,EAAAypC,EAAAC,GACAD,EAAA5oC,EAAA4oC,GAEA,IAAAE,EAAA,GACAzlC,GAAA,EA2DA,SAAA0lC,EAAAn4B,GAGA,OAAA+3B,EAAA9rB,QAAA,CACAvqB,KAAAse,EACArH,cAAA,EACAsI,WAAA,IACKjU,KAAA,SAAA8D,GACL,GAAAmnC,EAAAhiC,UACA,UAAAtS,MAAA,aAEAmN,EAAA+iB,KAAAhuB,QAAA,SAAAmlB,GAnBA,IAAAxS,EAoBAwS,EAAA7K,UAAA6K,EAAAxS,MAAAo/B,GAAA5sB,EAAAhrB,MAAAkU,OApBAsE,EAqBAwS,EAAAxS,IApBAA,EAAAM,cAAAvZ,OAAAmC,KAAA8W,EAAAM,cAAAlX,OAAA,IAGA,SAAA4W,GACA,OAAAA,EAAAyM,YAAAzM,EAAAyM,WAAArjB,OAAA,EAgBAw2C,CAAAptB,EAAAxS,OAOAwS,EAAAxS,IAAAyM,mBACA+F,EAAAxS,IAAAyM,WAIAizB,EAAA91C,KAAA4oB,EAAAxS,YACAw/B,EAAAhtB,EAAAhY,SAqBA,OAAA5G,QAAAC,UACAW,KAjBA,WAGA,IAAAgT,EAAAzgB,OAAAmC,KAAAs2C,GAAA7jC,OAAA,SAAAnB,GACA,IAAAoW,EAAA4uB,EAAAhlC,GAAAoW,QACA,WAAAA,EAAAxnB,QAAAg2C,GAAAxuB,EAAA,MAEA,GAAApJ,EAAApe,OAAA,EACA,OAAAu2C,EAAAn4B,KAUAhT,KA1GA,WAEA,IAAAqrC,EAjCA,SAAAL,GACA,IAAAplC,EAAA,GAWA,OAVArT,OAAAmC,KAAAs2C,GAAAnyC,QAAA,SAAAmN,GACAglC,EAAAhlC,GAAAoW,QACAvjB,QAAA,SAAAyyC,GACA1lC,EAAAxQ,KAAA,CACA4Q,KACAkB,IAAAokC,QAKA,CACAzlC,KAAAD,EACAyN,MAAA,EACA+K,QAAA,GAkBAmtB,CAAAP,GAEA,GAAAK,EAAAxlC,KAAAjR,OAIA,OAAAm2C,EAAArlC,QAAA2lC,GAAArrC,KAAA,SAAAwrC,GAEA,GAAAP,EAAAhiC,UACA,UAAAtS,MAAA,aAEA,OAAAyI,QAAA6e,IAAAutB,EAAAnlC,QAAA/L,IAAA,SAAAmxC,GACA,OAAArsC,QAAA6e,IAAAwtB,EAAA5lC,KAAAvL,IAAA,SAAAkR,GACA,IAAAkgC,EAAAlgC,EAAA/F,GAQA,OANA+F,EAAAzU,QAGA0O,GAAA,GAGAimC,KAAA5/B,aAhFA,SAAAvK,EAAAwpC,EAAAv/B,GACA,IAAAmgC,EAAAx/B,GAAA4+B,KAAA5+B,GAAA5K,GACAg+B,EAAAhtC,OAAAmC,KAAA8W,EAAAM,cAEA,OAAA6/B,EAIApqC,EAAAzG,IAAA0Q,EAAAwC,KAAAhO,KAAA,SAAA4gB,GACA,OAAAxhB,QAAA6e,IAAAshB,EAAAjlC,IAAA,SAAA25B,GACA,OAvBA,SAAArT,EAAA8qB,EAAAzX,GACA,OAAArT,EAAA9U,eACA8U,EAAA9U,aAAAmoB,IACArT,EAAA9U,aAAAmoB,GAAAvI,SAAAggB,EAAA5/B,aAAAmoB,GAAAvI,OAoBAkgB,CAAAhrB,EAAApV,EAAAyoB,GACA8W,EAAA/rB,cAAAxT,EAAAwC,IAAAimB,GAGA1yB,EAAAyd,cAAA4B,EAAA5S,IAAAimB,QAEGvW,MAAA,SAAA3mB,GAEH,SAAAA,EAAAuR,OACA,MAAAvR,EAGA,OAAA8zC,GAAAE,EAAAv/B,KAjBAq/B,GAAAE,EAAAv/B,GA+EAqgC,CAAAtqC,EAAAwpC,EAAAW,GACA1rC,KAAA,SAAA4L,GACA,IAAA2zB,EAAAhtC,OAAAmC,KAAAg3C,EAAA5/B,cASA,OARAF,EACA/S,QAAA,SAAA4gC,EAAA3lC,GACA,IAAA+X,EAAA6/B,EAAA5/B,aAAAyzB,EAAAzrC,WACA+X,EAAAE,YACAF,EAAAjX,OACAiX,EAAAZ,KAAAwuB,IAGAiS,IAdAA,QAmBA1rC,KAAA,SAAAqG,GACA6kC,IAAAlnC,OAAAgI,GAAA3F,GAAAc,OAAA2kC,gBA+DA9rC,KAPA,WACA,OAAYyF,KAAAI,KAAAqlC,KASZ,IAAAa,GAAA,EACAC,GAAA,UAQAC,GAAA,EACAC,GAAA,EAEA,SAAAC,GAAAxmC,EAAAK,EAAAomC,EAAAC,EAAAC,GACA,OAAA3mC,EAAA7K,IAAAkL,GAAA0X,MAAA,SAAAne,GACA,SAAAA,EAAA+I,OAMA,MALA,SAAA3C,EAAAqT,SAAA,UAAArT,EAAAqT,SACA3Q,EACA,+DAGA,CACAkkC,WAAAF,EACAr+B,IAAAhI,EACAqO,QAAA,GACAm4B,WAAAR,GACAvhB,QAAAshB,IAGA,MAAAxsC,IACGS,KAAA,SAAAwL,GACH,IAAA8gC,EAAArjC,WAKAuC,EAAAmS,WAAAyuB,EA0BA,OArBA5gC,EAAA6I,SAAA7I,EAAA6I,SAAA,IAAAlN,OAAA,SAAAqN,GACA,OAAAA,EAAA+3B,aAAAF,IAIA7gC,EAAA6I,QAAAo4B,QAAA,CACA9uB,SAAAyuB,EACAG,WAAAF,IAMA7gC,EAAA6I,QAAA7I,EAAA6I,QAAA/S,MAAA,EAAA2qC,IAEAzgC,EAAAif,QAAAshB,GACAvgC,EAAAghC,WAAAR,GAEAxgC,EAAA+gC,WAAAF,EACA7gC,EAAAmS,SAAAyuB,EAEAzmC,EAAAsI,IAAAzC,GAAAkS,MAAA,SAAAne,GACA,SAAAA,EAAA+I,OAEA,OAAA6jC,GAAAxmC,EAAAK,EAAAomC,EAAAC,EAAAC,GAEA,MAAA/sC,MAKA,SAAAmtC,GAAA3B,EAAAxpC,EAAAyE,EAAAsmC,EAAAp1C,GACAV,KAAAu0C,MACAv0C,KAAA+K,SACA/K,KAAAwP,KACAxP,KAAA81C,cACA91C,KAAAU,QAAA,GAGAw1C,GAAA55C,UAAA65C,gBAAA,SAAAP,EAAAC,GACA,IAAAtsC,EAAAvJ,KACA,OAAAA,KAAAo2C,aAAAR,EAAAC,GAAArsC,KAAA,WACA,OAAAD,EAAA8sC,aAAAT,EAAAC,MAIAK,GAAA55C,UAAA85C,aAAA,SAAAR,EAAAC,GACA,OAAA71C,KAAAU,KAAA41C,sBACAX,GAAA31C,KAAA+K,OAAA/K,KAAAwP,GAAAomC,EACAC,EAAA71C,KAAA81C,aAEAltC,QAAAC,SAAA,IAIAqtC,GAAA55C,UAAA+5C,aAAA,SAAAT,EAAAC,GACA,GAAA71C,KAAAU,KAAA61C,sBAAA,CACA,IAAAhtC,EAAAvJ,KACA,OAAA21C,GAAA31C,KAAAu0C,IAAAv0C,KAAAwP,GAAAomC,EACAC,EAAA71C,KAAA81C,aACA5uB,MAAA,SAAAne,GACA,GAAAytC,GAAAztC,GAEA,OADAQ,EAAA7I,KAAA61C,uBAAA,GACA,EAEA,MAAAxtC,IAGA,OAAAH,QAAAC,SAAA,IAIA,IAAA4tC,GAAA,CACAhwC,UAAA,SAAAiwC,EAAAC,GAEA,WAAAlpB,GAAAipB,EAAAvvB,SAAAwvB,EAAAxvB,UACAwvB,EAAAxvB,SAGA,GAEAyvB,EAAA,SAAAF,EAAAC,GAEA,OAyEA,SAAAE,EAAAC,GACA,GAAAD,EAAAd,aAAAe,EAAAf,WACA,OACA5uB,SAAA0vB,EAAA1vB,SACAtJ,QAAAg5B,EAAAh5B,SAIA,OAGA,SAAAk5B,EAAAC,EAAAC,GAGA,IAAAC,EAAAF,EAAA,GACA,IAAAG,EAAAH,EAAAlsC,MAAA,GACA,IAAAssC,EAAAH,EAAA,GACA,IAAAI,EAAAJ,EAAAnsC,MAAA,GAEA,IAAAosC,GAAA,IAAAD,EAAA74C,OACA,OACA+oB,SAAAuuB,GACA73B,QAAA,IAIA,IAAAy5B,EAAAJ,EAAAnB,WAEA,GAAAwB,GAAAD,EAAAL,GACA,OACA9vB,SAAA+vB,EAAA/vB,SACAtJ,QAAAm5B,GAIA,IAAAphB,EAAAwhB,EAAArB,WACA,GAAAwB,GAAA3hB,EAAAuhB,GACA,OACAhwB,SAAAiwB,EAAAjwB,SACAtJ,QAAAw5B,GAIA,OAAAN,EAAAI,EAAAE,GAnCAN,CAAAF,EAAAh5B,QAAAi5B,EAAAj5B,SAjFA25B,CAAAb,EAAAD,GAAAvvB,WAuHA,SAAAowB,GAAAE,EAAA55B,GACA,IAAA65B,EAAA75B,EAAA,GACA85B,EAAA95B,EAAA/S,MAAA,GAEA,SAAA2sC,GAAA,IAAA55B,EAAAzf,UAIAq5C,IAAAC,EAAA3B,YAIAwB,GAAAE,EAAAE,IAGA,SAAAnB,GAAAztC,GACA,uBAAAA,EAAA+I,QAAA,IAAAvU,KAAAq6C,MAAA7uC,EAAA+I,OAAA,KAnIAokC,GAAA55C,UAAAu7C,cAAA,WACA,IAAAtuC,EAAAvJ,KAEA,OAAAuJ,EAAA7I,MAAA6I,EAAA7I,KAAA61C,wBAAAhtC,EAAA7I,KAAA41C,sBACA/sC,EAAAgrC,IAAAjwC,IAAAiF,EAAAiG,IAAAhG,KAAA,SAAAmtC,GACA,OAAAA,EAAAxvB,UAAAuuB,KACKxuB,MAAA,SAAAne,GAEL,SAAAA,EAAA+I,OACA,MAAA/I,EAEA,OAAA2sC,KAIAnsC,EAAAwB,OAAAzG,IAAAiF,EAAAiG,IAAAhG,KAAA,SAAAktC,GACA,OAAAntC,EAAA7I,MAAA6I,EAAA7I,KAAA41C,wBAAA/sC,EAAA7I,KAAA61C,sBACAG,EAAAvvB,UAAAuuB,GAGAnsC,EAAAgrC,IAAAjwC,IAAAiF,EAAAiG,IAAAhG,KAAA,SAAAmtC,GAIA,OAAAD,EAAAziB,UAAA0iB,EAAA1iB,QACAyhB,IAKAzhB,EADAyiB,EAAAziB,QACAyiB,EAAAziB,QAAAv2B,WAEA,eAGA+4C,GACAA,GAAAxiB,GAAAyiB,EAAAC,GAGAjB,GAXA,IAAAzhB,GAYK,SAAAlrB,GACL,SAAAA,EAAA+I,QAAA4kC,EAAAvvB,SACA,OAAA5d,EAAAgrC,IAAA98B,IAAA,CACAD,IAAAjO,EAAAiG,GACA2X,SAAAuuB,KACSlsC,KAAA,WACT,OAAAksC,IACS,SAAA3sC,GACT,OAAAytC,GAAAztC,IACAQ,EAAA7I,KAAA61C,uBAAA,EACAG,EAAAvvB,UAGAuuB,KAGA,MAAA3sC,MAEGme,MAAA,SAAAne,GACH,SAAAA,EAAA+I,OACA,MAAA/I,EAEA,OAAA2sC,MAwEA,IAAAoC,GAAA,EAwCA,SAAAC,GAAAxD,EAAAxpC,EAAArK,GACA,IAAAggC,EAAAhgC,EAAA+yB,QAAA/yB,EAAA+yB,QAAApW,KAAAoQ,IAAA,GACAqG,EAAApzB,EAAAiQ,OAAAjQ,EAAAiQ,OAAAjT,WAAA,GACAs6C,EAAA,GACAC,EAAA,GACAzrB,EAAA,GAiBA,OAZA9rB,EAAA8rB,WACAA,EAAAltB,KAAAC,UAAAmB,EAAA8rB,WAGA9rB,EAAAiQ,QAAAjQ,EAAAoU,eACAkjC,EAAA14C,KAAAC,UAxBA,SAAAy4C,GACA,OAAAj8C,OAAAmC,KAAA85C,GAAA36B,KAAAoQ,IAAAzpB,OAAA,SAAA8I,EAAAnJ,GAEA,OADAmJ,EAAAnJ,GAAAq0C,EAAAr0C,GACAmJ,GACG,IAoBHorC,CAAAx3C,EAAAoU,gBAGApU,EAAAiQ,QAAA,UAAAjQ,EAAAiQ,SACAsnC,EAAAv3C,EAAA6yB,KAAA71B,YAGAkL,QAAA6e,IAAA,CAAA8sB,EAAA/kC,KAAAzE,EAAAyE,OAAAhG,KAAA,SAAA8D,GACA,IAAA6qC,EAAA7qC,EAAA,GAAAA,EAAA,GAAAwmB,EAAAmkB,EACAD,EAAAtX,EAAAlU,EACA,WAAA5jB,QAAA,SAAAC,GACA6R,GAAAy9B,EAAAtvC,OAEGW,KAAA,SAAA4uC,GAKH,iBADAA,IAAAj5C,QAAA,WAAAA,QAAA,cAKA,SAAAk5C,GAAA9D,EAAAxpC,EAAArK,EAAAo1C,EAAAhpC,GACA,IACAwrC,EAgBAC,EACAC,EAlBAC,EAAA,GAEAC,EAAA,CACAnmC,IAAA,EACAF,QAAA,GACAhD,KAAA,IAEAspC,GAAA,EACAC,GAAA,EACAC,GAAA,EACA1xB,EAAA,EACA1D,EAAA/iB,EAAA+iB,YAAA/iB,EAAAgjB,OAAA,EACAkmB,EAAAlpC,EAAAkpC,YAAA,IACAkP,EAAAp4C,EAAAo4C,eAAA,GACAC,GAAA,EACAtlB,EAAA/yB,EAAA+yB,QACAjH,EAAA9rB,EAAA8rB,SAGAwsB,EAAA,GAEAnD,EAAA/5B,KAEAhP,KAAA,CACAmC,IAAA,EACAgqC,YAAA,IAAA/1C,MAAA4I,cACAotC,UAAA,EACAC,aAAA,EACAC,mBAAA,EACAC,OAAA,IAGA,IAAAjnC,EAAA,GAGA,SAAAknC,IACA,OAAAd,EACA5vC,QAAAC,UAEAkvC,GAAAxD,EAAAxpC,EAAArK,GAAA8I,KAAA,SAAA8D,GACAirC,EAAAjrC,EAEA,IAAAisC,EAAA,GAEAA,GADA,IAAA74C,EAAAk1C,WACA,CAA0BW,uBAAA,EAAAD,uBAAA,GACnB,WAAA51C,EAAAk1C,WACP,CAA0BW,uBAAA,EAAAD,uBAAA,GACnB,WAAA51C,EAAAk1C,WACP,CAA0BW,uBAAA,EAAAD,uBAAA,GAE1B,CAA0BC,uBAAA,EAAAD,uBAAA,GAG1BkC,EAAA,IAAAtC,GAAA3B,EAAAxpC,EAAAwtC,EAAAzC,EAAAyD,KAIA,SAAAC,IAGA,GAFAR,EAAA,GAEA,IAAAV,EAAAjpC,KAAAjR,OAAA,CAGA,IAAAiR,EAAAipC,EAAAjpC,KACAoqC,EAAA,CAAoB1P,QAAArpC,EAAAqpC,SACpB,OAAAh/B,EAAAoZ,SAAA,CAA4B9U,OAAAuV,WAAA,GAA6B60B,GAAAjwC,KAAA,SAAA8D,GAEzD,GAAAwoC,EAAArjC,UAEA,MADAinC,IACA,IAAAv5C,MAAA,aAKA,IAAAw5C,EAAA59C,OAAAC,OAAA,MACAsR,EAAAjL,QAAA,SAAAiL,GACAA,EAAA/M,QACAo5C,EAAArsC,EAAAkC,IAAAlC,KAIA,IAAAssC,EAAA79C,OAAAmC,KAAAy7C,GAAAv7C,OACA0O,EAAAssC,oBAAAQ,EACA9sC,EAAAqsC,cAAA9pC,EAAAjR,OAAAw7C,EAEAvqC,EAAAhN,QAAA,SAAA2S,GACA,IAAAzU,EAAAo5C,EAAA3kC,EAAAwC,KACA,GAAAjX,EAAA,CACAuM,EAAAusC,OAAAz6C,KAAA2B,GAEA,IAAAs5C,GAAAt5C,EAAAsC,MAAA,IAAAgZ,cACA,oBAAAg+B,GAAA,cAAAA,EAGA,MAAAt5C,EAFAu1C,EAAA1oC,KAAA,SAAAxB,EAAArL,SAKAy4C,EAAAp6C,KAAAoW,MAIK,SAAAjM,GAEL,MADA+D,EAAAssC,oBAAA/pC,EAAAjR,OACA2K,KAIA,SAAA+wC,IACA,GAAAxB,EAAA/3C,MACA,UAAAJ,MAAA,qCAEA2M,EAAAqa,WAAAmxB,EAAA/lC,IACA,IAAAwnC,EAAAnuC,EAAAkB,GAYA,OAXAksC,EAAA56C,SACA27C,EAAA1qC,KAAA2pC,EAGA,iBAAAV,EAAAp3B,UACA64B,EAAA74B,QAAAo3B,EAAAp3B,eACAo3B,EAAAp3B,SAEA40B,EAAA1oC,KAAA,SAAA2sC,IAEApB,GAAA,EACAH,EAAArC,gBAAAmC,EAAA/lC,IACAsjC,GAAArsC,KAAA,WAGA,GAFAmvC,GAAA,EAEA7C,EAAArjC,UAEA,MADAinC,IACA,IAAAv5C,MAAA,aAEAm4C,OAAA7xC,EACAuzC,MACK9yB,MAAA,SAAAne,GAEL,MADAkxC,EAAAlxC,GACAA,IA2BA,SAAAmxC,IACA,OAAA5F,GAAAC,EAAAxpC,EAAAutC,EAAA9D,MAAAsB,GAAAtsC,KAAA,SAAA2wC,GACA7B,EAAA/3C,OAAA45C,EAAAlrC,GACAkrC,EAAA9qC,KAAAhN,QAAA,SAAA2S,UACAsjC,EAAA9D,MAAAx/B,EAAAwC,KACA1K,EAAAosC,YACAZ,EAAAjpC,KAAAzQ,KAAAoW,OAKA,SAAAolC,IAlCA,IACA16B,EAkCAo2B,EAAArjC,WAAA6lC,IAGA,IAAAG,EAAAr6C,QAIAk6C,EAAAG,EAAApxB,SAzCA3H,EAAA,GACA44B,EAAAjmC,QAAAhQ,QAAA,SAAA0S,GAGA,WAAAA,EAAAvF,KAGAkQ,EAAA3K,EAAAvF,IAAAuF,EAAA1C,QAAAvO,IAAA,SAAA1E,GACA,OAAAA,EAAAsR,SAGA3F,EAAA2a,SAAAhG,GAAAlW,KAAA,SAAAgrC,GAEA,GAAAsB,EAAArjC,UAEA,MADAinC,IACA,IAAAv5C,MAAA,aAGAm4C,EAAA9D,WAyBAhrC,KAAA0wC,GACA1wC,KAAAgwC,GACAhwC,KAAAswC,GACAtwC,KAAA4wC,GACAlzB,MAAA,SAAAne,GACAsxC,EAAA,yCAAAtxC,MAVAuxC,GAAA,IAeA,SAAAA,EAAAC,GACA,IAAA7B,EAAArmC,QAAAjU,QAaAm8C,GACA3B,GACAF,EAAArmC,QAAAjU,QAAAwrC,KAEA6O,EAAA75C,KAAA85C,GACAA,EAAA,CACAnmC,IAAA,EACAF,QAAA,GACAhD,KAAA,IAEA,YAAAymC,EAAArB,OAAA,YAAAqB,EAAArB,QACAqB,EAAArB,MAAA,SACAqB,EAAA1oC,KAAA,WAEAgtC,KA1BA,IAAA3B,EAAAr6C,QAAAk6C,KACA70B,GAAArR,EAAAsR,MAAAk1B,KACA9C,EAAArB,MAAA,UACAqB,EAAA1oC,KAAA,WAEAwrC,GACAc,KAyBA,SAAAW,EAAAnyC,EAAAa,GACA8vC,IAGA9vC,EAAAsK,UACAtK,EAAAsK,QAAAnL,GAEA4E,EAAAmC,IAAA,EACAnC,EAAAgF,OAAA,WACA2mC,EAAA,GACAC,EAAA,CACAnmC,IAAA,EACAF,QAAA,GACAhD,KAAA,IAEAqqC,EAAA3wC,IAIA,SAAA2wC,EAAAc,GACA,KAAA3B,GAIA/C,EAAArjC,YACA3F,EAAAgF,OAAA,YACA6mC,IASA,GALA7rC,EAAAgF,OAAAhF,EAAAgF,QAAA,WACAhF,EAAA2tC,UAAA,IAAAv3C,MAAA4I,cACAgB,EAAAqa,WACA0xB,GAAA,EAEA2B,EAAA,EAEAA,EAAAnmC,GAAAmmC,IACA1tC,SAGA,IAAA+sC,GAAAW,EAAA33C,MAAA,IAAAgZ,cACA,iBAAAg+B,GAAA,cAAAA,GACA/D,EAAA1oC,KAAA,QAAAotC,GACA1E,EAAA/0B,sBA3VA,SAAArgB,EAAAo1C,EAAAv1C,EAAAqM,GACA,QAAAlM,EAAAg6C,MAGA,OAFA5E,EAAA1oC,KAAA,QAAA7M,QACAu1C,EAAA/0B,qBAQA,GAJA,mBAAArgB,EAAAi6C,oBACAj6C,EAAAi6C,kBAAAnpC,GAEAskC,EAAA1oC,KAAA,eAAA7M,GACA,WAAAu1C,EAAArB,OAAA,YAAAqB,EAAArB,MAAA,CACAqB,EAAA1oC,KAAA,SAAA7M,GACAu1C,EAAArB,MAAA,UACA,IAAAmG,EAAA,WACAl6C,EAAAm6C,iBAAA/C,IAKAhC,EAAA1pC,KAAA,SAHA,WACA0pC,EAAAnjC,eAAA,SAAAioC,KAGA9E,EAAA1pC,KAAA,SAAAwuC,GAGAl6C,EAAAm6C,iBAAAn6C,EAAAm6C,kBAAA/C,GACAp3C,EAAAm6C,iBAAAn6C,EAAAi6C,kBAAAj6C,EAAAm6C,kBACA5gC,WAAArN,EAAAlM,EAAAm6C,kBAmUAC,CAAAp6C,EAAAo1C,EAAA0E,EAAA,WACAnC,GAAA9D,EAAAxpC,EAAArK,EAAAo1C,UAIAA,EAAA1oC,KAAA,WAAAN,GACAgpC,EAAA/0B,qBAKA,SAAArO,EAAAqC,EAAAmM,EAAAC,GAEA,GAAA20B,EAAArjC,UACA,OAAAinC,IAIA,iBAAAx4B,IACAw3B,EAAAx3B,WAGAxM,GAAAhU,EAAAgU,CAAAK,KAIA2jC,EAAAnmC,IAAAwC,EAAAxC,KAAA4O,EACAu3B,EAAArmC,QAAAzT,KAAAmW,GACI/K,IAAQ,WACZswC,EAAA,IAAA7B,EAAAr6C,QAAAgU,EAAAsR,SAKA,SAAAq3B,EAAA1oC,GAGA,GAFA0mC,GAAA,EAEAjD,EAAArjC,UACA,OAAAinC,IAKA,GAAArnC,EAAAxC,QAAAzR,OAAA,EACAgU,EAAAI,MAAAH,EAAAxC,QAAAwC,EAAAxC,QAAAzR,OAAA,GAAAmU,IACAynC,IACAM,GAAA,OACK,CAEL,IAAA15B,EAAA,WACA6C,GACArR,EAAAsR,MAAA,EACAs2B,KAEApB,GAAA,EAEA0B,GAAA,IAIAhC,GAAA,IAAAjmC,EAAAxC,QAAAzR,OAUAwiB,KATA+3B,GAAA,EACAH,EAAArC,gBAAA9jC,EAAA8U,SACA0uB,GAAArsC,KAAA,WACAmvC,GAAA,EACA7rC,EAAAqa,WAAA9U,EAAA8U,SACAvG,MAEAsG,MAAA+yB,KAQA,SAAAe,EAAAjyC,GAGA,GAFAgwC,GAAA,EAEAjD,EAAArjC,UACA,OAAAinC,IAEAW,EAAA,mBAAAtxC,GAIA,SAAAixC,IACA,IACAjB,IACAH,GACAH,EAAAr6C,OAAA06C,EAHA,CAOAC,GAAA,EAQAjD,EAAA9xB,WACA8xB,EAAAnjC,eAAA,SAAAmjC,EAAAmF,eACAnF,EAAA9xB,SAAA/C,UAEA60B,EAAA1pC,KAAA,SAAA8uC,GAEA,IAAA7oC,EAAAkiC,EAAAliC,QAAAD,GACAD,GAAA,SAAAO,GACAL,EAAA7I,KAAAmJ,KACAN,EAAA7I,KAAAuxC,GACA7zB,MAAA8zB,GAEAt6C,EAAAg6C,QAEA5E,EAAA9xB,SAAA3R,EACAyjC,EAAAmF,cAAAC,GAtBA,SAAAA,IACA7oC,EAAA4O,SAEA,SAAAtO,IACAmjC,EAAAnjC,eAAA,SAAAuoC,IAuBA,SAAAC,IACA7B,IAAA9vC,KAAA,WAEA,IAAAssC,EAAArjC,UAIA,OAAA+lC,EAAAX,gBAAAruC,KAAA,SAAAosC,GAEAxjC,EAAA,CACAI,MAFA2U,EAAAyuB,EAGA9xB,MAAA8lB,EACAA,aACAnoC,MAAA,WACAgyB,UACAjH,WACAlF,aAAA,GAEA5mB,EAAAiQ,SACA,iBAAAjQ,EAAAiQ,OAEAyB,EAAA+C,cAAA,EAEA/C,EAAAzB,OAAAjQ,EAAAiQ,QAGA,cAAAjQ,IACA0R,EAAAy3B,UAAAnpC,EAAAmpC,WAEA,YAAAnpC,IACA0R,EAAA23B,QAAArpC,EAAAqpC,SAEArpC,EAAAoU,eACA1C,EAAA0C,aAAApU,EAAAoU,cAEApU,EAAA6yB,OACAnhB,EAAAmhB,KAAA7yB,EAAA6yB,MAEAymB,MAlCAN,MAoCKxyB,MAAA,SAAAne,GACLsxC,EAAA,+BAAAtxC,KAKA,SAAAkxC,EAAAlxC,GACA4vC,GAAA,EACA0B,EAAA,uCAAAtxC,GA1ZA+sC,EAAAzyB,MAAAkxB,EAAAxpC,GA8ZA+qC,EAAArjC,UACAinC,KAIA5D,EAAAsF,kBACAtF,EAAA1pC,KAAA,SAAAstC,GAEA,mBAAAh5C,EAAAkgB,WACAk1B,EAAA1pC,KAAA,QAAA1L,EAAAkgB,UACAk1B,EAAA1pC,KAAA,oBAAAU,GACApM,EAAAkgB,SAAA,KAAA9T,MAGAgpC,EAAAsF,iBAAA,QAGA,IAAA16C,EAAA8R,MACA2oC,IAEA7B,IAAA9vC,KAAA,WAEA,OADAmvC,GAAA,EACAH,EAAArC,gBAAAz1C,EAAA8R,MAAAqjC,KACKrsC,KAAA,WACLmvC,GAAA,EAEA7C,EAAArjC,UACAinC,KAGAvyB,EAAAzmB,EAAA8R,MACA2oC,OACKj0B,MAAA+yB,IAOL,SAAAoB,KACEpxC,EAAA,aAAYjH,KAAAhD,MACdA,KAAAyS,WAAA,EACAzS,KAAAy0C,MAAA,UACA,IAAAlrC,EAAAvJ,KACA2I,EAAA,IAAAC,QAAA,SAAA8D,EAAA5D,GACAS,EAAA6C,KAAA,WAAAM,GACAnD,EAAA6C,KAAA,QAAAtD,KAEAS,EAAAC,KAAA,SAAAX,EAAAC,GACA,OAAAH,EAAAa,KAAAX,EAAAC,IAEAS,EAAA2d,MAAA,SAAApe,GACA,OAAAH,EAAAue,MAAApe,IAIAS,EAAA2d,MAAA,cA4BA,SAAAo0B,GAAAnsC,EAAAzO,GACA,IAAA66C,EAAA76C,EAAA66C,iBACA,uBAAApsC,EACA,IAAAosC,EAAApsC,EAAAzO,GAEAyO,EAIA,SAAAqsC,GAAAjH,EAAAxpC,EAAArK,EAAAkM,GAUA,GARA,mBAAAlM,IACAkM,EAAAlM,EACAA,EAAA,SAEA,IAAAA,IACAA,EAAA,IAGAA,EAAA+yB,UAAAr2B,MAAAkG,QAAA5C,EAAA+yB,SACA,MAAApf,GAAAL,EACA,6CAGAtT,EAAAkgB,SAAAhU,GACAlM,EAAAkL,EAAAlL,IACA+iB,WAAA/iB,EAAA+iB,YAAA/iB,EAAAgjB,KACAhjB,EAAAg6C,MAAA,UAAAh6C,KAAAg6C,MAEAh6C,EAAA66C,iBAAA76C,EAAA66C,kBAAAv7C,KACA,IAAAy7C,EAAA,IAAAJ,GAAA36C,GAIA,OADA23C,GAFAiD,GAAA/G,EAAA7zC,GACA46C,GAAAvwC,EAAArK,GACAA,EAAA+6C,GACAA,EAIA,SAAAC,GAAAnH,EAAAxpC,EAAArK,EAAAkM,GAaA,MAZA,mBAAAlM,IACAkM,EAAAlM,EACAA,EAAA,SAEA,IAAAA,IACAA,EAAA,KAEAA,EAAAkL,EAAAlL,IAEA66C,iBAAA76C,EAAA66C,kBAAAv7C,KAGA,IAAA27C,GAFApH,EAAA+G,GAAA/G,EAAA7zC,GACAqK,EAAAuwC,GAAAvwC,EAAArK,GACAA,EAAAkM,GAGA,SAAA+uC,GAAApH,EAAAxpC,EAAArK,EAAAkM,GACA,IAAArD,EAAAvJ,KACAA,KAAA47C,UAAA,EAEA,IAAAC,EAAAn7C,EAAA9B,KAAAkU,EAAA,GAAqDpS,IAAA9B,MAAA8B,EACrDo7C,EAAAp7C,EAAAq7C,KAAAjpC,EAAA,GAAqDpS,IAAAq7C,MAAAr7C,EAQrD,SAAAs7C,EAAAjnC,GACAxL,EAAA6D,KAAA,UACA6uC,UAAA,OACAlnC,WAGA,SAAAmnC,EAAAnnC,GACAxL,EAAA6D,KAAA,UACA6uC,UAAA,OACAlnC,WAGA,SAAAonC,EAAAnnC,GACAzL,EAAA6D,KAAA,UACA6uC,UAAA,OACAjnC,QAGA,SAAAonC,EAAApnC,GACAzL,EAAA6D,KAAA,UACA6uC,UAAA,OACAjnC,QAGA,SAAAqnC,IACA9yC,EAAA8yC,YAAA,EAEA9yC,EAAA+yC,YACA/yC,EAAA6D,KAAA,UAGA,SAAAkvC,IACA/yC,EAAA+yC,YAAA,EAEA/yC,EAAA8yC,YACA9yC,EAAA6D,KAAA,UAGA,SAAAmvC,IACAhzC,EAAA8yC,YAAA,EAEA9yC,EAAA+yC,YACA/yC,EAAA6D,KAAA,UACA6uC,UAAA,SAIA,SAAAO,IACAjzC,EAAA+yC,YAAA,EAEA/yC,EAAA8yC,YACA9yC,EAAA6D,KAAA,UACA6uC,UAAA,SA1DAj8C,KAAApB,KAAA48C,GAAAjH,EAAAxpC,EAAA8wC,GACA77C,KAAA+7C,KAAAP,GAAAzwC,EAAAwpC,EAAAuH,GAEA97C,KAAAq8C,YAAA,EACAr8C,KAAAs8C,YAAA,EA2DA,IAAAG,EAAA,GAEA,SAAAC,EAAArxC,GACA,gBAAA2uB,EAAAxtB,IACA,WAAAwtB,IACAxtB,IAAAwvC,GAAAxvC,IAAA0vC,IACA,WAAAliB,IACAxtB,IAAA4vC,GAAA5vC,IAAA2vC,IACA,WAAAniB,IACAxtB,IAAA8vC,GAAA9vC,IAAA6vC,IACA,WAAAriB,IACAxtB,IAAAgwC,GAAAhwC,IAAA+vC,MAGAviB,KAAAyiB,IACAA,EAAAziB,GAAA,IAEAyiB,EAAAziB,GAAA3uB,IAAA,EACA,IAAAtP,OAAAmC,KAAAu+C,EAAAziB,IAAA57B,QAEAmL,EAAAwX,mBAAAiZ,KAWA,SAAA2iB,EAAA97B,EAAAmZ,EAAA4iB,IACA,GAAA/7B,EAAA3T,UAAA8sB,GAAAr3B,QAAAi6C,IACA/7B,EAAA1O,GAAA6nB,EAAA4iB,GAPAl8C,EAAAgjB,OACA1jB,KAAApB,KAAAuT,GAAA,WAAA5I,EAAAwyC,KAAA96B,OAAAlkB,KAAAwM,EAAAwyC,OACA/7C,KAAA+7C,KAAA5pC,GAAA,WAAA5I,EAAA3K,KAAAqiB,OAAAlkB,KAAAwM,EAAA3K,QASAoB,KAAAmS,GAAA,uBAAA6nB,GACA,WAAAA,GACA2iB,EAAApzC,EAAAwyC,KAAA,SAAAC,GACAW,EAAApzC,EAAA3K,KAAA,SAAAs9C,IACK,WAAAliB,GACL2iB,EAAApzC,EAAAwyC,KAAA,SAAAK,GACAO,EAAApzC,EAAA3K,KAAA,SAAAu9C,IACK,WAAAniB,GACL2iB,EAAApzC,EAAAwyC,KAAA,SAAAS,GACAG,EAAApzC,EAAA3K,KAAA,SAAA29C,IACK,WAAAviB,IACL2iB,EAAApzC,EAAAwyC,KAAA,SAAAO,GACAK,EAAApzC,EAAA3K,KAAA,SAAAy9C,MAIAr8C,KAAAmS,GAAA,0BAAA6nB,GACA,WAAAA,GACAzwB,EAAAwyC,KAAAppC,eAAA,SAAAqpC,GACAzyC,EAAA3K,KAAA+T,eAAA,SAAAupC,IACK,WAAAliB,GACLzwB,EAAAwyC,KAAAppC,eAAA,SAAAypC,GACA7yC,EAAA3K,KAAA+T,eAAA,SAAAwpC,IACK,WAAAniB,GACLzwB,EAAAwyC,KAAAppC,eAAA,SAAA6pC,GACAjzC,EAAA3K,KAAA+T,eAAA,SAAA4pC,IACK,WAAAviB,IACLzwB,EAAAwyC,KAAAppC,eAAA,SAAA2pC,GACA/yC,EAAA3K,KAAA+T,eAAA,SAAA0pC,MAIAr8C,KAAA+7C,KAAA5pC,GAAA,iBAAAuqC,EAAA,SACA18C,KAAApB,KAAAuT,GAAA,iBAAAuqC,EAAA,SAEA,IAAA/zC,EAAAC,QAAA6e,IAAA,CACAznB,KAAApB,KACAoB,KAAA+7C,OACAvyC,KAAA,SAAAmD,GACA,IAAAkwC,EAAA,CACAj+C,KAAA+N,EAAA,GACAovC,KAAApvC,EAAA,IAOA,OALApD,EAAA6D,KAAA,WAAAyvC,GACAjwC,GACAA,EAAA,KAAAiwC,GAEAtzC,EAAAwX,qBACA87B,GACG,SAAA9zC,GAaH,GAZAQ,EAAA0X,SACArU,EAGAA,EAAA7D,GAKAQ,EAAA6D,KAAA,QAAArE,GAEAQ,EAAAwX,qBACAnU,EAEA,MAAA7D,IAIA/I,KAAAwJ,KAAA,SAAAszC,EAAA/zC,GACA,OAAAJ,EAAAa,KAAAszC,EAAA/zC,IAGA/I,KAAAknB,MAAA,SAAAne,GACA,OAAAJ,EAAAue,MAAAne,IAxRAoB,IAAQkxC,GAAcpxC,EAAA,cAqBtBoxC,GAAA/+C,UAAA2kB,OAAA,WACAjhB,KAAAyS,WAAA,EACAzS,KAAAy0C,MAAA,YACAz0C,KAAAoN,KAAA,WAGAiuC,GAAA/+C,UAAA+mB,MAAA,SAAAkxB,EAAAxpC,GACA,IAAAxB,EAAAvJ,KAMA,SAAAghB,IACAzX,EAAA0X,SANA1X,EAAAwzC,eAGAxzC,EAAAwzC,cAAA,EAKAxI,EAAAnoC,KAAA,YAAA4U,GACAjW,EAAAqB,KAAA,YAAA4U,GAKAzX,EAAA6C,KAAA,WAJA,WACAmoC,EAAA5hC,eAAA,YAAAqO,GACAjW,EAAA4H,eAAA,YAAAqO,OA0CA7W,IAAQwxC,GAAO1xC,EAAA,cAyMf0xC,GAAAr/C,UAAA2kB,OAAA,WACAjhB,KAAA47C,WACA57C,KAAA47C,UAAA,EACA57C,KAAApB,KAAAqiB,SACAjhB,KAAA+7C,KAAA96B,WA8BAkB,GAAAkJ,OA3pHA,SAAAlJ,GACAA,EAAAK,QAAA,MAAAkf,IAAA,KA2pHArW,OAvkFA,SAAAlJ,GACAA,EAAAK,QAAA,OAAAokB,IAAA,GACAzkB,EAAAK,QAAA,QAAAokB,IAAA,KAskFAvb,OAAA8oB,IACA9oB,OA7BA,SAAAlJ,GACAA,EAAAk2B,UAAAmD,GACAr5B,EAAAu5B,QAEA3/C,OAAAyM,eAAA2Z,EAAA7lB,UAAA,aACAgI,IAAA,WACA,IAAAiF,EAAAvJ,KAWA,YAVA,IAAAA,KAAAg9C,mBACAh9C,KAAAg9C,iBAAA,CACAv2B,KAAA,SAAAw2B,EAAAv8C,EAAAkM,GACA,OAAArD,EAAAhN,YAAA87C,UAAA4E,EAAA1zC,EAAA7I,EAAAkM,IAEAoG,GAAA,SAAAiqC,EAAAv8C,EAAAkM,GACA,OAAArD,EAAAhN,YAAA87C,UAAA9uC,EAAA0zC,EAAAv8C,EAAAkM,MAIA5M,KAAAg9C,oBAIA76B,EAAA7lB,UAAAo/C,KAAA,SAAA1pC,EAAAtR,EAAAkM,GACA,OAAA5M,KAAAzD,YAAAm/C,KAAA17C,KAAAgS,EAAAtR,EAAAkM,MAWejD,EAAA,sEC59Tf1N,EAAAC,QAEA,SAAAmQ,GACA,kBACA,IAAArN,EAAAL,UAAAP,OACA,GAAAY,EAAA,CAGA,IAFA,IAAAD,EAAA,GACAzB,GAAA,IACAA,EAAA0B,GACAD,EAAAzB,GAAAqB,UAAArB,GAEA,OAAA+O,EAAArJ,KAAAhD,KAAAjB,GAEA,OAAAsN,EAAArJ,KAAAhD,KAAA,yCCfA,SAAA4J,GACA,IAEAszC,EAyCAC,EA3CAC,EAAAxzC,EAAAyzC,kBAAAzzC,EAAA0zC,uBAKA,GAAAF,EAAA,CACA,IAAA9wC,EAAA,EACAixC,EAAA,IAAAH,EAAA3zC,GACAymB,EAAAtmB,EAAA4zC,SAAAC,eAAA,IACAF,EAAAG,QAAAxtB,EAAA,CACAytB,eAAA,IAEAT,EAAA,WACAhtB,EAAAzb,KAAAnI,MAAA,QAEG,GAAA1C,EAAAoQ,mBAAA,IAAApQ,EAAAg0C,eAOHV,EADG,aAAAtzC,GAAA,uBAAAA,EAAA4zC,SAAAK,cAAA,UACH,WAIA,IAAAC,EAAAl0C,EAAA4zC,SAAAK,cAAA,UACAC,EAAAC,mBAAA,WACAt0C,IAEAq0C,EAAAC,mBAAA,KACAD,EAAAE,WAAAC,YAAAH,GACAA,EAAA,MAEAl0C,EAAA4zC,SAAAU,gBAAAC,YAAAL,IAGA,WACA7jC,WAAAxQ,EAAA,QAvBG,CACH,IAAA20C,EAAA,IAAAx0C,EAAAg0C,eACAQ,EAAAC,MAAAC,UAAA70C,EACAyzC,EAAA,WACAkB,EAAAG,MAAAC,YAAA,IAyBA,IAAAx/B,EAAA,GAEA,SAAAvV,IAEA,IAAAnM,EAAAmhD,EADAtB,GAAA,EAGA,IADA,IAAAn+C,EAAAggB,EAAA5gB,OACAY,GAAA,CAIA,IAHAy/C,EAAAz/B,EACAA,EAAA,GACA1hB,GAAA,IACAA,EAAA0B,GACAy/C,EAAAnhD,KAEA0B,EAAAggB,EAAA5gB,OAEA++C,GAAA,EAGAlhD,EAAAC,QACA,SAAA+qB,GACA,IAAAjI,EAAApgB,KAAAqoB,IAAAk2B,GACAD,0DC3CA,IAOAwB,EAPAC,EAAA,iBAAAC,gBAAA,KACAC,EAAAF,GAAA,mBAAAA,EAAA5+C,MACA4+C,EAAA5+C,MACA,SAAAgL,EAAA+zC,EAAA//C,GACA,OAAA2M,SAAApP,UAAAyD,MAAAiD,KAAA+H,EAAA+zC,EAAA//C,IAKA2/C,EADAC,GAAA,mBAAAA,EAAAI,QACAJ,EAAAI,QACChjD,OAAAijD,sBACD,SAAAj0C,GACA,OAAAhP,OAAA0G,oBAAAsI,GACAyC,OAAAzR,OAAAijD,sBAAAj0C,KAGA,SAAAA,GACA,OAAAhP,OAAA0G,oBAAAsI,IAQA,IAAAk0C,EAAA5/C,OAAA+uB,OAAA,SAAA5xB,GACA,OAAAA,MAGA,SAAA0iD,IACAA,EAAA9Z,KAAApiC,KAAAhD,MAEA/D,EAAAC,QAAAgjD,EAGAA,iBAEAA,EAAA5iD,UAAA6iD,aAAA14C,EACAy4C,EAAA5iD,UAAA8iD,aAAA,EACAF,EAAA5iD,UAAA+iD,mBAAA54C,EAIA,IAAA64C,EAAA,GAoCA,SAAAC,EAAApU,GACA,YAAA1kC,IAAA0kC,EAAAkU,cACAH,EAAAI,oBACAnU,EAAAkU,cAmDA,SAAAG,EAAAz0C,EAAAM,EAAAuxC,EAAA6C,GACA,IAAAnpC,EACAopC,EACA73B,EAnHA83B,EAqHA,sBAAA/C,EACA,UAAAr0C,UAAA,0EAAAq0C,GAqBA,QAjBAn2C,KADAi5C,EAAA30C,EAAAo0C,UAEAO,EAAA30C,EAAAo0C,QAAApjD,OAAAC,OAAA,MACA+O,EAAAq0C,aAAA,SAIA34C,IAAAi5C,EAAAE,cACA70C,EAAAqC,KAAA,cAAA/B,EACAuxC,yBAIA8C,EAAA30C,EAAAo0C,SAEAt3B,EAAA63B,EAAAr0C,SAGA5E,IAAAohB,EAEAA,EAAA63B,EAAAr0C,GAAAuxC,IACA7xC,EAAAq0C,kBAeA,GAbA,mBAAAv3B,EAEAA,EAAA63B,EAAAr0C,GACAo0C,EAAA,CAAA7C,EAAA/0B,GAAA,CAAAA,EAAA+0B,GAEK6C,EACL53B,EAAAouB,QAAA2G,GAEA/0B,EAAAjpB,KAAAg+C,IAIAtmC,EAAAipC,EAAAx0C,IACA,GAAA8c,EAAAzpB,OAAAkY,IAAAuR,EAAA5nB,OAAA,CACA4nB,EAAA5nB,QAAA,EAGA,IAAA4/C,EAAA,IAAA1/C,MAAA,+CACA0nB,EAAAzpB,OAAA,IAAAc,OAAAmM,GAAA,qEAGAw0C,EAAAh9C,KAAA,8BACAg9C,EAAAC,QAAA/0C,EACA80C,EAAAx0C,OACAw0C,EAAAl6B,MAAAkC,EAAAzpB,OAxKAuhD,EAyKAE,EAxKAx/C,iBAAA0/C,MAAA1/C,QAAA0/C,KAAAJ,GA4KA,OAAA50C,EAwBA,SAAAi1C,EAAAj1C,EAAAM,EAAAuxC,GACA,IAAAnI,EAAA,CAAewL,OAAA,EAAAC,YAAAz5C,EAAAsE,SAAAM,OAAAuxC,YACfuD,EAZA,WAEA,IADA,IAAAphD,EAAA,GACAzB,EAAA,EAAiBA,EAAAqB,UAAAP,OAAsBd,IAAAyB,EAAAH,KAAAD,UAAArB,IACvC0C,KAAAigD,QACAjgD,KAAA+K,OAAA4H,eAAA3S,KAAAqL,KAAArL,KAAAkgD,QACAlgD,KAAAigD,OAAA,EACApB,EAAA7+C,KAAA48C,SAAA58C,KAAA+K,OAAAhM,KAMAhC,KAAA03C,GAGA,OAFA0L,EAAAvD,WACAnI,EAAAyL,OAAAC,EACAA,EAgIA,SAAA/uC,EAAArG,EAAAM,EAAA+0C,GACA,IAAAV,EAAA30C,EAAAo0C,QAEA,QAAA14C,IAAAi5C,EACA,SAEA,IAAAW,EAAAX,EAAAr0C,GACA,YAAA5E,IAAA45C,EACA,GAEA,mBAAAA,EACAD,EAAA,CAAAC,EAAAzD,UAAAyD,GAAA,CAAAA,GAEAD,EAsDA,SAAA/xC,GAEA,IADA,IAAAxM,EAAA,IAAAzE,MAAAiR,EAAAjQ,QACAd,EAAA,EAAiBA,EAAAuE,EAAAzD,SAAgBd,EACjCuE,EAAAvE,GAAA+Q,EAAA/Q,GAAAs/C,UAAAvuC,EAAA/Q,GAEA,OAAAuE,EA1DAy+C,CAAAD,GAAAE,EAAAF,IAAAjiD,QAoBA,SAAA0iB,EAAAzV,GACA,IAAAq0C,EAAA1/C,KAAAm/C,QAEA,QAAA14C,IAAAi5C,EAAA,CACA,IAAAW,EAAAX,EAAAr0C,GAEA,sBAAAg1C,EACA,SACK,QAAA55C,IAAA45C,EACL,OAAAA,EAAAjiD,OAIA,SAOA,SAAAmiD,EAAAlyC,EAAAnJ,GAEA,IADA,IAAAs7C,EAAA,IAAApjD,MAAA8H,GACA5H,EAAA,EAAiBA,EAAA4H,IAAO5H,EACxBkjD,EAAAljD,GAAA+Q,EAAA/Q,GACA,OAAAkjD,EA5WAzkD,OAAAyM,eAAA02C,EAAA,uBACAziD,YAAA,EACA6H,IAAA,WACA,OAAAg7C,GAEA/6C,IAAA,SAAAI,GACA,oBAAAA,KAAA,GAAAs6C,EAAAt6C,GACA,UAAA87C,WAAA,kGAAA97C,EAAA,KAEA26C,EAAA36C,KAIAu6C,EAAA9Z,KAAA,gBAEA3+B,IAAAzG,KAAAm/C,SACAn/C,KAAAm/C,UAAApjD,OAAAkN,eAAAjJ,MAAAm/C,UACAn/C,KAAAm/C,QAAApjD,OAAAC,OAAA,MACAgE,KAAAo/C,aAAA,GAGAp/C,KAAAq/C,cAAAr/C,KAAAq/C,oBAAA54C,GAKAy4C,EAAA5iD,UAAAokD,gBAAA,SAAAx7C,GACA,oBAAAA,KAAA,GAAA+5C,EAAA/5C,GACA,UAAAu7C,WAAA,gFAAAv7C,EAAA,KAGA,OADAlF,KAAAq/C,cAAAn6C,EACAlF,MASAk/C,EAAA5iD,UAAAqkD,gBAAA,WACA,OAAApB,EAAAv/C,OAGAk/C,EAAA5iD,UAAA8Q,KAAA,SAAA/B,GAEA,IADA,IAAAtM,EAAA,GACAzB,EAAA,EAAiBA,EAAAqB,UAAAP,OAAsBd,IAAAyB,EAAAH,KAAAD,UAAArB,IACvC,IAAAsjD,EAAA,UAAAv1C,EAEAq0C,EAAA1/C,KAAAm/C,QACA,QAAA14C,IAAAi5C,EACAkB,UAAAn6C,IAAAi5C,EAAAn/C,WACA,IAAAqgD,EACA,SAGA,GAAAA,EAAA,CACA,IAAAC,EAGA,GAFA9hD,EAAAX,OAAA,IACAyiD,EAAA9hD,EAAA,IACA8hD,aAAA1gD,MAGA,MAAA0gD,EAGA,IAAA93C,EAAA,IAAA5I,MAAA,oBAAA0gD,EAAA,KAAAA,EAAAxtC,QAAA,SAEA,MADAtK,EAAA+3C,QAAAD,EACA93C,EAGA,IAAAg4C,EAAArB,EAAAr0C,GAEA,QAAA5E,IAAAs6C,EACA,SAEA,sBAAAA,EACAlC,EAAAkC,EAAA/gD,KAAAjB,OAEA,KAAAC,EAAA+hD,EAAA3iD,OACA8O,EAAAqzC,EAAAQ,EAAA/hD,GACA,IAAA1B,EAAA,EAAmBA,EAAA0B,IAAS1B,EAC5BuhD,EAAA3xC,EAAA5P,GAAA0C,KAAAjB,GAGA,UAmEAmgD,EAAA5iD,UAAAyV,YAAA,SAAA1G,EAAAuxC,GACA,OAAA4C,EAAAx/C,KAAAqL,EAAAuxC,GAAA,IAGAsC,EAAA5iD,UAAA6V,GAAA+sC,EAAA5iD,UAAAyV,YAEAmtC,EAAA5iD,UAAA0kD,gBACA,SAAA31C,EAAAuxC,GACA,OAAA4C,EAAAx/C,KAAAqL,EAAAuxC,GAAA,IAqBAsC,EAAA5iD,UAAA8P,KAAA,SAAAf,EAAAuxC,GACA,sBAAAA,EACA,UAAAr0C,UAAA,0EAAAq0C,GAGA,OADA58C,KAAAmS,GAAA9G,EAAA20C,EAAAhgD,KAAAqL,EAAAuxC,IACA58C,MAGAk/C,EAAA5iD,UAAA2kD,oBACA,SAAA51C,EAAAuxC,GACA,sBAAAA,EACA,UAAAr0C,UAAA,0EAAAq0C,GAGA,OADA58C,KAAAghD,gBAAA31C,EAAA20C,EAAAhgD,KAAAqL,EAAAuxC,IACA58C,MAIAk/C,EAAA5iD,UAAAqW,eACA,SAAAtH,EAAAuxC,GACA,IAAAsE,EAAAxB,EAAAyB,EAAA7jD,EAAA8jD,EAEA,sBAAAxE,EACA,UAAAr0C,UAAA,0EAAAq0C,GAIA,QAAAn2C,KADAi5C,EAAA1/C,KAAAm/C,SAEA,OAAAn/C,KAGA,QAAAyG,KADAy6C,EAAAxB,EAAAr0C,IAEA,OAAArL,KAEA,GAAAkhD,IAAAtE,GAAAsE,EAAAtE,aACA,KAAA58C,KAAAo/C,aACAp/C,KAAAm/C,QAAApjD,OAAAC,OAAA,cAEA0jD,EAAAr0C,GACAq0C,EAAA/sC,gBACA3S,KAAAoN,KAAA,iBAAA/B,EAAA61C,EAAAtE,mBAEO,sBAAAsE,EAAA,CAGP,IAFAC,GAAA,EAEA7jD,EAAA4jD,EAAA9iD,OAAA,EAAiCd,GAAA,EAAQA,IACzC,GAAA4jD,EAAA5jD,KAAAs/C,GAAAsE,EAAA5jD,GAAAs/C,aAAA,CACAwE,EAAAF,EAAA5jD,GAAAs/C,SACAuE,EAAA7jD,EACA,MAIA,GAAA6jD,EAAA,EACA,OAAAnhD,KAEA,IAAAmhD,EACAD,EAAA75B,QAiIA,SAAA65B,EAAAjuC,GACA,KAAQA,EAAA,EAAAiuC,EAAA9iD,OAAyB6U,IACjCiuC,EAAAjuC,GAAAiuC,EAAAjuC,EAAA,GACAiuC,EAAAn9C,MAlIAs9C,CAAAH,EAAAC,GAGA,IAAAD,EAAA9iD,SACAshD,EAAAr0C,GAAA61C,EAAA,SAEAz6C,IAAAi5C,EAAA/sC,gBACA3S,KAAAoN,KAAA,iBAAA/B,EAAA+1C,GAAAxE,GAGA,OAAA58C,MAGAk/C,EAAA5iD,UAAAglD,IAAApC,EAAA5iD,UAAAqW,eAEAusC,EAAA5iD,UAAAykB,mBACA,SAAA1V,GACA,IAAA6B,EAAAwyC,EAAApiD,EAGA,QAAAmJ,KADAi5C,EAAA1/C,KAAAm/C,SAEA,OAAAn/C,KAGA,QAAAyG,IAAAi5C,EAAA/sC,eAUA,OATA,IAAAhU,UAAAP,QACA4B,KAAAm/C,QAAApjD,OAAAC,OAAA,MACAgE,KAAAo/C,aAAA,QACS34C,IAAAi5C,EAAAr0C,KACT,KAAArL,KAAAo/C,aACAp/C,KAAAm/C,QAAApjD,OAAAC,OAAA,aAEA0jD,EAAAr0C,IAEArL,KAIA,OAAArB,UAAAP,OAAA,CACA,IACAuF,EADAzF,EAAAnC,OAAAmC,KAAAwhD,GAEA,IAAApiD,EAAA,EAAmBA,EAAAY,EAAAE,SAAiBd,EAEpC,oBADAqG,EAAAzF,EAAAZ,KAEA0C,KAAA+gB,mBAAApd,GAKA,OAHA3D,KAAA+gB,mBAAA,kBACA/gB,KAAAm/C,QAAApjD,OAAAC,OAAA,MACAgE,KAAAo/C,aAAA,EACAp/C,KAKA,sBAFAkN,EAAAwyC,EAAAr0C,IAGArL,KAAA2S,eAAAtH,EAAA6B,QACO,QAAAzG,IAAAyG,EAEP,IAAA5P,EAAA4P,EAAA9O,OAAA,EAAsCd,GAAA,EAAQA,IAC9C0C,KAAA2S,eAAAtH,EAAA6B,EAAA5P,IAIA,OAAA0C,MAoBAk/C,EAAA5iD,UAAA4Q,UAAA,SAAA7B,GACA,OAAA+F,EAAApR,KAAAqL,GAAA,IAGA6zC,EAAA5iD,UAAAilD,aAAA,SAAAl2C,GACA,OAAA+F,EAAApR,KAAAqL,GAAA,IAGA6zC,EAAAp+B,cAAA,SAAAg/B,EAAAz0C,GACA,yBAAAy0C,EAAAh/B,cACAg/B,EAAAh/B,cAAAzV,GAEAyV,EAAA9d,KAAA88C,EAAAz0C,IAIA6zC,EAAA5iD,UAAAwkB,gBAiBAo+B,EAAA5iD,UAAAklD,WAAA,WACA,OAAAxhD,KAAAo/C,aAAA,EAAAV,EAAA1+C,KAAAm/C,SAAA,yBCtaAljD,EAAAC,QAgBC,SAAAuK,GAED,aAeA,IAGAg7C,EAAA,kEAQA,SAAAC,EAAAtiD,EAAAmvB,GACA,IAAAvT,EAAA5b,EAAA,GACA4d,EAAA5d,EAAA,GACAkT,EAAAlT,EAAA,GACA0F,EAAA1F,EAAA,GAEA4b,IAAAgC,EAAA1K,GAAA0K,EAAAlY,GAAAypB,EAAA,eAEAzpB,KADAkW,MAAA,EAAAA,IAAA,IAAAgC,EAAA,GACAA,GAAAhC,EAAA1I,GAAAic,EAAA,eAEAjc,KADAxN,MAAA,GAAAA,IAAA,IAAAkW,EAAA,GACAA,GAAAlW,EAAAkY,GAAAuR,EAAA,eAEAvR,KADA1K,MAAA,GAAAA,IAAA,IAAAxN,EAAA,GACAA,GAAAwN,EAAA0I,GAAAuT,EAAA,gBAEAvT,KADAgC,MAAA,GAAAA,IAAA,IAAA1K,EAAA,GACAA,GAAA0K,EAAAlY,GAAAypB,EAAA,eAEAzpB,KADAkW,MAAA,EAAAA,IAAA,IAAAgC,EAAA,GACAA,GAAAhC,EAAA1I,GAAAic,EAAA,gBAEAjc,KADAxN,MAAA,GAAAA,IAAA,IAAAkW,EAAA,GACAA,GAAAlW,EAAAkY,GAAAuR,EAAA,gBAEAvR,KADA1K,MAAA,GAAAA,IAAA,IAAAxN,EAAA,GACAA,GAAAwN,EAAA0I,GAAAuT,EAAA,cAEAvT,KADAgC,MAAA,GAAAA,IAAA,IAAA1K,EAAA,GACAA,GAAA0K,EAAAlY,GAAAypB,EAAA,gBAEAzpB,KADAkW,MAAA,EAAAA,IAAA,IAAAgC,EAAA,GACAA,GAAAhC,EAAA1I,GAAAic,EAAA,gBAEAjc,KADAxN,MAAA,GAAAA,IAAA,IAAAkW,EAAA,GACAA,GAAAlW,EAAAkY,GAAAuR,EAAA,YAEAvR,KADA1K,MAAA,GAAAA,IAAA,IAAAxN,EAAA,GACAA,GAAAwN,EAAA0I,GAAAuT,EAAA,iBAEAvT,KADAgC,MAAA,GAAAA,IAAA,IAAA1K,EAAA,GACAA,GAAA0K,EAAAlY,GAAAypB,EAAA,iBAEAzpB,KADAkW,MAAA,EAAAA,IAAA,IAAAgC,EAAA,GACAA,GAAAhC,EAAA1I,GAAAic,EAAA,eAEAjc,KADAxN,MAAA,GAAAA,IAAA,IAAAkW,EAAA,GACAA,GAAAlW,EAAAkY,GAAAuR,EAAA,iBAEAvR,KADA1K,MAAA,GAAAA,IAAA,IAAAxN,EAAA,GACAA,GAAAwN,EAAA0I,GAAAuT,EAAA,iBAGAvT,KAFAgC,MAAA,GAAAA,IAAA,IAAA1K,EAAA,GAEAxN,EAAAwN,GAAAxN,GAAAypB,EAAA,eAEAzpB,KADAkW,MAAA,EAAAA,IAAA,IAAAgC,EAAA,GACA1K,EAAA0K,GAAA1K,GAAAic,EAAA,gBAEAjc,KADAxN,MAAA,EAAAA,IAAA,IAAAkW,EAAA,GACAgC,EAAAhC,GAAAgC,GAAAuR,EAAA,gBAEAvR,KADA1K,MAAA,GAAAA,IAAA,IAAAxN,EAAA,GACAkW,EAAAlW,GAAAkW,GAAAuT,EAAA,eAEAvT,KADAgC,MAAA,GAAAA,IAAA,IAAA1K,EAAA,GACAxN,EAAAwN,GAAAxN,GAAAypB,EAAA,eAEAzpB,KADAkW,MAAA,EAAAA,IAAA,IAAAgC,EAAA,GACA1K,EAAA0K,GAAA1K,GAAAic,EAAA,eAEAjc,KADAxN,MAAA,EAAAA,IAAA,IAAAkW,EAAA,GACAgC,EAAAhC,GAAAgC,GAAAuR,EAAA,gBAEAvR,KADA1K,MAAA,GAAAA,IAAA,IAAAxN,EAAA,GACAkW,EAAAlW,GAAAkW,GAAAuT,EAAA,eAEAvT,KADAgC,MAAA,GAAAA,IAAA,IAAA1K,EAAA,GACAxN,EAAAwN,GAAAxN,GAAAypB,EAAA,eAEAzpB,KADAkW,MAAA,EAAAA,IAAA,IAAAgC,EAAA,GACA1K,EAAA0K,GAAA1K,GAAAic,EAAA,iBAEAjc,KADAxN,MAAA,EAAAA,IAAA,IAAAkW,EAAA,GACAgC,EAAAhC,GAAAgC,GAAAuR,EAAA,eAEAvR,KADA1K,MAAA,GAAAA,IAAA,IAAAxN,EAAA,GACAkW,EAAAlW,GAAAkW,GAAAuT,EAAA,gBAEAvT,KADAgC,MAAA,GAAAA,IAAA,IAAA1K,EAAA,GACAxN,EAAAwN,GAAAxN,GAAAypB,EAAA,iBAEAzpB,KADAkW,MAAA,EAAAA,IAAA,IAAAgC,EAAA,GACA1K,EAAA0K,GAAA1K,GAAAic,EAAA,cAEAjc,KADAxN,MAAA,EAAAA,IAAA,IAAAkW,EAAA,GACAgC,EAAAhC,GAAAgC,GAAAuR,EAAA,gBAEAvR,KADA1K,MAAA,GAAAA,IAAA,IAAAxN,EAAA,GACAkW,EAAAlW,GAAAkW,GAAAuT,EAAA,iBAGAvT,KAFAgC,MAAA,GAAAA,IAAA,IAAA1K,EAAA,GAEAA,EAAAxN,GAAAypB,EAAA,YAEAzpB,KADAkW,MAAA,EAAAA,IAAA,IAAAgC,EAAA,GACAA,EAAA1K,GAAAic,EAAA,gBAEAjc,KADAxN,MAAA,GAAAA,IAAA,IAAAkW,EAAA,GACAA,EAAAgC,GAAAuR,EAAA,iBAEAvR,KADA1K,MAAA,GAAAA,IAAA,IAAAxN,EAAA,GACAA,EAAAkW,GAAAuT,EAAA,eAEAvT,KADAgC,MAAA,GAAAA,IAAA,GAAA1K,EAAA,GACAA,EAAAxN,GAAAypB,EAAA,gBAEAzpB,KADAkW,MAAA,EAAAA,IAAA,IAAAgC,EAAA,GACAA,EAAA1K,GAAAic,EAAA,gBAEAjc,KADAxN,MAAA,GAAAA,IAAA,IAAAkW,EAAA,GACAA,EAAAgC,GAAAuR,EAAA,eAEAvR,KADA1K,MAAA,GAAAA,IAAA,IAAAxN,EAAA,GACAA,EAAAkW,GAAAuT,EAAA,iBAEAvT,KADAgC,MAAA,GAAAA,IAAA,GAAA1K,EAAA,GACAA,EAAAxN,GAAAypB,EAAA,gBAEAzpB,KADAkW,MAAA,EAAAA,IAAA,IAAAgC,EAAA,GACAA,EAAA1K,GAAAic,EAAA,eAEAjc,KADAxN,MAAA,GAAAA,IAAA,IAAAkW,EAAA,GACAA,EAAAgC,GAAAuR,EAAA,eAEAvR,KADA1K,MAAA,GAAAA,IAAA,IAAAxN,EAAA,GACAA,EAAAkW,GAAAuT,EAAA,cAEAvT,KADAgC,MAAA,GAAAA,IAAA,GAAA1K,EAAA,GACAA,EAAAxN,GAAAypB,EAAA,eAEAzpB,KADAkW,MAAA,EAAAA,IAAA,IAAAgC,EAAA,GACAA,EAAA1K,GAAAic,EAAA,gBAEAjc,KADAxN,MAAA,GAAAA,IAAA,IAAAkW,EAAA,GACAA,EAAAgC,GAAAuR,EAAA,gBAEAvR,KADA1K,MAAA,GAAAA,IAAA,IAAAxN,EAAA,GACAA,EAAAkW,GAAAuT,EAAA,eAGAvT,IAAA1I,IAFA0K,MAAA,GAAAA,IAAA,GAAA1K,EAAA,IAEAxN,IAAAypB,EAAA,eAEAzpB,IAAAkY,IADAhC,MAAA,EAAAA,IAAA,IAAAgC,EAAA,IACA1K,IAAAic,EAAA,gBAEAjc,IAAA0I,IADAlW,MAAA,GAAAA,IAAA,IAAAkW,EAAA,IACAgC,IAAAuR,EAAA,iBAEAvR,IAAAlY,IADAwN,MAAA,GAAAA,IAAA,IAAAxN,EAAA,IACAkW,IAAAuT,EAAA,cAEAvT,IAAA1I,IADA0K,MAAA,GAAAA,IAAA,IAAA1K,EAAA,IACAxN,IAAAypB,EAAA,iBAEAzpB,IAAAkY,IADAhC,MAAA,EAAAA,IAAA,IAAAgC,EAAA,IACA1K,IAAAic,EAAA,gBAEAjc,IAAA0I,IADAlW,MAAA,GAAAA,IAAA,IAAAkW,EAAA,IACAgC,IAAAuR,EAAA,cAEAvR,IAAAlY,IADAwN,MAAA,GAAAA,IAAA,IAAAxN,EAAA,IACAkW,IAAAuT,EAAA,gBAEAvT,IAAA1I,IADA0K,MAAA,GAAAA,IAAA,IAAA1K,EAAA,IACAxN,IAAAypB,EAAA,gBAEAzpB,IAAAkY,IADAhC,MAAA,EAAAA,IAAA,IAAAgC,EAAA,IACA1K,IAAAic,EAAA,eAEAjc,IAAA0I,IADAlW,MAAA,GAAAA,IAAA,IAAAkW,EAAA,IACAgC,IAAAuR,EAAA,gBAEAvR,IAAAlY,IADAwN,MAAA,GAAAA,IAAA,IAAAxN,EAAA,IACAkW,IAAAuT,EAAA,iBAEAvT,IAAA1I,IADA0K,MAAA,GAAAA,IAAA,IAAA1K,EAAA,IACAxN,IAAAypB,EAAA,eAEAzpB,IAAAkY,IADAhC,MAAA,EAAAA,IAAA,IAAAgC,EAAA,IACA1K,IAAAic,EAAA,iBAEAjc,IAAA0I,IADAlW,MAAA,GAAAA,IAAA,IAAAkW,EAAA,IACAgC,IAAAuR,EAAA,eAGAvR,IADAA,IAAAlY,IADAwN,MAAA,GAAAA,IAAA,IAAAxN,EAAA,IACAkW,IAAAuT,EAAA,iBACA,GAAAvR,IAAA,IAAA1K,EAAA,EAEAlT,EAAA,GAAA4b,EAAA5b,EAAA,KACAA,EAAA,GAAA4d,EAAA5d,EAAA,KACAA,EAAA,GAAAkT,EAAAlT,EAAA,KACAA,EAAA,GAAA0F,EAAA1F,EAAA,KAGA,SAAAuiD,EAAA7rC,GACA,IACAxY,EADAskD,EAAA,GAGA,IAAAtkD,EAAA,EAAmBA,EAAA,GAAQA,GAAA,EAC3BskD,EAAAtkD,GAAA,GAAAwY,EAAA4C,WAAApb,IAAAwY,EAAA4C,WAAApb,EAAA,QAAAwY,EAAA4C,WAAApb,EAAA,SAAAwY,EAAA4C,WAAApb,EAAA,QAEA,OAAAskD,EAGA,SAAAC,EAAA7mC,GACA,IACA1d,EADAskD,EAAA,GAGA,IAAAtkD,EAAA,EAAmBA,EAAA,GAAQA,GAAA,EAC3BskD,EAAAtkD,GAAA,GAAA0d,EAAA1d,IAAA0d,EAAA1d,EAAA,QAAA0d,EAAA1d,EAAA,SAAA0d,EAAA1d,EAAA,QAEA,OAAAskD,EAGA,SAAAE,EAAAhsC,GACA,IAEAxY,EACAc,EACA2jD,EACAC,EACAC,EACAC,EAPAh9C,EAAA4Q,EAAA1X,OACAq2C,EAAA,8CAQA,IAAAn3C,EAAA,GAAoBA,GAAA4H,EAAQ5H,GAAA,GAC5BokD,EAAAjN,EAAAkN,EAAA7rC,EAAA9H,UAAA1Q,EAAA,GAAAA,KAKA,IAHAwY,IAAA9H,UAAA1Q,EAAA,IACAc,EAAA0X,EAAA1X,OACA2jD,EAAA,kCACAzkD,EAAA,EAAmBA,EAAAc,EAAYd,GAAA,EAC/BykD,EAAAzkD,GAAA,IAAAwY,EAAA4C,WAAApb,OAAA,MAGA,GADAykD,EAAAzkD,GAAA,UAAAA,EAAA,MACAA,EAAA,GAEA,IADAokD,EAAAjN,EAAAsN,GACAzkD,EAAA,EAAuBA,EAAA,GAAQA,GAAA,EAC/BykD,EAAAzkD,GAAA,EAcA,OARA0kD,GADAA,EAAA,EAAA98C,GACAxH,SAAA,IAAAkG,MAAA,kBACAq+C,EAAAvwC,SAAAswC,EAAA,OACAE,EAAAxwC,SAAAswC,EAAA,UAEAD,EAAA,IAAAE,EACAF,EAAA,IAAAG,EAEAR,EAAAjN,EAAAsN,GACAtN,EAmDA,SAAA0N,EAAAj9C,GACA,IACAmL,EADAyF,EAAA,GAEA,IAAAzF,EAAA,EAAmBA,EAAA,EAAOA,GAAA,EAC1ByF,GAAA2rC,EAAAv8C,GAAA,EAAAmL,EAAA,MAAAoxC,EAAAv8C,GAAA,EAAAmL,EAAA,IAEA,OAAAyF,EAGA,SAAAssC,EAAAhjD,GACA,IAAA9B,EACA,IAAAA,EAAA,EAAmBA,EAAA8B,EAAAhB,OAAcd,GAAA,EACjC8B,EAAA9B,GAAA6kD,EAAA/iD,EAAA9B,IAEA,OAAA8B,EAAAN,KAAA,IAmEA,SAAAujD,EAAApjD,GAKA,MAJA,kBAAAsG,KAAAtG,KACAA,EAAAmoC,SAAAxB,mBAAA3mC,KAGAA,EA6BA,SAAAqjD,EAAAF,GACA,IAEAhjD,EAFAma,EAAA,GACAnb,EAAAgkD,EAAAhkD,OAGA,IAAAgB,EAAA,EAAmBA,EAAAhB,EAAA,EAAgBgB,GAAA,EACnCma,EAAA3a,KAAA8S,SAAA0wC,EAAAzkD,OAAAyB,EAAA,QAGA,OAAAF,OAAAsa,aAAAzZ,MAAAb,OAAAqa,GAYA,SAAAgpC,IAEAviD,KAAAwiD,QAwTA,OAhbAJ,EAAAN,EAAA,UAgBA,oBAAAl3C,yBAAAtO,UAAAwO,OACA,WACA,SAAA23C,EAAAngD,EAAAlE,GAGA,OAFAkE,EAAA,EAAAA,GAAA,GAEA,EACA/E,KAAAkU,IAAAnP,EAAAlE,EAAA,GAGAb,KAAA2S,IAAA5N,EAAAlE,GAGAwM,YAAAtO,UAAAwO,MAAA,SAAA2b,EAAAzT,GACA,IAGAyb,EACA1jB,EACAE,EACAC,EANA9M,EAAA4B,KAAAgL,WACA03C,EAAAD,EAAAh8B,EAAAroB,GACAic,EAAAjc,EAUA,OAJA4U,IAAAvM,IACA4T,EAAAooC,EAAAzvC,EAAA5U,IAGAskD,EAAAroC,EACA,IAAAzP,YAAA,IAGA6jB,EAAApU,EAAAqoC,EACA33C,EAAA,IAAAH,YAAA6jB,GACAxjB,EAAA,IAAA/N,WAAA6N,GAEAG,EAAA,IAAAhO,WAAA8C,KAAA0iD,EAAAj0B,GACAxjB,EAAA1G,IAAA2G,GAEAH,IAnCA,GAkHAw3C,EAAAjmD,UAAAgc,OAAA,SAAArZ,GAKA,OAFAe,KAAAya,aAAA4nC,EAAApjD,IAEAe,MAUAuiD,EAAAjmD,UAAAme,aAAA,SAAAkoC,GACA3iD,KAAA4iD,OAAAD,EACA3iD,KAAA6iD,SAAAF,EAAAvkD,OAEA,IACAd,EADAc,EAAA4B,KAAA4iD,MAAAxkD,OAGA,IAAAd,EAAA,GAAoBA,GAAAc,EAAad,GAAA,GACjCokD,EAAA1hD,KAAA8iD,MAAAnB,EAAA3hD,KAAA4iD,MAAA50C,UAAA1Q,EAAA,GAAAA,KAKA,OAFA0C,KAAA4iD,MAAA5iD,KAAA4iD,MAAA50C,UAAA1Q,EAAA,IAEA0C,MAWAuiD,EAAAjmD,UAAA+d,IAAA,SAAAe,GACA,IAEA9d,EAEAuE,EAJAgJ,EAAA7K,KAAA4iD,MACAxkD,EAAAyM,EAAAzM,OAEA2jD,EAAA,kCAGA,IAAAzkD,EAAA,EAAmBA,EAAAc,EAAYd,GAAA,EAC/BykD,EAAAzkD,GAAA,IAAAuN,EAAA6N,WAAApb,OAAA,MAYA,OATA0C,KAAA+iD,QAAAhB,EAAA3jD,GACAyD,EAAAugD,EAAApiD,KAAA8iD,OAEA1nC,IACAvZ,EAAAygD,EAAAzgD,IAGA7B,KAAAwiD,QAEA3gD,GAQA0gD,EAAAjmD,UAAAkmD,MAAA,WAKA,OAJAxiD,KAAA4iD,MAAA,GACA5iD,KAAA6iD,QAAA,EACA7iD,KAAA8iD,MAAA,8CAEA9iD,MAQAuiD,EAAAjmD,UAAA0mD,SAAA,WACA,OACAn4C,KAAA7K,KAAA4iD,MACAxkD,OAAA4B,KAAA6iD,QACAzgD,KAAApC,KAAA8iD,QAWAP,EAAAjmD,UAAA2mD,SAAA,SAAAxO,GAKA,OAJAz0C,KAAA4iD,MAAAnO,EAAA5pC,KACA7K,KAAA6iD,QAAApO,EAAAr2C,OACA4B,KAAA8iD,MAAArO,EAAAryC,KAEApC,MAOAuiD,EAAAjmD,UAAAgf,QAAA,kBACAtb,KAAA8iD,aACA9iD,KAAA4iD,aACA5iD,KAAA6iD,SASAN,EAAAjmD,UAAAymD,QAAA,SAAAhB,EAAA3jD,GACA,IACA4jD,EACAC,EACAC,EAHA5kD,EAAAc,EAMA,GADA2jD,EAAAzkD,GAAA,UAAAA,EAAA,MACAA,EAAA,GAEA,IADAokD,EAAA1hD,KAAA8iD,MAAAf,GACAzkD,EAAA,EAAuBA,EAAA,GAAQA,GAAA,EAC/BykD,EAAAzkD,GAAA,EAOA0kD,GADAA,EAAA,EAAAhiD,KAAA6iD,SACAnlD,SAAA,IAAAkG,MAAA,kBACAq+C,EAAAvwC,SAAAswC,EAAA,OACAE,EAAAxwC,SAAAswC,EAAA,UAEAD,EAAA,IAAAE,EACAF,EAAA,IAAAG,EACAR,EAAA1hD,KAAA8iD,MAAAf,IAYAQ,EAAAngD,KAAA,SAAAnD,EAAAmc,GAGA,OAAAmnC,EAAAW,WAAAb,EAAApjD,GAAAmc,IAWAmnC,EAAAW,WAAA,SAAAC,EAAA/nC,GACA,IACAvZ,EAAAugD,EADAN,EAAAqB,IAGA,OAAA/nC,EAAAknC,EAAAzgD,MAUA0gD,EAAA33C,YAAA,WAEA5K,KAAAwiD,SAUAD,EAAA33C,YAAAtO,UAAAgc,OAAA,SAAAjK,GACA,IAEA/Q,EAhPA8lD,EAAAC,EAAAC,EACAx2C,EA6OAjC,GA9OAu4C,EA8OApjD,KAAA4iD,MAAAvpC,OA9OAgqC,EA8OAh1C,EA9OAi1C,GA8OA,GA7OAx2C,EAAA,IAAA5P,WAAAkmD,EAAAp4C,WAAAq4C,EAAAr4C,aAEAzG,IAAA,IAAArH,WAAAkmD,IACAt2C,EAAAvI,IAAA,IAAArH,WAAAmmD,GAAAD,EAAAp4C,YAEAs4C,EAAAx2C,IAAAuM,QAyOAjb,EAAAyM,EAAAzM,OAKA,IAFA4B,KAAA6iD,SAAAx0C,EAAArD,WAEA1N,EAAA,GAAoBA,GAAAc,EAAad,GAAA,GACjCokD,EAAA1hD,KAAA8iD,MAAAjB,EAAAh3C,EAAA04C,SAAAjmD,EAAA,GAAAA,KAKA,OAFA0C,KAAA4iD,MAAAtlD,EAAA,GAAAc,EAAA,IAAAlB,WAAA2N,EAAAwO,OAAAvO,MAAAxN,EAAA,SAAAJ,WAAA,GAEA8C,MAWAuiD,EAAA33C,YAAAtO,UAAA+d,IAAA,SAAAe,GACA,IAGA9d,EACAuE,EAJAgJ,EAAA7K,KAAA4iD,MACAxkD,EAAAyM,EAAAzM,OACA2jD,EAAA,kCAIA,IAAAzkD,EAAA,EAAmBA,EAAAc,EAAYd,GAAA,EAC/BykD,EAAAzkD,GAAA,IAAAuN,EAAAvN,OAAA,MAYA,OATA0C,KAAA+iD,QAAAhB,EAAA3jD,GACAyD,EAAAugD,EAAApiD,KAAA8iD,OAEA1nC,IACAvZ,EAAAygD,EAAAzgD,IAGA7B,KAAAwiD,QAEA3gD,GAQA0gD,EAAA33C,YAAAtO,UAAAkmD,MAAA,WAKA,OAJAxiD,KAAA4iD,MAAA,IAAA1lD,WAAA,GACA8C,KAAA6iD,QAAA,EACA7iD,KAAA8iD,MAAA,8CAEA9iD,MAQAuiD,EAAA33C,YAAAtO,UAAA0mD,SAAA,WACA,IAnTAn4C,EAmTA4pC,EAAA8N,EAAAjmD,UAAA0mD,SAAAhgD,KAAAhD,MAKA,OAFAy0C,EAAA5pC,MAtTAA,EAsTA4pC,EAAA5pC,KArTA3L,OAAAsa,aAAAzZ,MAAA,SAAA7C,WAAA2N,KAuTA4pC,GAUA8N,EAAA33C,YAAAtO,UAAA2mD,SAAA,SAAAxO,GAIA,OAFAA,EAAA5pC,KAjVA,SAAA5L,EAAAqkD,GACA,IAGAhmD,EAHAc,EAAAa,EAAAb,OACAyM,EAAA,IAAAD,YAAAxM,GACAiQ,EAAA,IAAAnR,WAAA2N,GAGA,IAAAvN,EAAA,EAAmBA,EAAAc,EAAYd,GAAA,EAC/B+Q,EAAA/Q,GAAA2B,EAAAyZ,WAAApb,GAGA,OAAAgmD,EAAAj1C,EAAAxD,EAuUA24C,CAAA/O,EAAA5pC,MAAA,GAEA03C,EAAAjmD,UAAA2mD,SAAAjgD,KAAAhD,KAAAy0C,IAGA8N,EAAA33C,YAAAtO,UAAAgf,QAAAinC,EAAAjmD,UAAAgf,QAEAinC,EAAA33C,YAAAtO,UAAAymD,QAAAR,EAAAjmD,UAAAymD,QAUAR,EAAA33C,YAAAxI,KAAA,SAAAiM,EAAA+M,GACA,IACAvZ,EAAAugD,EA7eA,SAAApnC,GACA,IAEA1d,EACAc,EACA2jD,EACAC,EACAC,EACAC,EAPAh9C,EAAA8V,EAAA5c,OACAq2C,EAAA,8CAQA,IAAAn3C,EAAA,GAAoBA,GAAA4H,EAAQ5H,GAAA,GAC5BokD,EAAAjN,EAAAoN,EAAA7mC,EAAAuoC,SAAAjmD,EAAA,GAAAA,KAWA,IAJA0d,EAAA1d,EAAA,GAAA4H,EAAA8V,EAAAuoC,SAAAjmD,EAAA,QAAAJ,WAAA,GAEAkB,EAAA4c,EAAA5c,OACA2jD,EAAA,kCACAzkD,EAAA,EAAmBA,EAAAc,EAAYd,GAAA,EAC/BykD,EAAAzkD,GAAA,IAAA0d,EAAA1d,OAAA,MAIA,GADAykD,EAAAzkD,GAAA,UAAAA,EAAA,MACAA,EAAA,GAEA,IADAokD,EAAAjN,EAAAsN,GACAzkD,EAAA,EAAuBA,EAAA,GAAQA,GAAA,EAC/BykD,EAAAzkD,GAAA,EAeA,OATA0kD,GADAA,EAAA,EAAA98C,GACAxH,SAAA,IAAAkG,MAAA,kBACAq+C,EAAAvwC,SAAAswC,EAAA,OACAE,EAAAxwC,SAAAswC,EAAA,UAEAD,EAAA,IAAAE,EACAF,EAAA,IAAAG,EAEAR,EAAAjN,EAAAsN,GAEAtN,EA+bAgP,CAAA,IAAAvmD,WAAAmR,KAGA,OAAA+M,EAAAknC,EAAAzgD,MAGA0gD,EA1uBAmB,wBCHA,IAAAC,EAASz8C,EAAQ,KACjB0U,EAAS1U,EAAQ,KAEjB4U,EAAAF,EACAE,EAAA6nC,KACA7nC,EAAAF,KAEA3f,EAAAC,QAAA4f,uBCPA,IAQA8nC,EACAC,EATAC,EAAU58C,EAAQ,KAClB68C,EAAkB78C,EAAQ,KAW1B88C,EAAA,EACAC,EAAA,EA+FAhoD,EAAAC,QA5FA,SAAA8qC,EAAAppC,EAAAC,GACA,IAAAP,EAAAM,GAAAC,GAAA,EACAmf,EAAApf,GAAA,GAGAwe,GADA4qB,KAAA,IACA5qB,MAAAwnC,EACAM,OAAAz9C,IAAAugC,EAAAkd,SAAAld,EAAAkd,SAAAL,EAKA,SAAAznC,GAAA,MAAA8nC,EAAA,CACA,IAAAC,EAAAL,IACA,MAAA1nC,IAEAA,EAAAwnC,EAAA,CACA,EAAAO,EAAA,GACAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,KAGA,MAAAD,IAEAA,EAAAL,EAAA,OAAAM,EAAA,MAAAA,EAAA,KAQA,IAAAC,OAAA39C,IAAAugC,EAAAod,MAAApd,EAAAod,OAAA,IAAAlhD,MAAAmhD,UAIAC,OAAA79C,IAAAugC,EAAAsd,MAAAtd,EAAAsd,MAAAL,EAAA,EAGAM,EAAAH,EAAAJ,GAAAM,EAAAL,GAAA,IAcA,GAXAM,EAAA,QAAA99C,IAAAugC,EAAAkd,WACAA,IAAA,UAKAK,EAAA,GAAAH,EAAAJ,SAAAv9C,IAAAugC,EAAAsd,QACAA,EAAA,GAIAA,GAAA,IACA,UAAAnkD,MAAA,mDAGA6jD,EAAAI,EACAH,EAAAK,EACAT,EAAAK,EAMA,IAAAM,GAAA,gBAHAJ,GAAA,cAGAE,GAAA,WACAtnC,EAAA1f,KAAAknD,IAAA,OACAxnC,EAAA1f,KAAAknD,IAAA,OACAxnC,EAAA1f,KAAAknD,IAAA,MACAxnC,EAAA1f,KAAA,IAAAknD,EAGA,IAAAC,EAAAL,EAAA,yBACApnC,EAAA1f,KAAAmnD,IAAA,MACAznC,EAAA1f,KAAA,IAAAmnD,EAGAznC,EAAA1f,KAAAmnD,IAAA,SACAznC,EAAA1f,KAAAmnD,IAAA,OAGAznC,EAAA1f,KAAA4mD,IAAA,MAGAlnC,EAAA1f,KAAA,IAAA4mD,EAGA,QAAAh/C,EAAA,EAAiBA,EAAA,IAAOA,EACxB8X,EAAA1f,EAAA4H,GAAAkX,EAAAlX,GAGA,OAAAtH,GAAAmmD,EAAA/mC,yBCzGA,IAAA8mC,EAAU58C,EAAQ,KAClB68C,EAAkB78C,EAAQ,KA2B1BjL,EAAAC,QAzBA,SAAA8qC,EAAAppC,EAAAC,GACA,IAAAP,EAAAM,GAAAC,GAAA,EAEA,qBACAD,EAAA,WAAAopC,EAAA,IAAA5pC,MAAA,SACA4pC,EAAA,MAIA,IAAA7pC,GAFA6pC,KAAA,IAEAxpC,SAAAwpC,EAAA8c,UAOA,GAJA3mD,EAAA,MAAAA,EAAA,MACAA,EAAA,MAAAA,EAAA,OAGAS,EACA,QAAA8mD,EAAA,EAAoBA,EAAA,KAASA,EAC7B9mD,EAAAN,EAAAonD,GAAAvnD,EAAAunD,GAIA,OAAA9mD,GAAAmmD,EAAA5mD,sCC8BA,SAAA4G,EAAA9F,EAAA8xB,EAAAC,GACA,IAAAC,EAAAD,IAAA5xB,OAAA,GACAH,IAAAgyB,EAAAC,UAEAF,EAAAjsB,MACAksB,EAAAD,IAAA5xB,OAAA,IAEA,IAAA8xB,EAAAD,EAAAC,QACAC,EAAAF,EAAAhd,MACA,GAAA7V,MAAAkG,QAAA4sB,GACAA,EAAAtxB,KAAAX,QACG,GAAAkyB,IAAAJ,EAAA3xB,OAAA,GAEH8xB,EADAH,EAAAhsB,OACA9F,OAEA8xB,EAAAnxB,KAAAX,GA/DA/B,EAAAqD,UAAA,SAAA0zB,GACA,IAAAjU,EAAA,GACAA,EAAApgB,KAAA,CAAcX,IAAAg1B,IAId,IAFA,IACAhY,EAAAhd,EAAAqE,EAAAhF,EAAAqnD,EAAAzmD,EAAAqwB,EAAA5qB,EAAAnH,EAAAooD,EADAt3C,EAAA,GAEA2N,EAAA+D,EAAAjb,OAKA,GAJA9F,EAAAgd,EAAAhd,IAGAqP,GAFA2N,EAAAqH,QAAA,GACAhgB,EAAA2Y,EAAA3Y,KAAA,GAGAgL,GAAAhL,OACK,oBAAArE,EACLqP,QAAA,IAAArP,EAAA,KAAAqB,KAAAC,UAAAtB,QACK,UAAAA,EACLqP,GAAA,YACK,GAAAlQ,MAAAkG,QAAArF,GAAA,CAEL,IADA+gB,EAAApgB,KAAA,CAAkB0D,IAAA,MAClBhF,EAAAW,EAAAG,OAAA,EAA8Bd,GAAA,EAAQA,IACtCqnD,EAAA,IAAArnD,EAAA,OACA0hB,EAAApgB,KAAA,CAAoBX,MAAAX,GAAAglB,OAAAqiC,IAEpB3lC,EAAApgB,KAAA,CAAkB0D,IAAA,UACb,CAEL,IAAAisB,KADArwB,EAAA,GACAD,EACAA,EAAAwF,eAAA8qB,IACArwB,EAAAU,KAAA2vB,GAIA,IADAvP,EAAApgB,KAAA,CAAkB0D,IAAA,MAClBhF,EAAAY,EAAAE,OAAA,EAA+Bd,GAAA,EAAQA,IAEvCd,EAAAyB,EADA0F,EAAAzF,EAAAZ,IAEAsnD,EAAAtnD,EAAA,SACAsnD,GAAAtlD,KAAAC,UAAAoE,GAAA,IACAqb,EAAApgB,KAAA,CAAoBX,IAAAzB,EAAA8lB,OAAAsiC,IAEpB5lC,EAAApgB,KAAA,CAAkB0D,IAAA,MAGlB,OAAAgL,GAyBApR,EAAAm8B,MAAA,SAAAp5B,GAOA,IANA,IAGA2uB,EAAAwjB,EAAAyT,EACAC,EAAAC,EAAAC,EAAA/4B,EACAqlB,EAAAC,EALAxhB,EAAA,GACAC,EAAA,GACA1yB,EAAA,IAMA,UADAswB,EAAA3uB,EAAA3B,OAEA,MAAAswB,QACA,IAAAA,EAQA,OAAAA,GACA,QACA,SACA,SACA,QACA,QACA,MACA,QACAtwB,GAAA,EACAyG,EAAA,KAAAgsB,EAAAC,GACA,MACA,QACA1yB,GAAA,EACAyG,GAAA,EAAAgsB,EAAAC,GACA,MACA,QACA1yB,GAAA,EACAyG,GAAA,EAAAgsB,EAAAC,GACA,MACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QAGA,IAFAohB,EAAA,GACA9zC,MACA,CAEA,GADAunD,EAAA5lD,EAAA3B,MACA,cAAAiI,KAAAs/C,GAEW,CACXvnD,IACA,MAHA8zC,GAAAyT,EAMA9gD,EAAAsrB,WAAA+hB,GAAArhB,EAAAC,GACA,MACA,QAIA,IAHA80B,EAAA,GACAC,OAAA,EACAC,EAAA,EAGA,OADA/4B,EAAAhtB,EAAA3B,OACA,OAAAynD,GACAC,EAAA,MACAF,GAAA74B,EAEA,QADA84B,EAAA94B,GAEA+4B,IAEAA,EAAA,EAMAjhD,EAAAzE,KAAA+4B,MAAA,IAAAysB,EAAA,KAAA/0B,EAAAC,GACA,MACA,QACAshB,EAAA,CAAwBphB,QAAA,GAAAjd,MAAA8c,EAAA3xB,QACxB2xB,EAAAnxB,KAAA0yC,EAAAphB,SACAF,EAAApxB,KAAA0yC,GACA,MACA,QACAC,EAAA,CAAsBrhB,QAAA,GAAYjd,MAAA8c,EAAA3xB,QAClC2xB,EAAAnxB,KAAA2yC,EAAArhB,SACAF,EAAApxB,KAAA2yC,GACA,MACA,QACA,UAAApxC,MACA,sCAAAytB,OAtFA,CAGA,OAAAmC,EAAA3xB,OACA,OAAA2xB,EAAAhsB,MAEAA,EAAAgsB,EAAAhsB,MAAAgsB,EAAAC,wBCzFA/zB,EAAAC,QAAA,SAAAyI,GACA,OAAAA,GAAA,iBAAAA,GACA,mBAAAA,EAAA67C,MACA,mBAAA77C,EAAAsgD,MACA,mBAAAtgD,EAAAugD","file":"1.77876b03954816d1612a.js","sourcesContent":["if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n","// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\n\n// getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\nvar getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues.bind(crypto)) ||\n                      (typeof(msCrypto) != 'undefined' && msCrypto.getRandomValues.bind(msCrypto));\nif (getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\n  module.exports = function whatwgRNG() {\n    getRandomValues(rnds8);\n    return rnds8;\n  };\n} else {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n\n  module.exports = function mathRNG() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  return bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]];\n}\n\nmodule.exports = bytesToUuid;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\n  function getOwnPropertyDescriptors(obj) {\n    var keys = Object.keys(obj);\n    var descriptors = {};\n    for (var i = 0; i < keys.length; i++) {\n      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);\n    }\n    return descriptors;\n  };\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  if (typeof process !== 'undefined' && process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Allow for deprecating things in the process of starting up.\n  if (typeof process === 'undefined') {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nvar kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;\n\nexports.promisify = function promisify(original) {\n  if (typeof original !== 'function')\n    throw new TypeError('The \"original\" argument must be of type Function');\n\n  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n    if (typeof fn !== 'function') {\n      throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n    }\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn, enumerable: false, writable: false, configurable: true\n    });\n    return fn;\n  }\n\n  function fn() {\n    var promiseResolve, promiseReject;\n    var promise = new Promise(function (resolve, reject) {\n      promiseResolve = resolve;\n      promiseReject = reject;\n    });\n\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n    args.push(function (err, value) {\n      if (err) {\n        promiseReject(err);\n      } else {\n        promiseResolve(value);\n      }\n    });\n\n    try {\n      original.apply(this, args);\n    } catch (err) {\n      promiseReject(err);\n    }\n\n    return promise;\n  }\n\n  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));\n\n  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n    value: fn, enumerable: false, writable: false, configurable: true\n  });\n  return Object.defineProperties(\n    fn,\n    getOwnPropertyDescriptors(original)\n  );\n}\n\nexports.promisify.custom = kCustomPromisifiedSymbol\n\nfunction callbackifyOnRejected(reason, cb) {\n  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).\n  // Because `null` is a special error value in callbacks which means \"no error\n  // occurred\", we error-wrap so the callback consumer can distinguish between\n  // \"the promise rejected with null\" or \"the promise fulfilled with undefined\".\n  if (!reason) {\n    var newReason = new Error('Promise was rejected with a falsy value');\n    newReason.reason = reason;\n    reason = newReason;\n  }\n  return cb(reason);\n}\n\nfunction callbackify(original) {\n  if (typeof original !== 'function') {\n    throw new TypeError('The \"original\" argument must be of type Function');\n  }\n\n  // We DO NOT return the promise as it gives the user a false sense that\n  // the promise is actually somehow related to the callback's execution\n  // and that the callback throwing will reject the promise.\n  function callbackified() {\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n\n    var maybeCb = args.pop();\n    if (typeof maybeCb !== 'function') {\n      throw new TypeError('The last argument must be of type Function');\n    }\n    var self = this;\n    var cb = function() {\n      return maybeCb.apply(self, arguments);\n    };\n    // In true node style we process the callback on `nextTick` with all the\n    // implications (stack, `uncaughtException`, `async_hooks`)\n    original.apply(this, args)\n      .then(function(ret) { process.nextTick(cb, null, ret) },\n            function(rej) { process.nextTick(callbackifyOnRejected, rej, cb) });\n  }\n\n  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\n  Object.defineProperties(callbackified,\n                          getOwnPropertyDescriptors(original));\n  return callbackified;\n}\nexports.callbackify = callbackify;\n","import getArguments from 'argsarray';\nimport nextTick from 'immediate';\nimport { EventEmitter } from 'events';\nimport inherits from 'inherits';\nimport Md5 from 'spark-md5';\nimport uuidV4 from 'uuid';\nimport vuvuzela from 'vuvuzela';\n\nfunction isBinaryObject(object) {\n  return (typeof ArrayBuffer !== 'undefined' && object instanceof ArrayBuffer) ||\n    (typeof Blob !== 'undefined' && object instanceof Blob);\n}\n\nfunction cloneArrayBuffer(buff) {\n  if (typeof buff.slice === 'function') {\n    return buff.slice(0);\n  }\n  // IE10-11 slice() polyfill\n  var target = new ArrayBuffer(buff.byteLength);\n  var targetArray = new Uint8Array(target);\n  var sourceArray = new Uint8Array(buff);\n  targetArray.set(sourceArray);\n  return target;\n}\n\nfunction cloneBinaryObject(object) {\n  if (object instanceof ArrayBuffer) {\n    return cloneArrayBuffer(object);\n  }\n  var size = object.size;\n  var type = object.type;\n  // Blob\n  if (typeof object.slice === 'function') {\n    return object.slice(0, size, type);\n  }\n  // PhantomJS slice() replacement\n  return object.webkitSlice(0, size, type);\n}\n\n// most of this is borrowed from lodash.isPlainObject:\n// https://github.com/fis-components/lodash.isplainobject/\n// blob/29c358140a74f252aeb08c9eb28bef86f2217d4a/index.js\n\nvar funcToString = Function.prototype.toString;\nvar objectCtorString = funcToString.call(Object);\n\nfunction isPlainObject(value) {\n  var proto = Object.getPrototypeOf(value);\n  /* istanbul ignore if */\n  if (proto === null) { // not sure when this happens, but I guess it can\n    return true;\n  }\n  var Ctor = proto.constructor;\n  return (typeof Ctor == 'function' &&\n    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);\n}\n\nfunction clone(object) {\n  var newObject;\n  var i;\n  var len;\n\n  if (!object || typeof object !== 'object') {\n    return object;\n  }\n\n  if (Array.isArray(object)) {\n    newObject = [];\n    for (i = 0, len = object.length; i < len; i++) {\n      newObject[i] = clone(object[i]);\n    }\n    return newObject;\n  }\n\n  // special case: to avoid inconsistencies between IndexedDB\n  // and other backends, we automatically stringify Dates\n  if (object instanceof Date) {\n    return object.toISOString();\n  }\n\n  if (isBinaryObject(object)) {\n    return cloneBinaryObject(object);\n  }\n\n  if (!isPlainObject(object)) {\n    return object; // don't clone objects like Workers\n  }\n\n  newObject = {};\n  for (i in object) {\n    /* istanbul ignore else */\n    if (Object.prototype.hasOwnProperty.call(object, i)) {\n      var value = clone(object[i]);\n      if (typeof value !== 'undefined') {\n        newObject[i] = value;\n      }\n    }\n  }\n  return newObject;\n}\n\nfunction once(fun) {\n  var called = false;\n  return getArguments(function (args) {\n    /* istanbul ignore if */\n    if (called) {\n      // this is a smoke test and should never actually happen\n      throw new Error('once called more than once');\n    } else {\n      called = true;\n      fun.apply(this, args);\n    }\n  });\n}\n\nfunction toPromise(func) {\n  //create the function we will be returning\n  return getArguments(function (args) {\n    // Clone arguments\n    args = clone(args);\n    var self = this;\n    // if the last argument is a function, assume its a callback\n    var usedCB = (typeof args[args.length - 1] === 'function') ? args.pop() : false;\n    var promise = new Promise(function (fulfill, reject) {\n      var resp;\n      try {\n        var callback = once(function (err, mesg) {\n          if (err) {\n            reject(err);\n          } else {\n            fulfill(mesg);\n          }\n        });\n        // create a callback for this invocation\n        // apply the function in the orig context\n        args.push(callback);\n        resp = func.apply(self, args);\n        if (resp && typeof resp.then === 'function') {\n          fulfill(resp);\n        }\n      } catch (e) {\n        reject(e);\n      }\n    });\n    // if there is a callback, call it back\n    if (usedCB) {\n      promise.then(function (result) {\n        usedCB(null, result);\n      }, usedCB);\n    }\n    return promise;\n  });\n}\n\nfunction logApiCall(self, name, args) {\n  /* istanbul ignore if */\n  if (self.constructor.listeners('debug').length) {\n    var logArgs = ['api', self.name, name];\n    for (var i = 0; i < args.length - 1; i++) {\n      logArgs.push(args[i]);\n    }\n    self.constructor.emit('debug', logArgs);\n\n    // override the callback itself to log the response\n    var origCallback = args[args.length - 1];\n    args[args.length - 1] = function (err, res) {\n      var responseArgs = ['api', self.name, name];\n      responseArgs = responseArgs.concat(\n        err ? ['error', err] : ['success', res]\n      );\n      self.constructor.emit('debug', responseArgs);\n      origCallback(err, res);\n    };\n  }\n}\n\nfunction adapterFun(name, callback) {\n  return toPromise(getArguments(function (args) {\n    if (this._closed) {\n      return Promise.reject(new Error('database is closed'));\n    }\n    if (this._destroyed) {\n      return Promise.reject(new Error('database is destroyed'));\n    }\n    var self = this;\n    logApiCall(self, name, args);\n    if (!this.taskqueue.isReady) {\n      return new Promise(function (fulfill, reject) {\n        self.taskqueue.addTask(function (failed) {\n          if (failed) {\n            reject(failed);\n          } else {\n            fulfill(self[name].apply(self, args));\n          }\n        });\n      });\n    }\n    return callback.apply(this, args);\n  }));\n}\n\nfunction mangle(key) {\n  return '$' + key;\n}\nfunction unmangle(key) {\n  return key.substring(1);\n}\nfunction Map$1() {\n  this._store = {};\n}\nMap$1.prototype.get = function (key) {\n  var mangled = mangle(key);\n  return this._store[mangled];\n};\nMap$1.prototype.set = function (key, value) {\n  var mangled = mangle(key);\n  this._store[mangled] = value;\n  return true;\n};\nMap$1.prototype.has = function (key) {\n  var mangled = mangle(key);\n  return mangled in this._store;\n};\nMap$1.prototype.delete = function (key) {\n  var mangled = mangle(key);\n  var res = mangled in this._store;\n  delete this._store[mangled];\n  return res;\n};\nMap$1.prototype.forEach = function (cb) {\n  var keys = Object.keys(this._store);\n  for (var i = 0, len = keys.length; i < len; i++) {\n    var key = keys[i];\n    var value = this._store[key];\n    key = unmangle(key);\n    cb(value, key);\n  }\n};\nObject.defineProperty(Map$1.prototype, 'size', {\n  get: function () {\n    return Object.keys(this._store).length;\n  }\n});\n\nfunction Set$1(array) {\n  this._store = new Map$1();\n\n  // init with an array\n  if (array && Array.isArray(array)) {\n    for (var i = 0, len = array.length; i < len; i++) {\n      this.add(array[i]);\n    }\n  }\n}\nSet$1.prototype.add = function (key) {\n  return this._store.set(key, true);\n};\nSet$1.prototype.has = function (key) {\n  return this._store.has(key);\n};\nSet$1.prototype.forEach = function (cb) {\n  this._store.forEach(function (value, key) {\n    cb(key);\n  });\n};\nObject.defineProperty(Set$1.prototype, 'size', {\n  get: function () {\n    return this._store.size;\n  }\n});\n\n/* global Map,Set,Symbol */\n// Based on https://kangax.github.io/compat-table/es6/ we can sniff out\n// incomplete Map/Set implementations which would otherwise cause our tests to fail.\n// Notably they fail in IE11 and iOS 8.4, which this prevents.\nfunction supportsMapAndSet() {\n  if (typeof Symbol === 'undefined' || typeof Map === 'undefined' || typeof Set === 'undefined') {\n    return false;\n  }\n  var prop = Object.getOwnPropertyDescriptor(Map, Symbol.species);\n  return prop && 'get' in prop && Map[Symbol.species] === Map;\n}\n\n// based on https://github.com/montagejs/collections\n\nvar ExportedSet;\nvar ExportedMap;\n\n{\n  if (supportsMapAndSet()) { // prefer built-in Map/Set\n    ExportedSet = Set;\n    ExportedMap = Map;\n  } else { // fall back to our polyfill\n    ExportedSet = Set$1;\n    ExportedMap = Map$1;\n  }\n}\n\n// like underscore/lodash _.pick()\nfunction pick(obj, arr) {\n  var res = {};\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var prop = arr[i];\n    if (prop in obj) {\n      res[prop] = obj[prop];\n    }\n  }\n  return res;\n}\n\n// Most browsers throttle concurrent requests at 6, so it's silly\n// to shim _bulk_get by trying to launch potentially hundreds of requests\n// and then letting the majority time out. We can handle this ourselves.\nvar MAX_NUM_CONCURRENT_REQUESTS = 6;\n\nfunction identityFunction(x) {\n  return x;\n}\n\nfunction formatResultForOpenRevsGet(result) {\n  return [{\n    ok: result\n  }];\n}\n\n// shim for P/CouchDB adapters that don't directly implement _bulk_get\nfunction bulkGet(db, opts, callback) {\n  var requests = opts.docs;\n\n  // consolidate into one request per doc if possible\n  var requestsById = new ExportedMap();\n  requests.forEach(function (request) {\n    if (requestsById.has(request.id)) {\n      requestsById.get(request.id).push(request);\n    } else {\n      requestsById.set(request.id, [request]);\n    }\n  });\n\n  var numDocs = requestsById.size;\n  var numDone = 0;\n  var perDocResults = new Array(numDocs);\n\n  function collapseResultsAndFinish() {\n    var results = [];\n    perDocResults.forEach(function (res) {\n      res.docs.forEach(function (info) {\n        results.push({\n          id: res.id,\n          docs: [info]\n        });\n      });\n    });\n    callback(null, {results: results});\n  }\n\n  function checkDone() {\n    if (++numDone === numDocs) {\n      collapseResultsAndFinish();\n    }\n  }\n\n  function gotResult(docIndex, id, docs) {\n    perDocResults[docIndex] = {id: id, docs: docs};\n    checkDone();\n  }\n\n  var allRequests = [];\n  requestsById.forEach(function (value, key) {\n    allRequests.push(key);\n  });\n\n  var i = 0;\n\n  function nextBatch() {\n\n    if (i >= allRequests.length) {\n      return;\n    }\n\n    var upTo = Math.min(i + MAX_NUM_CONCURRENT_REQUESTS, allRequests.length);\n    var batch = allRequests.slice(i, upTo);\n    processBatch(batch, i);\n    i += batch.length;\n  }\n\n  function processBatch(batch, offset) {\n    batch.forEach(function (docId, j) {\n      var docIdx = offset + j;\n      var docRequests = requestsById.get(docId);\n\n      // just use the first request as the \"template\"\n      // TODO: The _bulk_get API allows for more subtle use cases than this,\n      // but for now it is unlikely that there will be a mix of different\n      // \"atts_since\" or \"attachments\" in the same request, since it's just\n      // replicate.js that is using this for the moment.\n      // Also, atts_since is aspirational, since we don't support it yet.\n      var docOpts = pick(docRequests[0], ['atts_since', 'attachments']);\n      docOpts.open_revs = docRequests.map(function (request) {\n        // rev is optional, open_revs disallowed\n        return request.rev;\n      });\n\n      // remove falsey / undefined revisions\n      docOpts.open_revs = docOpts.open_revs.filter(identityFunction);\n\n      var formatResult = identityFunction;\n\n      if (docOpts.open_revs.length === 0) {\n        delete docOpts.open_revs;\n\n        // when fetching only the \"winning\" leaf,\n        // transform the result so it looks like an open_revs\n        // request\n        formatResult = formatResultForOpenRevsGet;\n      }\n\n      // globally-supplied options\n      ['revs', 'attachments', 'binary', 'ajax', 'latest'].forEach(function (param) {\n        if (param in opts) {\n          docOpts[param] = opts[param];\n        }\n      });\n      db.get(docId, docOpts, function (err, res) {\n        var result;\n        /* istanbul ignore if */\n        if (err) {\n          result = [{error: err}];\n        } else {\n          result = formatResult(res);\n        }\n        gotResult(docIdx, docId, result);\n        nextBatch();\n      });\n    });\n  }\n\n  nextBatch();\n\n}\n\nvar hasLocal;\n\ntry {\n  localStorage.setItem('_pouch_check_localstorage', 1);\n  hasLocal = !!localStorage.getItem('_pouch_check_localstorage');\n} catch (e) {\n  hasLocal = false;\n}\n\nfunction hasLocalStorage() {\n  return hasLocal;\n}\n\n// Custom nextTick() shim for browsers. In node, this will just be process.nextTick(). We\n\ninherits(Changes, EventEmitter);\n\n/* istanbul ignore next */\nfunction attachBrowserEvents(self) {\n  if (hasLocalStorage()) {\n    addEventListener(\"storage\", function (e) {\n      self.emit(e.key);\n    });\n  }\n}\n\nfunction Changes() {\n  EventEmitter.call(this);\n  this._listeners = {};\n\n  attachBrowserEvents(this);\n}\nChanges.prototype.addListener = function (dbName, id, db, opts) {\n  /* istanbul ignore if */\n  if (this._listeners[id]) {\n    return;\n  }\n  var self = this;\n  var inprogress = false;\n  function eventFunction() {\n    /* istanbul ignore if */\n    if (!self._listeners[id]) {\n      return;\n    }\n    if (inprogress) {\n      inprogress = 'waiting';\n      return;\n    }\n    inprogress = true;\n    var changesOpts = pick(opts, [\n      'style', 'include_docs', 'attachments', 'conflicts', 'filter',\n      'doc_ids', 'view', 'since', 'query_params', 'binary', 'return_docs'\n    ]);\n\n    /* istanbul ignore next */\n    function onError() {\n      inprogress = false;\n    }\n\n    db.changes(changesOpts).on('change', function (c) {\n      if (c.seq > opts.since && !opts.cancelled) {\n        opts.since = c.seq;\n        opts.onChange(c);\n      }\n    }).on('complete', function () {\n      if (inprogress === 'waiting') {\n        nextTick(eventFunction);\n      }\n      inprogress = false;\n    }).on('error', onError);\n  }\n  this._listeners[id] = eventFunction;\n  this.on(dbName, eventFunction);\n};\n\nChanges.prototype.removeListener = function (dbName, id) {\n  /* istanbul ignore if */\n  if (!(id in this._listeners)) {\n    return;\n  }\n  EventEmitter.prototype.removeListener.call(this, dbName,\n    this._listeners[id]);\n  delete this._listeners[id];\n};\n\n\n/* istanbul ignore next */\nChanges.prototype.notifyLocalWindows = function (dbName) {\n  //do a useless change on a storage thing\n  //in order to get other windows's listeners to activate\n  if (hasLocalStorage()) {\n    localStorage[dbName] = (localStorage[dbName] === \"a\") ? \"b\" : \"a\";\n  }\n};\n\nChanges.prototype.notify = function (dbName) {\n  this.emit(dbName);\n  this.notifyLocalWindows(dbName);\n};\n\nfunction guardedConsole(method) {\n  /* istanbul ignore else */\n  if (typeof console !== 'undefined' && typeof console[method] === 'function') {\n    var args = Array.prototype.slice.call(arguments, 1);\n    console[method].apply(console, args);\n  }\n}\n\nfunction randomNumber(min, max) {\n  var maxTimeout = 600000; // Hard-coded default of 10 minutes\n  min = parseInt(min, 10) || 0;\n  max = parseInt(max, 10);\n  if (max !== max || max <= min) {\n    max = (min || 1) << 1; //doubling\n  } else {\n    max = max + 1;\n  }\n  // In order to not exceed maxTimeout, pick a random value between half of maxTimeout and maxTimeout\n  if (max > maxTimeout) {\n    min = maxTimeout >> 1; // divide by two\n    max = maxTimeout;\n  }\n  var ratio = Math.random();\n  var range = max - min;\n\n  return ~~(range * ratio + min); // ~~ coerces to an int, but fast.\n}\n\nfunction defaultBackOff(min) {\n  var max = 0;\n  if (!min) {\n    max = 2000;\n  }\n  return randomNumber(min, max);\n}\n\n// designed to give info to browser users, who are disturbed\n// when they see http errors in the console\nfunction explainError(status, str) {\n  guardedConsole('info', 'The above ' + status + ' is totally normal. ' + str);\n}\n\nvar assign;\n{\n  if (typeof Object.assign === 'function') {\n    assign = Object.assign;\n  } else {\n    // lite Object.assign polyfill based on\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n    assign = function (target) {\n      var to = Object(target);\n\n      for (var index = 1; index < arguments.length; index++) {\n        var nextSource = arguments[index];\n\n        if (nextSource != null) { // Skip over if undefined or null\n          for (var nextKey in nextSource) {\n            // Avoid bugs when hasOwnProperty is shadowed\n            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n              to[nextKey] = nextSource[nextKey];\n            }\n          }\n        }\n      }\n      return to;\n    };\n  }\n}\n\nvar $inject_Object_assign = assign;\n\ninherits(PouchError, Error);\n\nfunction PouchError(status, error, reason) {\n  Error.call(this, reason);\n  this.status = status;\n  this.name = error;\n  this.message = reason;\n  this.error = true;\n}\n\nPouchError.prototype.toString = function () {\n  return JSON.stringify({\n    status: this.status,\n    name: this.name,\n    message: this.message,\n    reason: this.reason\n  });\n};\n\nvar UNAUTHORIZED = new PouchError(401, 'unauthorized', \"Name or password is incorrect.\");\nvar MISSING_BULK_DOCS = new PouchError(400, 'bad_request', \"Missing JSON list of 'docs'\");\nvar MISSING_DOC = new PouchError(404, 'not_found', 'missing');\nvar REV_CONFLICT = new PouchError(409, 'conflict', 'Document update conflict');\nvar INVALID_ID = new PouchError(400, 'bad_request', '_id field must contain a string');\nvar MISSING_ID = new PouchError(412, 'missing_id', '_id is required for puts');\nvar RESERVED_ID = new PouchError(400, 'bad_request', 'Only reserved document ids may start with underscore.');\nvar NOT_OPEN = new PouchError(412, 'precondition_failed', 'Database not open');\nvar UNKNOWN_ERROR = new PouchError(500, 'unknown_error', 'Database encountered an unknown error');\nvar BAD_ARG = new PouchError(500, 'badarg', 'Some query argument is invalid');\nvar INVALID_REQUEST = new PouchError(400, 'invalid_request', 'Request was invalid');\nvar QUERY_PARSE_ERROR = new PouchError(400, 'query_parse_error', 'Some query parameter is invalid');\nvar DOC_VALIDATION = new PouchError(500, 'doc_validation', 'Bad special document member');\nvar BAD_REQUEST = new PouchError(400, 'bad_request', 'Something wrong with the request');\nvar NOT_AN_OBJECT = new PouchError(400, 'bad_request', 'Document must be a JSON object');\nvar DB_MISSING = new PouchError(404, 'not_found', 'Database not found');\nvar IDB_ERROR = new PouchError(500, 'indexed_db_went_bad', 'unknown');\nvar WSQ_ERROR = new PouchError(500, 'web_sql_went_bad', 'unknown');\nvar LDB_ERROR = new PouchError(500, 'levelDB_went_went_bad', 'unknown');\nvar FORBIDDEN = new PouchError(403, 'forbidden', 'Forbidden by design doc validate_doc_update function');\nvar INVALID_REV = new PouchError(400, 'bad_request', 'Invalid rev format');\nvar FILE_EXISTS = new PouchError(412, 'file_exists', 'The database could not be created, the file already exists.');\nvar MISSING_STUB = new PouchError(412, 'missing_stub', 'A pre-existing attachment stub wasn\\'t found');\nvar INVALID_URL = new PouchError(413, 'invalid_url', 'Provided URL is invalid');\n\nfunction createError(error, reason) {\n  function CustomPouchError(reason) {\n    // inherit error properties from our parent error manually\n    // so as to allow proper JSON parsing.\n    /* jshint ignore:start */\n    for (var p in error) {\n      if (typeof error[p] !== 'function') {\n        this[p] = error[p];\n      }\n    }\n    /* jshint ignore:end */\n    if (reason !== undefined) {\n      this.reason = reason;\n    }\n  }\n  CustomPouchError.prototype = PouchError.prototype;\n  return new CustomPouchError(reason);\n}\n\nfunction generateErrorFromResponse(err) {\n\n  if (typeof err !== 'object') {\n    var data = err;\n    err = UNKNOWN_ERROR;\n    err.data = data;\n  }\n\n  if ('error' in err && err.error === 'conflict') {\n    err.name = 'conflict';\n    err.status = 409;\n  }\n\n  if (!('name' in err)) {\n    err.name = err.error || 'unknown';\n  }\n\n  if (!('status' in err)) {\n    err.status = 500;\n  }\n\n  if (!('message' in err)) {\n    err.message = err.message || err.reason;\n  }\n\n  return err;\n}\n\nfunction tryFilter(filter, doc, req) {\n  try {\n    return !filter(doc, req);\n  } catch (err) {\n    var msg = 'Filter function threw: ' + err.toString();\n    return createError(BAD_REQUEST, msg);\n  }\n}\n\nfunction filterChange(opts) {\n  var req = {};\n  var hasFilter = opts.filter && typeof opts.filter === 'function';\n  req.query = opts.query_params;\n\n  return function filter(change) {\n    if (!change.doc) {\n      // CSG sends events on the changes feed that don't have documents,\n      // this hack makes a whole lot of existing code robust.\n      change.doc = {};\n    }\n\n    var filterReturn = hasFilter && tryFilter(opts.filter, change.doc, req);\n\n    if (typeof filterReturn === 'object') {\n      return filterReturn;\n    }\n\n    if (filterReturn) {\n      return false;\n    }\n\n    if (!opts.include_docs) {\n      delete change.doc;\n    } else if (!opts.attachments) {\n      for (var att in change.doc._attachments) {\n        /* istanbul ignore else */\n        if (change.doc._attachments.hasOwnProperty(att)) {\n          change.doc._attachments[att].stub = true;\n        }\n      }\n    }\n    return true;\n  };\n}\n\nfunction flatten(arrs) {\n  var res = [];\n  for (var i = 0, len = arrs.length; i < len; i++) {\n    res = res.concat(arrs[i]);\n  }\n  return res;\n}\n\n// shim for Function.prototype.name,\n\n// Determine id an ID is valid\n//   - invalid IDs begin with an underescore that does not begin '_design' or\n//     '_local'\n//   - any other string value is a valid id\n// Returns the specific error object for each case\nfunction invalidIdError(id) {\n  var err;\n  if (!id) {\n    err = createError(MISSING_ID);\n  } else if (typeof id !== 'string') {\n    err = createError(INVALID_ID);\n  } else if (/^_/.test(id) && !(/^_(design|local)/).test(id)) {\n    err = createError(RESERVED_ID);\n  }\n  if (err) {\n    throw err;\n  }\n}\n\n// Checks if a PouchDB object is \"remote\" or not. This is\n\nfunction isRemote(db) {\n  if (typeof db._remote === 'boolean') {\n    return db._remote;\n  }\n  /* istanbul ignore next */\n  if (typeof db.type === 'function') {\n    guardedConsole('warn',\n      'db.type() is deprecated and will be removed in ' +\n      'a future version of PouchDB');\n    return db.type() === 'http';\n  }\n  /* istanbul ignore next */\n  return false;\n}\n\nfunction listenerCount(ee, type) {\n  return 'listenerCount' in ee ? ee.listenerCount(type) :\n                                 EventEmitter.listenerCount(ee, type);\n}\n\nfunction parseDesignDocFunctionName(s) {\n  if (!s) {\n    return null;\n  }\n  var parts = s.split('/');\n  if (parts.length === 2) {\n    return parts;\n  }\n  if (parts.length === 1) {\n    return [s, s];\n  }\n  return null;\n}\n\nfunction normalizeDesignDocFunctionName(s) {\n  var normalized = parseDesignDocFunctionName(s);\n  return normalized ? normalized.join('/') : null;\n}\n\n// originally parseUri 1.2.2, now patched by us\n// (c) Steven Levithan <stevenlevithan.com>\n// MIT License\nvar keys = [\"source\", \"protocol\", \"authority\", \"userInfo\", \"user\", \"password\",\n    \"host\", \"port\", \"relative\", \"path\", \"directory\", \"file\", \"query\", \"anchor\"];\nvar qName =\"queryKey\";\nvar qParser = /(?:^|&)([^&=]*)=?([^&]*)/g;\n\n// use the \"loose\" parser\n/* eslint maxlen: 0, no-useless-escape: 0 */\nvar parser = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n\nfunction parseUri(str) {\n  var m = parser.exec(str);\n  var uri = {};\n  var i = 14;\n\n  while (i--) {\n    var key = keys[i];\n    var value = m[i] || \"\";\n    var encoded = ['user', 'password'].indexOf(key) !== -1;\n    uri[key] = encoded ? decodeURIComponent(value) : value;\n  }\n\n  uri[qName] = {};\n  uri[keys[12]].replace(qParser, function ($0, $1, $2) {\n    if ($1) {\n      uri[qName][$1] = $2;\n    }\n  });\n\n  return uri;\n}\n\n// Based on https://github.com/alexdavid/scope-eval v0.0.3\n// (source: https://unpkg.com/scope-eval@0.0.3/scope_eval.js)\n// This is basically just a wrapper around new Function()\n\nfunction scopeEval(source, scope) {\n  var keys = [];\n  var values = [];\n  for (var key in scope) {\n    if (scope.hasOwnProperty(key)) {\n      keys.push(key);\n      values.push(scope[key]);\n    }\n  }\n  keys.push(source);\n  return Function.apply(null, keys).apply(null, values);\n}\n\n// this is essentially the \"update sugar\" function from daleharvey/pouchdb#1388\n// the diffFun tells us what delta to apply to the doc.  it either returns\n// the doc, or false if it doesn't need to do an update after all\nfunction upsert(db, docId, diffFun) {\n  return new Promise(function (fulfill, reject) {\n    db.get(docId, function (err, doc) {\n      if (err) {\n        /* istanbul ignore next */\n        if (err.status !== 404) {\n          return reject(err);\n        }\n        doc = {};\n      }\n\n      // the user might change the _rev, so save it for posterity\n      var docRev = doc._rev;\n      var newDoc = diffFun(doc);\n\n      if (!newDoc) {\n        // if the diffFun returns falsy, we short-circuit as\n        // an optimization\n        return fulfill({updated: false, rev: docRev});\n      }\n\n      // users aren't allowed to modify these values,\n      // so reset them here\n      newDoc._id = docId;\n      newDoc._rev = docRev;\n      fulfill(tryAndPut(db, newDoc, diffFun));\n    });\n  });\n}\n\nfunction tryAndPut(db, doc, diffFun) {\n  return db.put(doc).then(function (res) {\n    return {\n      updated: true,\n      rev: res.rev\n    };\n  }, function (err) {\n    /* istanbul ignore next */\n    if (err.status !== 409) {\n      throw err;\n    }\n    return upsert(db, doc._id, diffFun);\n  });\n}\n\nvar thisAtob = function (str) {\n  return atob(str);\n};\n\nvar thisBtoa = function (str) {\n  return btoa(str);\n};\n\n// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor (e.g.\n// old QtWebKit versions, Android < 4.4).\nfunction createBlob(parts, properties) {\n  /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */\n  parts = parts || [];\n  properties = properties || {};\n  try {\n    return new Blob(parts, properties);\n  } catch (e) {\n    if (e.name !== \"TypeError\") {\n      throw e;\n    }\n    var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder :\n                  typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder :\n                  typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder :\n                  WebKitBlobBuilder;\n    var builder = new Builder();\n    for (var i = 0; i < parts.length; i += 1) {\n      builder.append(parts[i]);\n    }\n    return builder.getBlob(properties.type);\n  }\n}\n\n// From http://stackoverflow.com/questions/14967647/ (continues on next line)\n// encode-decode-image-with-base64-breaks-image (2013-04-21)\nfunction binaryStringToArrayBuffer(bin) {\n  var length = bin.length;\n  var buf = new ArrayBuffer(length);\n  var arr = new Uint8Array(buf);\n  for (var i = 0; i < length; i++) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return buf;\n}\n\nfunction binStringToBluffer(binString, type) {\n  return createBlob([binaryStringToArrayBuffer(binString)], {type: type});\n}\n\nfunction b64ToBluffer(b64, type) {\n  return binStringToBluffer(thisAtob(b64), type);\n}\n\n//Can't find original post, but this is close\n//http://stackoverflow.com/questions/6965107/ (continues on next line)\n//converting-between-strings-and-arraybuffers\nfunction arrayBufferToBinaryString(buffer) {\n  var binary = '';\n  var bytes = new Uint8Array(buffer);\n  var length = bytes.byteLength;\n  for (var i = 0; i < length; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return binary;\n}\n\n// shim for browsers that don't support it\nfunction readAsBinaryString(blob, callback) {\n  var reader = new FileReader();\n  var hasBinaryString = typeof reader.readAsBinaryString === 'function';\n  reader.onloadend = function (e) {\n    var result = e.target.result || '';\n    if (hasBinaryString) {\n      return callback(result);\n    }\n    callback(arrayBufferToBinaryString(result));\n  };\n  if (hasBinaryString) {\n    reader.readAsBinaryString(blob);\n  } else {\n    reader.readAsArrayBuffer(blob);\n  }\n}\n\nfunction blobToBinaryString(blobOrBuffer, callback) {\n  readAsBinaryString(blobOrBuffer, function (bin) {\n    callback(bin);\n  });\n}\n\nfunction blobToBase64(blobOrBuffer, callback) {\n  blobToBinaryString(blobOrBuffer, function (base64) {\n    callback(thisBtoa(base64));\n  });\n}\n\n// simplified API. universal browser support is assumed\nfunction readAsArrayBuffer(blob, callback) {\n  var reader = new FileReader();\n  reader.onloadend = function (e) {\n    var result = e.target.result || new ArrayBuffer(0);\n    callback(result);\n  };\n  reader.readAsArrayBuffer(blob);\n}\n\n// this is not used in the browser\n\nvar setImmediateShim = global.setImmediate || global.setTimeout;\nvar MD5_CHUNK_SIZE = 32768;\n\nfunction rawToBase64(raw) {\n  return thisBtoa(raw);\n}\n\nfunction sliceBlob(blob, start, end) {\n  if (blob.webkitSlice) {\n    return blob.webkitSlice(start, end);\n  }\n  return blob.slice(start, end);\n}\n\nfunction appendBlob(buffer, blob, start, end, callback) {\n  if (start > 0 || end < blob.size) {\n    // only slice blob if we really need to\n    blob = sliceBlob(blob, start, end);\n  }\n  readAsArrayBuffer(blob, function (arrayBuffer) {\n    buffer.append(arrayBuffer);\n    callback();\n  });\n}\n\nfunction appendString(buffer, string, start, end, callback) {\n  if (start > 0 || end < string.length) {\n    // only create a substring if we really need to\n    string = string.substring(start, end);\n  }\n  buffer.appendBinary(string);\n  callback();\n}\n\nfunction binaryMd5(data, callback) {\n  var inputIsString = typeof data === 'string';\n  var len = inputIsString ? data.length : data.size;\n  var chunkSize = Math.min(MD5_CHUNK_SIZE, len);\n  var chunks = Math.ceil(len / chunkSize);\n  var currentChunk = 0;\n  var buffer = inputIsString ? new Md5() : new Md5.ArrayBuffer();\n\n  var append = inputIsString ? appendString : appendBlob;\n\n  function next() {\n    setImmediateShim(loadNextChunk);\n  }\n\n  function done() {\n    var raw = buffer.end(true);\n    var base64 = rawToBase64(raw);\n    callback(base64);\n    buffer.destroy();\n  }\n\n  function loadNextChunk() {\n    var start = currentChunk * chunkSize;\n    var end = start + chunkSize;\n    currentChunk++;\n    if (currentChunk < chunks) {\n      append(buffer, data, start, end, next);\n    } else {\n      append(buffer, data, start, end, done);\n    }\n  }\n  loadNextChunk();\n}\n\nfunction stringMd5(string) {\n  return Md5.hash(string);\n}\n\nfunction rev$$1(doc, deterministic_revs) {\n  var clonedDoc = clone(doc);\n  if (!deterministic_revs) {\n    return uuidV4.v4().replace(/-/g, '').toLowerCase();\n  }\n\n  delete clonedDoc._rev_tree;\n  return stringMd5(JSON.stringify(clonedDoc));\n}\n\nvar uuid = uuidV4.v4;\n\n// We fetch all leafs of the revision tree, and sort them based on tree length\n// and whether they were deleted, undeleted documents with the longest revision\n// tree (most edits) win\n// The final sort algorithm is slightly documented in a sidebar here:\n// http://guide.couchdb.org/draft/conflicts.html\nfunction winningRev(metadata) {\n  var winningId;\n  var winningPos;\n  var winningDeleted;\n  var toVisit = metadata.rev_tree.slice();\n  var node;\n  while ((node = toVisit.pop())) {\n    var tree = node.ids;\n    var branches = tree[2];\n    var pos = node.pos;\n    if (branches.length) { // non-leaf\n      for (var i = 0, len = branches.length; i < len; i++) {\n        toVisit.push({pos: pos + 1, ids: branches[i]});\n      }\n      continue;\n    }\n    var deleted = !!tree[1].deleted;\n    var id = tree[0];\n    // sort by deleted, then pos, then id\n    if (!winningId || (winningDeleted !== deleted ? winningDeleted :\n        winningPos !== pos ? winningPos < pos : winningId < id)) {\n      winningId = id;\n      winningPos = pos;\n      winningDeleted = deleted;\n    }\n  }\n\n  return winningPos + '-' + winningId;\n}\n\n// Pretty much all below can be combined into a higher order function to\n// traverse revisions\n// The return value from the callback will be passed as context to all\n// children of that node\nfunction traverseRevTree(revs, callback) {\n  var toVisit = revs.slice();\n\n  var node;\n  while ((node = toVisit.pop())) {\n    var pos = node.pos;\n    var tree = node.ids;\n    var branches = tree[2];\n    var newCtx =\n      callback(branches.length === 0, pos, tree[0], node.ctx, tree[1]);\n    for (var i = 0, len = branches.length; i < len; i++) {\n      toVisit.push({pos: pos + 1, ids: branches[i], ctx: newCtx});\n    }\n  }\n}\n\nfunction sortByPos(a, b) {\n  return a.pos - b.pos;\n}\n\nfunction collectLeaves(revs) {\n  var leaves = [];\n  traverseRevTree(revs, function (isLeaf, pos, id, acc, opts) {\n    if (isLeaf) {\n      leaves.push({rev: pos + \"-\" + id, pos: pos, opts: opts});\n    }\n  });\n  leaves.sort(sortByPos).reverse();\n  for (var i = 0, len = leaves.length; i < len; i++) {\n    delete leaves[i].pos;\n  }\n  return leaves;\n}\n\n// returns revs of all conflicts that is leaves such that\n// 1. are not deleted and\n// 2. are different than winning revision\nfunction collectConflicts(metadata) {\n  var win = winningRev(metadata);\n  var leaves = collectLeaves(metadata.rev_tree);\n  var conflicts = [];\n  for (var i = 0, len = leaves.length; i < len; i++) {\n    var leaf = leaves[i];\n    if (leaf.rev !== win && !leaf.opts.deleted) {\n      conflicts.push(leaf.rev);\n    }\n  }\n  return conflicts;\n}\n\n// compact a tree by marking its non-leafs as missing,\n// and return a list of revs to delete\nfunction compactTree(metadata) {\n  var revs = [];\n  traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n                                               revHash, ctx, opts) {\n    if (opts.status === 'available' && !isLeaf) {\n      revs.push(pos + '-' + revHash);\n      opts.status = 'missing';\n    }\n  });\n  return revs;\n}\n\n// build up a list of all the paths to the leafs in this revision tree\nfunction rootToLeaf(revs) {\n  var paths = [];\n  var toVisit = revs.slice();\n  var node;\n  while ((node = toVisit.pop())) {\n    var pos = node.pos;\n    var tree = node.ids;\n    var id = tree[0];\n    var opts = tree[1];\n    var branches = tree[2];\n    var isLeaf = branches.length === 0;\n\n    var history = node.history ? node.history.slice() : [];\n    history.push({id: id, opts: opts});\n    if (isLeaf) {\n      paths.push({pos: (pos + 1 - history.length), ids: history});\n    }\n    for (var i = 0, len = branches.length; i < len; i++) {\n      toVisit.push({pos: pos + 1, ids: branches[i], history: history});\n    }\n  }\n  return paths.reverse();\n}\n\n// for a better overview of what this is doing, read:\n\nfunction sortByPos$1(a, b) {\n  return a.pos - b.pos;\n}\n\n// classic binary search\nfunction binarySearch(arr, item, comparator) {\n  var low = 0;\n  var high = arr.length;\n  var mid;\n  while (low < high) {\n    mid = (low + high) >>> 1;\n    if (comparator(arr[mid], item) < 0) {\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n  return low;\n}\n\n// assuming the arr is sorted, insert the item in the proper place\nfunction insertSorted(arr, item, comparator) {\n  var idx = binarySearch(arr, item, comparator);\n  arr.splice(idx, 0, item);\n}\n\n// Turn a path as a flat array into a tree with a single branch.\n// If any should be stemmed from the beginning of the array, that's passed\n// in as the second argument\nfunction pathToTree(path, numStemmed) {\n  var root;\n  var leaf;\n  for (var i = numStemmed, len = path.length; i < len; i++) {\n    var node = path[i];\n    var currentLeaf = [node.id, node.opts, []];\n    if (leaf) {\n      leaf[2].push(currentLeaf);\n      leaf = currentLeaf;\n    } else {\n      root = leaf = currentLeaf;\n    }\n  }\n  return root;\n}\n\n// compare the IDs of two trees\nfunction compareTree(a, b) {\n  return a[0] < b[0] ? -1 : 1;\n}\n\n// Merge two trees together\n// The roots of tree1 and tree2 must be the same revision\nfunction mergeTree(in_tree1, in_tree2) {\n  var queue = [{tree1: in_tree1, tree2: in_tree2}];\n  var conflicts = false;\n  while (queue.length > 0) {\n    var item = queue.pop();\n    var tree1 = item.tree1;\n    var tree2 = item.tree2;\n\n    if (tree1[1].status || tree2[1].status) {\n      tree1[1].status =\n        (tree1[1].status ===  'available' ||\n        tree2[1].status === 'available') ? 'available' : 'missing';\n    }\n\n    for (var i = 0; i < tree2[2].length; i++) {\n      if (!tree1[2][0]) {\n        conflicts = 'new_leaf';\n        tree1[2][0] = tree2[2][i];\n        continue;\n      }\n\n      var merged = false;\n      for (var j = 0; j < tree1[2].length; j++) {\n        if (tree1[2][j][0] === tree2[2][i][0]) {\n          queue.push({tree1: tree1[2][j], tree2: tree2[2][i]});\n          merged = true;\n        }\n      }\n      if (!merged) {\n        conflicts = 'new_branch';\n        insertSorted(tree1[2], tree2[2][i], compareTree);\n      }\n    }\n  }\n  return {conflicts: conflicts, tree: in_tree1};\n}\n\nfunction doMerge(tree, path, dontExpand) {\n  var restree = [];\n  var conflicts = false;\n  var merged = false;\n  var res;\n\n  if (!tree.length) {\n    return {tree: [path], conflicts: 'new_leaf'};\n  }\n\n  for (var i = 0, len = tree.length; i < len; i++) {\n    var branch = tree[i];\n    if (branch.pos === path.pos && branch.ids[0] === path.ids[0]) {\n      // Paths start at the same position and have the same root, so they need\n      // merged\n      res = mergeTree(branch.ids, path.ids);\n      restree.push({pos: branch.pos, ids: res.tree});\n      conflicts = conflicts || res.conflicts;\n      merged = true;\n    } else if (dontExpand !== true) {\n      // The paths start at a different position, take the earliest path and\n      // traverse up until it as at the same point from root as the path we\n      // want to merge.  If the keys match we return the longer path with the\n      // other merged After stemming we dont want to expand the trees\n\n      var t1 = branch.pos < path.pos ? branch : path;\n      var t2 = branch.pos < path.pos ? path : branch;\n      var diff = t2.pos - t1.pos;\n\n      var candidateParents = [];\n\n      var trees = [];\n      trees.push({ids: t1.ids, diff: diff, parent: null, parentIdx: null});\n      while (trees.length > 0) {\n        var item = trees.pop();\n        if (item.diff === 0) {\n          if (item.ids[0] === t2.ids[0]) {\n            candidateParents.push(item);\n          }\n          continue;\n        }\n        var elements = item.ids[2];\n        for (var j = 0, elementsLen = elements.length; j < elementsLen; j++) {\n          trees.push({\n            ids: elements[j],\n            diff: item.diff - 1,\n            parent: item.ids,\n            parentIdx: j\n          });\n        }\n      }\n\n      var el = candidateParents[0];\n\n      if (!el) {\n        restree.push(branch);\n      } else {\n        res = mergeTree(el.ids, t2.ids);\n        el.parent[2][el.parentIdx] = res.tree;\n        restree.push({pos: t1.pos, ids: t1.ids});\n        conflicts = conflicts || res.conflicts;\n        merged = true;\n      }\n    } else {\n      restree.push(branch);\n    }\n  }\n\n  // We didnt find\n  if (!merged) {\n    restree.push(path);\n  }\n\n  restree.sort(sortByPos$1);\n\n  return {\n    tree: restree,\n    conflicts: conflicts || 'internal_node'\n  };\n}\n\n// To ensure we dont grow the revision tree infinitely, we stem old revisions\nfunction stem(tree, depth) {\n  // First we break out the tree into a complete list of root to leaf paths\n  var paths = rootToLeaf(tree);\n  var stemmedRevs;\n\n  var result;\n  for (var i = 0, len = paths.length; i < len; i++) {\n    // Then for each path, we cut off the start of the path based on the\n    // `depth` to stem to, and generate a new set of flat trees\n    var path = paths[i];\n    var stemmed = path.ids;\n    var node;\n    if (stemmed.length > depth) {\n      // only do the stemming work if we actually need to stem\n      if (!stemmedRevs) {\n        stemmedRevs = {}; // avoid allocating this object unnecessarily\n      }\n      var numStemmed = stemmed.length - depth;\n      node = {\n        pos: path.pos + numStemmed,\n        ids: pathToTree(stemmed, numStemmed)\n      };\n\n      for (var s = 0; s < numStemmed; s++) {\n        var rev = (path.pos + s) + '-' + stemmed[s].id;\n        stemmedRevs[rev] = true;\n      }\n    } else { // no need to actually stem\n      node = {\n        pos: path.pos,\n        ids: pathToTree(stemmed, 0)\n      };\n    }\n\n    // Then we remerge all those flat trees together, ensuring that we dont\n    // connect trees that would go beyond the depth limit\n    if (result) {\n      result = doMerge(result, node, true).tree;\n    } else {\n      result = [node];\n    }\n  }\n\n  // this is memory-heavy per Chrome profiler, avoid unless we actually stemmed\n  if (stemmedRevs) {\n    traverseRevTree(result, function (isLeaf, pos, revHash) {\n      // some revisions may have been removed in a branch but not in another\n      delete stemmedRevs[pos + '-' + revHash];\n    });\n  }\n\n  return {\n    tree: result,\n    revs: stemmedRevs ? Object.keys(stemmedRevs) : []\n  };\n}\n\nfunction merge(tree, path, depth) {\n  var newTree = doMerge(tree, path);\n  var stemmed = stem(newTree.tree, depth);\n  return {\n    tree: stemmed.tree,\n    stemmedRevs: stemmed.revs,\n    conflicts: newTree.conflicts\n  };\n}\n\n// return true if a rev exists in the rev tree, false otherwise\nfunction revExists(revs, rev) {\n  var toVisit = revs.slice();\n  var splitRev = rev.split('-');\n  var targetPos = parseInt(splitRev[0], 10);\n  var targetId = splitRev[1];\n\n  var node;\n  while ((node = toVisit.pop())) {\n    if (node.pos === targetPos && node.ids[0] === targetId) {\n      return true;\n    }\n    var branches = node.ids[2];\n    for (var i = 0, len = branches.length; i < len; i++) {\n      toVisit.push({pos: node.pos + 1, ids: branches[i]});\n    }\n  }\n  return false;\n}\n\nfunction getTrees(node) {\n  return node.ids;\n}\n\n// check if a specific revision of a doc has been deleted\n//  - metadata: the metadata object from the doc store\n//  - rev: (optional) the revision to check. defaults to winning revision\nfunction isDeleted(metadata, rev) {\n  if (!rev) {\n    rev = winningRev(metadata);\n  }\n  var id = rev.substring(rev.indexOf('-') + 1);\n  var toVisit = metadata.rev_tree.map(getTrees);\n\n  var tree;\n  while ((tree = toVisit.pop())) {\n    if (tree[0] === id) {\n      return !!tree[1].deleted;\n    }\n    toVisit = toVisit.concat(tree[2]);\n  }\n}\n\nfunction isLocalId(id) {\n  return (/^_local/).test(id);\n}\n\n// returns the current leaf node for a given revision\nfunction latest(rev, metadata) {\n  var toVisit = metadata.rev_tree.slice();\n  var node;\n  while ((node = toVisit.pop())) {\n    var pos = node.pos;\n    var tree = node.ids;\n    var id = tree[0];\n    var opts = tree[1];\n    var branches = tree[2];\n    var isLeaf = branches.length === 0;\n\n    var history = node.history ? node.history.slice() : [];\n    history.push({id: id, pos: pos, opts: opts});\n\n    if (isLeaf) {\n      for (var i = 0, len = history.length; i < len; i++) {\n        var historyNode = history[i];\n        var historyRev = historyNode.pos + '-' + historyNode.id;\n\n        if (historyRev === rev) {\n          // return the rev of this leaf\n          return pos + '-' + id;\n        }\n      }\n    }\n\n    for (var j = 0, l = branches.length; j < l; j++) {\n      toVisit.push({pos: pos + 1, ids: branches[j], history: history});\n    }\n  }\n\n  /* istanbul ignore next */\n  throw new Error('Unable to resolve latest revision for id ' + metadata.id + ', rev ' + rev);\n}\n\ninherits(Changes$1, EventEmitter);\n\nfunction tryCatchInChangeListener(self, change, pending, lastSeq) {\n  // isolate try/catches to avoid V8 deoptimizations\n  try {\n    self.emit('change', change, pending, lastSeq);\n  } catch (e) {\n    guardedConsole('error', 'Error in .on(\"change\", function):', e);\n  }\n}\n\nfunction Changes$1(db, opts, callback) {\n  EventEmitter.call(this);\n  var self = this;\n  this.db = db;\n  opts = opts ? clone(opts) : {};\n  var complete = opts.complete = once(function (err, resp) {\n    if (err) {\n      if (listenerCount(self, 'error') > 0) {\n        self.emit('error', err);\n      }\n    } else {\n      self.emit('complete', resp);\n    }\n    self.removeAllListeners();\n    db.removeListener('destroyed', onDestroy);\n  });\n  if (callback) {\n    self.on('complete', function (resp) {\n      callback(null, resp);\n    });\n    self.on('error', callback);\n  }\n  function onDestroy() {\n    self.cancel();\n  }\n  db.once('destroyed', onDestroy);\n\n  opts.onChange = function (change, pending, lastSeq) {\n    /* istanbul ignore if */\n    if (self.isCancelled) {\n      return;\n    }\n    tryCatchInChangeListener(self, change, pending, lastSeq);\n  };\n\n  var promise = new Promise(function (fulfill, reject) {\n    opts.complete = function (err, res) {\n      if (err) {\n        reject(err);\n      } else {\n        fulfill(res);\n      }\n    };\n  });\n  self.once('cancel', function () {\n    db.removeListener('destroyed', onDestroy);\n    opts.complete(null, {status: 'cancelled'});\n  });\n  this.then = promise.then.bind(promise);\n  this['catch'] = promise['catch'].bind(promise);\n  this.then(function (result) {\n    complete(null, result);\n  }, complete);\n\n\n\n  if (!db.taskqueue.isReady) {\n    db.taskqueue.addTask(function (failed) {\n      if (failed) {\n        opts.complete(failed);\n      } else if (self.isCancelled) {\n        self.emit('cancel');\n      } else {\n        self.validateChanges(opts);\n      }\n    });\n  } else {\n    self.validateChanges(opts);\n  }\n}\nChanges$1.prototype.cancel = function () {\n  this.isCancelled = true;\n  if (this.db.taskqueue.isReady) {\n    this.emit('cancel');\n  }\n};\nfunction processChange(doc, metadata, opts) {\n  var changeList = [{rev: doc._rev}];\n  if (opts.style === 'all_docs') {\n    changeList = collectLeaves(metadata.rev_tree)\n    .map(function (x) { return {rev: x.rev}; });\n  }\n  var change = {\n    id: metadata.id,\n    changes: changeList,\n    doc: doc\n  };\n\n  if (isDeleted(metadata, doc._rev)) {\n    change.deleted = true;\n  }\n  if (opts.conflicts) {\n    change.doc._conflicts = collectConflicts(metadata);\n    if (!change.doc._conflicts.length) {\n      delete change.doc._conflicts;\n    }\n  }\n  return change;\n}\n\nChanges$1.prototype.validateChanges = function (opts) {\n  var callback = opts.complete;\n  var self = this;\n\n  /* istanbul ignore else */\n  if (PouchDB._changesFilterPlugin) {\n    PouchDB._changesFilterPlugin.validate(opts, function (err) {\n      if (err) {\n        return callback(err);\n      }\n      self.doChanges(opts);\n    });\n  } else {\n    self.doChanges(opts);\n  }\n};\n\nChanges$1.prototype.doChanges = function (opts) {\n  var self = this;\n  var callback = opts.complete;\n\n  opts = clone(opts);\n  if ('live' in opts && !('continuous' in opts)) {\n    opts.continuous = opts.live;\n  }\n  opts.processChange = processChange;\n\n  if (opts.since === 'latest') {\n    opts.since = 'now';\n  }\n  if (!opts.since) {\n    opts.since = 0;\n  }\n  if (opts.since === 'now') {\n    this.db.info().then(function (info) {\n      /* istanbul ignore if */\n      if (self.isCancelled) {\n        callback(null, {status: 'cancelled'});\n        return;\n      }\n      opts.since = info.update_seq;\n      self.doChanges(opts);\n    }, callback);\n    return;\n  }\n\n  /* istanbul ignore else */\n  if (PouchDB._changesFilterPlugin) {\n    PouchDB._changesFilterPlugin.normalize(opts);\n    if (PouchDB._changesFilterPlugin.shouldFilter(this, opts)) {\n      return PouchDB._changesFilterPlugin.filter(this, opts);\n    }\n  } else {\n    ['doc_ids', 'filter', 'selector', 'view'].forEach(function (key) {\n      if (key in opts) {\n        guardedConsole('warn',\n          'The \"' + key + '\" option was passed in to changes/replicate, ' +\n          'but pouchdb-changes-filter plugin is not installed, so it ' +\n          'was ignored. Please install the plugin to enable filtering.'\n        );\n      }\n    });\n  }\n\n  if (!('descending' in opts)) {\n    opts.descending = false;\n  }\n\n  // 0 and 1 should return 1 document\n  opts.limit = opts.limit === 0 ? 1 : opts.limit;\n  opts.complete = callback;\n  var newPromise = this.db._changes(opts);\n  /* istanbul ignore else */\n  if (newPromise && typeof newPromise.cancel === 'function') {\n    var cancel = self.cancel;\n    self.cancel = getArguments(function (args) {\n      newPromise.cancel();\n      cancel.apply(this, args);\n    });\n  }\n};\n\n/*\n * A generic pouch adapter\n */\n\nfunction compare(left, right) {\n  return left < right ? -1 : left > right ? 1 : 0;\n}\n\n// Wrapper for functions that call the bulkdocs api with a single doc,\n// if the first result is an error, return an error\nfunction yankError(callback, docId) {\n  return function (err, results) {\n    if (err || (results[0] && results[0].error)) {\n      err = err || results[0];\n      err.docId = docId;\n      callback(err);\n    } else {\n      callback(null, results.length ? results[0]  : results);\n    }\n  };\n}\n\n// clean docs given to us by the user\nfunction cleanDocs(docs) {\n  for (var i = 0; i < docs.length; i++) {\n    var doc = docs[i];\n    if (doc._deleted) {\n      delete doc._attachments; // ignore atts for deleted docs\n    } else if (doc._attachments) {\n      // filter out extraneous keys from _attachments\n      var atts = Object.keys(doc._attachments);\n      for (var j = 0; j < atts.length; j++) {\n        var att = atts[j];\n        doc._attachments[att] = pick(doc._attachments[att],\n          ['data', 'digest', 'content_type', 'length', 'revpos', 'stub']);\n      }\n    }\n  }\n}\n\n// compare two docs, first by _id then by _rev\nfunction compareByIdThenRev(a, b) {\n  var idCompare = compare(a._id, b._id);\n  if (idCompare !== 0) {\n    return idCompare;\n  }\n  var aStart = a._revisions ? a._revisions.start : 0;\n  var bStart = b._revisions ? b._revisions.start : 0;\n  return compare(aStart, bStart);\n}\n\n// for every node in a revision tree computes its distance from the closest\n// leaf\nfunction computeHeight(revs) {\n  var height = {};\n  var edges = [];\n  traverseRevTree(revs, function (isLeaf, pos, id, prnt) {\n    var rev = pos + \"-\" + id;\n    if (isLeaf) {\n      height[rev] = 0;\n    }\n    if (prnt !== undefined) {\n      edges.push({from: prnt, to: rev});\n    }\n    return rev;\n  });\n\n  edges.reverse();\n  edges.forEach(function (edge) {\n    if (height[edge.from] === undefined) {\n      height[edge.from] = 1 + height[edge.to];\n    } else {\n      height[edge.from] = Math.min(height[edge.from], 1 + height[edge.to]);\n    }\n  });\n  return height;\n}\n\nfunction allDocsKeysParse(opts) {\n  var keys =  ('limit' in opts) ?\n    opts.keys.slice(opts.skip, opts.limit + opts.skip) :\n    (opts.skip > 0) ? opts.keys.slice(opts.skip) : opts.keys;\n  opts.keys = keys;\n  opts.skip = 0;\n  delete opts.limit;\n  if (opts.descending) {\n    keys.reverse();\n    opts.descending = false;\n  }\n}\n\n// all compaction is done in a queue, to avoid attaching\n// too many listeners at once\nfunction doNextCompaction(self) {\n  var task = self._compactionQueue[0];\n  var opts = task.opts;\n  var callback = task.callback;\n  self.get('_local/compaction').catch(function () {\n    return false;\n  }).then(function (doc) {\n    if (doc && doc.last_seq) {\n      opts.last_seq = doc.last_seq;\n    }\n    self._compact(opts, function (err, res) {\n      /* istanbul ignore if */\n      if (err) {\n        callback(err);\n      } else {\n        callback(null, res);\n      }\n      nextTick(function () {\n        self._compactionQueue.shift();\n        if (self._compactionQueue.length) {\n          doNextCompaction(self);\n        }\n      });\n    });\n  });\n}\n\nfunction attachmentNameError(name) {\n  if (name.charAt(0) === '_') {\n    return name + ' is not a valid attachment name, attachment ' +\n      'names cannot start with \\'_\\'';\n  }\n  return false;\n}\n\ninherits(AbstractPouchDB, EventEmitter);\n\nfunction AbstractPouchDB() {\n  EventEmitter.call(this);\n\n  // re-bind prototyped methods\n  for (var p in AbstractPouchDB.prototype) {\n    if (typeof this[p] === 'function') {\n      this[p] = this[p].bind(this);\n    }\n  }\n}\n\nAbstractPouchDB.prototype.post =\n  adapterFun('post', function (doc, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  if (typeof doc !== 'object' || Array.isArray(doc)) {\n    return callback(createError(NOT_AN_OBJECT));\n  }\n  this.bulkDocs({docs: [doc]}, opts, yankError(callback, doc._id));\n});\n\nAbstractPouchDB.prototype.put = adapterFun('put', function (doc, opts, cb) {\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n  if (typeof doc !== 'object' || Array.isArray(doc)) {\n    return cb(createError(NOT_AN_OBJECT));\n  }\n  invalidIdError(doc._id);\n  if (isLocalId(doc._id) && typeof this._putLocal === 'function') {\n    if (doc._deleted) {\n      return this._removeLocal(doc, cb);\n    } else {\n      return this._putLocal(doc, cb);\n    }\n  }\n  var self = this;\n  if (opts.force && doc._rev) {\n    transformForceOptionToNewEditsOption();\n    putDoc(function (err) {\n      var result = err ? null : {ok: true, id: doc._id, rev: doc._rev};\n      cb(err, result);\n    });\n  } else {\n    putDoc(cb);\n  }\n\n  function transformForceOptionToNewEditsOption() {\n    var parts = doc._rev.split('-');\n    var oldRevId = parts[1];\n    var oldRevNum = parseInt(parts[0], 10);\n\n    var newRevNum = oldRevNum + 1;\n    var newRevId = rev$$1();\n\n    doc._revisions = {\n      start: newRevNum,\n      ids: [newRevId, oldRevId]\n    };\n    doc._rev = newRevNum + '-' + newRevId;\n    opts.new_edits = false;\n  }\n  function putDoc(next) {\n    if (typeof self._put === 'function' && opts.new_edits !== false) {\n      self._put(doc, opts, next);\n    } else {\n      self.bulkDocs({docs: [doc]}, opts, yankError(next, doc._id));\n    }\n  }\n});\n\nAbstractPouchDB.prototype.putAttachment =\n  adapterFun('putAttachment', function (docId, attachmentId, rev,\n                                              blob, type) {\n  var api = this;\n  if (typeof type === 'function') {\n    type = blob;\n    blob = rev;\n    rev = null;\n  }\n  // Lets fix in https://github.com/pouchdb/pouchdb/issues/3267\n  /* istanbul ignore if */\n  if (typeof type === 'undefined') {\n    type = blob;\n    blob = rev;\n    rev = null;\n  }\n  if (!type) {\n    guardedConsole('warn', 'Attachment', attachmentId, 'on document', docId, 'is missing content_type');\n  }\n\n  function createAttachment(doc) {\n    var prevrevpos = '_rev' in doc ? parseInt(doc._rev, 10) : 0;\n    doc._attachments = doc._attachments || {};\n    doc._attachments[attachmentId] = {\n      content_type: type,\n      data: blob,\n      revpos: ++prevrevpos\n    };\n    return api.put(doc);\n  }\n\n  return api.get(docId).then(function (doc) {\n    if (doc._rev !== rev) {\n      throw createError(REV_CONFLICT);\n    }\n\n    return createAttachment(doc);\n  }, function (err) {\n     // create new doc\n    /* istanbul ignore else */\n    if (err.reason === MISSING_DOC.message) {\n      return createAttachment({_id: docId});\n    } else {\n      throw err;\n    }\n  });\n});\n\nAbstractPouchDB.prototype.removeAttachment =\n  adapterFun('removeAttachment', function (docId, attachmentId, rev,\n                                                 callback) {\n  var self = this;\n  self.get(docId, function (err, obj) {\n    /* istanbul ignore if */\n    if (err) {\n      callback(err);\n      return;\n    }\n    if (obj._rev !== rev) {\n      callback(createError(REV_CONFLICT));\n      return;\n    }\n    /* istanbul ignore if */\n    if (!obj._attachments) {\n      return callback();\n    }\n    delete obj._attachments[attachmentId];\n    if (Object.keys(obj._attachments).length === 0) {\n      delete obj._attachments;\n    }\n    self.put(obj, callback);\n  });\n});\n\nAbstractPouchDB.prototype.remove =\n  adapterFun('remove', function (docOrId, optsOrRev, opts, callback) {\n  var doc;\n  if (typeof optsOrRev === 'string') {\n    // id, rev, opts, callback style\n    doc = {\n      _id: docOrId,\n      _rev: optsOrRev\n    };\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n  } else {\n    // doc, opts, callback style\n    doc = docOrId;\n    if (typeof optsOrRev === 'function') {\n      callback = optsOrRev;\n      opts = {};\n    } else {\n      callback = opts;\n      opts = optsOrRev;\n    }\n  }\n  opts = opts || {};\n  opts.was_delete = true;\n  var newDoc = {_id: doc._id, _rev: (doc._rev || opts.rev)};\n  newDoc._deleted = true;\n  if (isLocalId(newDoc._id) && typeof this._removeLocal === 'function') {\n    return this._removeLocal(doc, callback);\n  }\n  this.bulkDocs({docs: [newDoc]}, opts, yankError(callback, newDoc._id));\n});\n\nAbstractPouchDB.prototype.revsDiff =\n  adapterFun('revsDiff', function (req, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  var ids = Object.keys(req);\n\n  if (!ids.length) {\n    return callback(null, {});\n  }\n\n  var count = 0;\n  var missing = new ExportedMap();\n\n  function addToMissing(id, revId) {\n    if (!missing.has(id)) {\n      missing.set(id, {missing: []});\n    }\n    missing.get(id).missing.push(revId);\n  }\n\n  function processDoc(id, rev_tree) {\n    // Is this fast enough? Maybe we should switch to a set simulated by a map\n    var missingForId = req[id].slice(0);\n    traverseRevTree(rev_tree, function (isLeaf, pos, revHash, ctx,\n      opts) {\n        var rev = pos + '-' + revHash;\n        var idx = missingForId.indexOf(rev);\n        if (idx === -1) {\n          return;\n        }\n\n        missingForId.splice(idx, 1);\n        /* istanbul ignore if */\n        if (opts.status !== 'available') {\n          addToMissing(id, rev);\n        }\n      });\n\n    // Traversing the tree is synchronous, so now `missingForId` contains\n    // revisions that were not found in the tree\n    missingForId.forEach(function (rev) {\n      addToMissing(id, rev);\n    });\n  }\n\n  ids.map(function (id) {\n    this._getRevisionTree(id, function (err, rev_tree) {\n      if (err && err.status === 404 && err.message === 'missing') {\n        missing.set(id, {missing: req[id]});\n      } else if (err) {\n        /* istanbul ignore next */\n        return callback(err);\n      } else {\n        processDoc(id, rev_tree);\n      }\n\n      if (++count === ids.length) {\n        // convert LazyMap to object\n        var missingObj = {};\n        missing.forEach(function (value, key) {\n          missingObj[key] = value;\n        });\n        return callback(null, missingObj);\n      }\n    });\n  }, this);\n});\n\n// _bulk_get API for faster replication, as described in\n// https://github.com/apache/couchdb-chttpd/pull/33\n// At the \"abstract\" level, it will just run multiple get()s in\n// parallel, because this isn't much of a performance cost\n// for local databases (except the cost of multiple transactions, which is\n// small). The http adapter overrides this in order\n// to do a more efficient single HTTP request.\nAbstractPouchDB.prototype.bulkGet =\n  adapterFun('bulkGet', function (opts, callback) {\n  bulkGet(this, opts, callback);\n});\n\n// compact one document and fire callback\n// by compacting we mean removing all revisions which\n// are further from the leaf in revision tree than max_height\nAbstractPouchDB.prototype.compactDocument =\n  adapterFun('compactDocument', function (docId, maxHeight, callback) {\n  var self = this;\n  this._getRevisionTree(docId, function (err, revTree) {\n    /* istanbul ignore if */\n    if (err) {\n      return callback(err);\n    }\n    var height = computeHeight(revTree);\n    var candidates = [];\n    var revs = [];\n    Object.keys(height).forEach(function (rev) {\n      if (height[rev] > maxHeight) {\n        candidates.push(rev);\n      }\n    });\n\n    traverseRevTree(revTree, function (isLeaf, pos, revHash, ctx, opts) {\n      var rev = pos + '-' + revHash;\n      if (opts.status === 'available' && candidates.indexOf(rev) !== -1) {\n        revs.push(rev);\n      }\n    });\n    self._doCompaction(docId, revs, callback);\n  });\n});\n\n// compact the whole database using single document\n// compaction\nAbstractPouchDB.prototype.compact =\n  adapterFun('compact', function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  var self = this;\n  opts = opts || {};\n\n  self._compactionQueue = self._compactionQueue || [];\n  self._compactionQueue.push({opts: opts, callback: callback});\n  if (self._compactionQueue.length === 1) {\n    doNextCompaction(self);\n  }\n});\nAbstractPouchDB.prototype._compact = function (opts, callback) {\n  var self = this;\n  var changesOpts = {\n    return_docs: false,\n    last_seq: opts.last_seq || 0\n  };\n  var promises = [];\n\n  function onChange(row) {\n    promises.push(self.compactDocument(row.id, 0));\n  }\n  function onComplete(resp) {\n    var lastSeq = resp.last_seq;\n    Promise.all(promises).then(function () {\n      return upsert(self, '_local/compaction', function deltaFunc(doc) {\n        if (!doc.last_seq || doc.last_seq < lastSeq) {\n          doc.last_seq = lastSeq;\n          return doc;\n        }\n        return false; // somebody else got here first, don't update\n      });\n    }).then(function () {\n      callback(null, {ok: true});\n    }).catch(callback);\n  }\n  self.changes(changesOpts)\n    .on('change', onChange)\n    .on('complete', onComplete)\n    .on('error', callback);\n};\n\n/* Begin api wrappers. Specific functionality to storage belongs in the\n   _[method] */\nAbstractPouchDB.prototype.get = adapterFun('get', function (id, opts, cb) {\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n  if (typeof id !== 'string') {\n    return cb(createError(INVALID_ID));\n  }\n  if (isLocalId(id) && typeof this._getLocal === 'function') {\n    return this._getLocal(id, cb);\n  }\n  var leaves = [], self = this;\n\n  function finishOpenRevs() {\n    var result = [];\n    var count = leaves.length;\n    /* istanbul ignore if */\n    if (!count) {\n      return cb(null, result);\n    }\n\n    // order with open_revs is unspecified\n    leaves.forEach(function (leaf) {\n      self.get(id, {\n        rev: leaf,\n        revs: opts.revs,\n        latest: opts.latest,\n        attachments: opts.attachments,\n        binary: opts.binary\n      }, function (err, doc) {\n        if (!err) {\n          // using latest=true can produce duplicates\n          var existing;\n          for (var i = 0, l = result.length; i < l; i++) {\n            if (result[i].ok && result[i].ok._rev === doc._rev) {\n              existing = true;\n              break;\n            }\n          }\n          if (!existing) {\n            result.push({ok: doc});\n          }\n        } else {\n          result.push({missing: leaf});\n        }\n        count--;\n        if (!count) {\n          cb(null, result);\n        }\n      });\n    });\n  }\n\n  if (opts.open_revs) {\n    if (opts.open_revs === \"all\") {\n      this._getRevisionTree(id, function (err, rev_tree) {\n        /* istanbul ignore if */\n        if (err) {\n          return cb(err);\n        }\n        leaves = collectLeaves(rev_tree).map(function (leaf) {\n          return leaf.rev;\n        });\n        finishOpenRevs();\n      });\n    } else {\n      if (Array.isArray(opts.open_revs)) {\n        leaves = opts.open_revs;\n        for (var i = 0; i < leaves.length; i++) {\n          var l = leaves[i];\n          // looks like it's the only thing couchdb checks\n          if (!(typeof (l) === \"string\" && /^\\d+-/.test(l))) {\n            return cb(createError(INVALID_REV));\n          }\n        }\n        finishOpenRevs();\n      } else {\n        return cb(createError(UNKNOWN_ERROR, 'function_clause'));\n      }\n    }\n    return; // open_revs does not like other options\n  }\n\n  return this._get(id, opts, function (err, result) {\n    if (err) {\n      err.docId = id;\n      return cb(err);\n    }\n\n    var doc = result.doc;\n    var metadata = result.metadata;\n    var ctx = result.ctx;\n\n    if (opts.conflicts) {\n      var conflicts = collectConflicts(metadata);\n      if (conflicts.length) {\n        doc._conflicts = conflicts;\n      }\n    }\n\n    if (isDeleted(metadata, doc._rev)) {\n      doc._deleted = true;\n    }\n\n    if (opts.revs || opts.revs_info) {\n      var splittedRev = doc._rev.split('-');\n      var revNo       = parseInt(splittedRev[0], 10);\n      var revHash     = splittedRev[1];\n\n      var paths = rootToLeaf(metadata.rev_tree);\n      var path = null;\n\n      for (var i = 0; i < paths.length; i++) {\n        var currentPath = paths[i];\n        var hashIndex = currentPath.ids.map(function (x) { return x.id; })\n          .indexOf(revHash);\n        var hashFoundAtRevPos = hashIndex === (revNo - 1);\n\n        if (hashFoundAtRevPos || (!path && hashIndex !== -1)) {\n          path = currentPath;\n        }\n      }\n\n      var indexOfRev = path.ids.map(function (x) { return x.id; })\n        .indexOf(doc._rev.split('-')[1]) + 1;\n      var howMany = path.ids.length - indexOfRev;\n      path.ids.splice(indexOfRev, howMany);\n      path.ids.reverse();\n\n      if (opts.revs) {\n        doc._revisions = {\n          start: (path.pos + path.ids.length) - 1,\n          ids: path.ids.map(function (rev) {\n            return rev.id;\n          })\n        };\n      }\n      if (opts.revs_info) {\n        var pos =  path.pos + path.ids.length;\n        doc._revs_info = path.ids.map(function (rev) {\n          pos--;\n          return {\n            rev: pos + '-' + rev.id,\n            status: rev.opts.status\n          };\n        });\n      }\n    }\n\n    if (opts.attachments && doc._attachments) {\n      var attachments = doc._attachments;\n      var count = Object.keys(attachments).length;\n      if (count === 0) {\n        return cb(null, doc);\n      }\n      Object.keys(attachments).forEach(function (key) {\n        this._getAttachment(doc._id, key, attachments[key], {\n          // Previously the revision handling was done in adapter.js\n          // getAttachment, however since idb-next doesnt we need to\n          // pass the rev through\n          rev: doc._rev,\n          binary: opts.binary,\n          ctx: ctx\n        }, function (err, data) {\n          var att = doc._attachments[key];\n          att.data = data;\n          delete att.stub;\n          delete att.length;\n          if (!--count) {\n            cb(null, doc);\n          }\n        });\n      }, self);\n    } else {\n      if (doc._attachments) {\n        for (var key in doc._attachments) {\n          /* istanbul ignore else */\n          if (doc._attachments.hasOwnProperty(key)) {\n            doc._attachments[key].stub = true;\n          }\n        }\n      }\n      cb(null, doc);\n    }\n  });\n});\n\n// TODO: I dont like this, it forces an extra read for every\n// attachment read and enforces a confusing api between\n// adapter.js and the adapter implementation\nAbstractPouchDB.prototype.getAttachment =\n  adapterFun('getAttachment', function (docId, attachmentId, opts, callback) {\n  var self = this;\n  if (opts instanceof Function) {\n    callback = opts;\n    opts = {};\n  }\n  this._get(docId, opts, function (err, res) {\n    if (err) {\n      return callback(err);\n    }\n    if (res.doc._attachments && res.doc._attachments[attachmentId]) {\n      opts.ctx = res.ctx;\n      opts.binary = true;\n      self._getAttachment(docId, attachmentId,\n                          res.doc._attachments[attachmentId], opts, callback);\n    } else {\n      return callback(createError(MISSING_DOC));\n    }\n  });\n});\n\nAbstractPouchDB.prototype.allDocs =\n  adapterFun('allDocs', function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  opts.skip = typeof opts.skip !== 'undefined' ? opts.skip : 0;\n  if (opts.start_key) {\n    opts.startkey = opts.start_key;\n  }\n  if (opts.end_key) {\n    opts.endkey = opts.end_key;\n  }\n  if ('keys' in opts) {\n    if (!Array.isArray(opts.keys)) {\n      return callback(new TypeError('options.keys must be an array'));\n    }\n    var incompatibleOpt =\n      ['startkey', 'endkey', 'key'].filter(function (incompatibleOpt) {\n      return incompatibleOpt in opts;\n    })[0];\n    if (incompatibleOpt) {\n      callback(createError(QUERY_PARSE_ERROR,\n        'Query parameter `' + incompatibleOpt +\n        '` is not compatible with multi-get'\n      ));\n      return;\n    }\n    if (!isRemote(this)) {\n      allDocsKeysParse(opts);\n      if (opts.keys.length === 0) {\n        return this._allDocs({limit: 0}, callback);\n      }\n    }\n  }\n\n  return this._allDocs(opts, callback);\n});\n\nAbstractPouchDB.prototype.changes = function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  opts = opts || {};\n\n  // By default set return_docs to false if the caller has opts.live = true,\n  // this will prevent us from collecting the set of changes indefinitely\n  // resulting in growing memory\n  opts.return_docs = ('return_docs' in opts) ? opts.return_docs : !opts.live;\n\n  return new Changes$1(this, opts, callback);\n};\n\nAbstractPouchDB.prototype.close = adapterFun('close', function (callback) {\n  this._closed = true;\n  this.emit('closed');\n  return this._close(callback);\n});\n\nAbstractPouchDB.prototype.info = adapterFun('info', function (callback) {\n  var self = this;\n  this._info(function (err, info) {\n    if (err) {\n      return callback(err);\n    }\n    // assume we know better than the adapter, unless it informs us\n    info.db_name = info.db_name || self.name;\n    info.auto_compaction = !!(self.auto_compaction && !isRemote(self));\n    info.adapter = self.adapter;\n    callback(null, info);\n  });\n});\n\nAbstractPouchDB.prototype.id = adapterFun('id', function (callback) {\n  return this._id(callback);\n});\n\n/* istanbul ignore next */\nAbstractPouchDB.prototype.type = function () {\n  return (typeof this._type === 'function') ? this._type() : this.adapter;\n};\n\nAbstractPouchDB.prototype.bulkDocs =\n  adapterFun('bulkDocs', function (req, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  opts = opts || {};\n\n  if (Array.isArray(req)) {\n    req = {\n      docs: req\n    };\n  }\n\n  if (!req || !req.docs || !Array.isArray(req.docs)) {\n    return callback(createError(MISSING_BULK_DOCS));\n  }\n\n  for (var i = 0; i < req.docs.length; ++i) {\n    if (typeof req.docs[i] !== 'object' || Array.isArray(req.docs[i])) {\n      return callback(createError(NOT_AN_OBJECT));\n    }\n  }\n\n  var attachmentError;\n  req.docs.forEach(function (doc) {\n    if (doc._attachments) {\n      Object.keys(doc._attachments).forEach(function (name) {\n        attachmentError = attachmentError || attachmentNameError(name);\n        if (!doc._attachments[name].content_type) {\n          guardedConsole('warn', 'Attachment', name, 'on document', doc._id, 'is missing content_type');\n        }\n      });\n    }\n  });\n\n  if (attachmentError) {\n    return callback(createError(BAD_REQUEST, attachmentError));\n  }\n\n  if (!('new_edits' in opts)) {\n    if ('new_edits' in req) {\n      opts.new_edits = req.new_edits;\n    } else {\n      opts.new_edits = true;\n    }\n  }\n\n  var adapter = this;\n  if (!opts.new_edits && !isRemote(adapter)) {\n    // ensure revisions of the same doc are sorted, so that\n    // the local adapter processes them correctly (#2935)\n    req.docs.sort(compareByIdThenRev);\n  }\n\n  cleanDocs(req.docs);\n\n  // in the case of conflicts, we want to return the _ids to the user\n  // however, the underlying adapter may destroy the docs array, so\n  // create a copy here\n  var ids = req.docs.map(function (doc) {\n    return doc._id;\n  });\n\n  return this._bulkDocs(req, opts, function (err, res) {\n    if (err) {\n      return callback(err);\n    }\n    if (!opts.new_edits) {\n      // this is what couch does when new_edits is false\n      res = res.filter(function (x) {\n        return x.error;\n      });\n    }\n    // add ids for error/conflict responses (not required for CouchDB)\n    if (!isRemote(adapter)) {\n      for (var i = 0, l = res.length; i < l; i++) {\n        res[i].id = res[i].id || ids[i];\n      }\n    }\n\n    callback(null, res);\n  });\n});\n\nAbstractPouchDB.prototype.registerDependentDatabase =\n  adapterFun('registerDependentDatabase', function (dependentDb,\n                                                          callback) {\n  var depDB = new this.constructor(dependentDb, this.__opts);\n\n  function diffFun(doc) {\n    doc.dependentDbs = doc.dependentDbs || {};\n    if (doc.dependentDbs[dependentDb]) {\n      return false; // no update required\n    }\n    doc.dependentDbs[dependentDb] = true;\n    return doc;\n  }\n  upsert(this, '_local/_pouch_dependentDbs', diffFun)\n    .then(function () {\n      callback(null, {db: depDB});\n    }).catch(callback);\n});\n\nAbstractPouchDB.prototype.destroy =\n  adapterFun('destroy', function (opts, callback) {\n\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  var self = this;\n  var usePrefix = 'use_prefix' in self ? self.use_prefix : true;\n\n  function destroyDb() {\n    // call destroy method of the particular adaptor\n    self._destroy(opts, function (err, resp) {\n      if (err) {\n        return callback(err);\n      }\n      self._destroyed = true;\n      self.emit('destroyed');\n      callback(null, resp || { 'ok': true });\n    });\n  }\n\n  if (isRemote(self)) {\n    // no need to check for dependent DBs if it's a remote DB\n    return destroyDb();\n  }\n\n  self.get('_local/_pouch_dependentDbs', function (err, localDoc) {\n    if (err) {\n      /* istanbul ignore if */\n      if (err.status !== 404) {\n        return callback(err);\n      } else { // no dependencies\n        return destroyDb();\n      }\n    }\n    var dependentDbs = localDoc.dependentDbs;\n    var PouchDB = self.constructor;\n    var deletedMap = Object.keys(dependentDbs).map(function (name) {\n      // use_prefix is only false in the browser\n      /* istanbul ignore next */\n      var trueName = usePrefix ?\n        name.replace(new RegExp('^' + PouchDB.prefix), '') : name;\n      return new PouchDB(trueName, self.__opts).destroy();\n    });\n    Promise.all(deletedMap).then(destroyDb, callback);\n  });\n});\n\nfunction TaskQueue() {\n  this.isReady = false;\n  this.failed = false;\n  this.queue = [];\n}\n\nTaskQueue.prototype.execute = function () {\n  var fun;\n  if (this.failed) {\n    while ((fun = this.queue.shift())) {\n      fun(this.failed);\n    }\n  } else {\n    while ((fun = this.queue.shift())) {\n      fun();\n    }\n  }\n};\n\nTaskQueue.prototype.fail = function (err) {\n  this.failed = err;\n  this.execute();\n};\n\nTaskQueue.prototype.ready = function (db) {\n  this.isReady = true;\n  this.db = db;\n  this.execute();\n};\n\nTaskQueue.prototype.addTask = function (fun) {\n  this.queue.push(fun);\n  if (this.failed) {\n    this.execute();\n  }\n};\n\nfunction parseAdapter(name, opts) {\n  var match = name.match(/([a-z-]*):\\/\\/(.*)/);\n  if (match) {\n    // the http adapter expects the fully qualified name\n    return {\n      name: /https?/.test(match[1]) ? match[1] + '://' + match[2] : match[2],\n      adapter: match[1]\n    };\n  }\n\n  var adapters = PouchDB.adapters;\n  var preferredAdapters = PouchDB.preferredAdapters;\n  var prefix = PouchDB.prefix;\n  var adapterName = opts.adapter;\n\n  if (!adapterName) { // automatically determine adapter\n    for (var i = 0; i < preferredAdapters.length; ++i) {\n      adapterName = preferredAdapters[i];\n      // check for browsers that have been upgraded from websql-only to websql+idb\n      /* istanbul ignore if */\n      if (adapterName === 'idb' && 'websql' in adapters &&\n          hasLocalStorage() && localStorage['_pouch__websqldb_' + prefix + name]) {\n        // log it, because this can be confusing during development\n        guardedConsole('log', 'PouchDB is downgrading \"' + name + '\" to WebSQL to' +\n          ' avoid data loss, because it was already opened with WebSQL.');\n        continue; // keep using websql to avoid user data loss\n      }\n      break;\n    }\n  }\n\n  var adapter = adapters[adapterName];\n\n  // if adapter is invalid, then an error will be thrown later\n  var usePrefix = (adapter && 'use_prefix' in adapter) ?\n    adapter.use_prefix : true;\n\n  return {\n    name: usePrefix ? (prefix + name) : name,\n    adapter: adapterName\n  };\n}\n\n// OK, so here's the deal. Consider this code:\n//     var db1 = new PouchDB('foo');\n//     var db2 = new PouchDB('foo');\n//     db1.destroy();\n// ^ these two both need to emit 'destroyed' events,\n// as well as the PouchDB constructor itself.\n// So we have one db object (whichever one got destroy() called on it)\n// responsible for emitting the initial event, which then gets emitted\n// by the constructor, which then broadcasts it to any other dbs\n// that may have been created with the same name.\nfunction prepareForDestruction(self) {\n\n  function onDestroyed(from_constructor) {\n    self.removeListener('closed', onClosed);\n    if (!from_constructor) {\n      self.constructor.emit('destroyed', self.name);\n    }\n  }\n\n  function onClosed() {\n    self.removeListener('destroyed', onDestroyed);\n    self.constructor.emit('unref', self);\n  }\n\n  self.once('destroyed', onDestroyed);\n  self.once('closed', onClosed);\n  self.constructor.emit('ref', self);\n}\n\ninherits(PouchDB, AbstractPouchDB);\nfunction PouchDB(name, opts) {\n  // In Node our test suite only tests this for PouchAlt unfortunately\n  /* istanbul ignore if */\n  if (!(this instanceof PouchDB)) {\n    return new PouchDB(name, opts);\n  }\n\n  var self = this;\n  opts = opts || {};\n\n  if (name && typeof name === 'object') {\n    opts = name;\n    name = opts.name;\n    delete opts.name;\n  }\n\n  if (opts.deterministic_revs === undefined) {\n    opts.deterministic_revs = true;\n  }\n\n  this.__opts = opts = clone(opts);\n\n  self.auto_compaction = opts.auto_compaction;\n  self.prefix = PouchDB.prefix;\n\n  if (typeof name !== 'string') {\n    throw new Error('Missing/invalid DB name');\n  }\n\n  var prefixedName = (opts.prefix || '') + name;\n  var backend = parseAdapter(prefixedName, opts);\n\n  opts.name = backend.name;\n  opts.adapter = opts.adapter || backend.adapter;\n\n  self.name = name;\n  self._adapter = opts.adapter;\n  PouchDB.emit('debug', ['adapter', 'Picked adapter: ', opts.adapter]);\n\n  if (!PouchDB.adapters[opts.adapter] ||\n      !PouchDB.adapters[opts.adapter].valid()) {\n    throw new Error('Invalid Adapter: ' + opts.adapter);\n  }\n\n  AbstractPouchDB.call(self);\n  self.taskqueue = new TaskQueue();\n\n  self.adapter = opts.adapter;\n\n  PouchDB.adapters[opts.adapter].call(self, opts, function (err) {\n    if (err) {\n      return self.taskqueue.fail(err);\n    }\n    prepareForDestruction(self);\n\n    self.emit('created', self);\n    PouchDB.emit('created', self.name);\n    self.taskqueue.ready(self);\n  });\n\n}\n\n// AbortController was introduced quite a while after fetch and\n// isnt required for PouchDB to function so polyfill if needed\nvar a = (typeof AbortController !== 'undefined')\n    ? AbortController\n    : function () { return {abort: function () {}}; };\n\nvar f$1 = fetch;\nvar h = Headers;\n\nPouchDB.adapters = {};\nPouchDB.preferredAdapters = [];\n\nPouchDB.prefix = '_pouch_';\n\nvar eventEmitter = new EventEmitter();\n\nfunction setUpEventEmitter(Pouch) {\n  Object.keys(EventEmitter.prototype).forEach(function (key) {\n    if (typeof EventEmitter.prototype[key] === 'function') {\n      Pouch[key] = eventEmitter[key].bind(eventEmitter);\n    }\n  });\n\n  // these are created in constructor.js, and allow us to notify each DB with\n  // the same name that it was destroyed, via the constructor object\n  var destructListeners = Pouch._destructionListeners = new ExportedMap();\n\n  Pouch.on('ref', function onConstructorRef(db) {\n    if (!destructListeners.has(db.name)) {\n      destructListeners.set(db.name, []);\n    }\n    destructListeners.get(db.name).push(db);\n  });\n\n  Pouch.on('unref', function onConstructorUnref(db) {\n    if (!destructListeners.has(db.name)) {\n      return;\n    }\n    var dbList = destructListeners.get(db.name);\n    var pos = dbList.indexOf(db);\n    if (pos < 0) {\n      /* istanbul ignore next */\n      return;\n    }\n    dbList.splice(pos, 1);\n    if (dbList.length > 1) {\n      /* istanbul ignore next */\n      destructListeners.set(db.name, dbList);\n    } else {\n      destructListeners.delete(db.name);\n    }\n  });\n\n  Pouch.on('destroyed', function onConstructorDestroyed(name) {\n    if (!destructListeners.has(name)) {\n      return;\n    }\n    var dbList = destructListeners.get(name);\n    destructListeners.delete(name);\n    dbList.forEach(function (db) {\n      db.emit('destroyed',true);\n    });\n  });\n}\n\nsetUpEventEmitter(PouchDB);\n\nPouchDB.adapter = function (id, obj, addToPreferredAdapters) {\n  /* istanbul ignore else */\n  if (obj.valid()) {\n    PouchDB.adapters[id] = obj;\n    if (addToPreferredAdapters) {\n      PouchDB.preferredAdapters.push(id);\n    }\n  }\n};\n\nPouchDB.plugin = function (obj) {\n  if (typeof obj === 'function') { // function style for plugins\n    obj(PouchDB);\n  } else if (typeof obj !== 'object' || Object.keys(obj).length === 0) {\n    throw new Error('Invalid plugin: got \"' + obj + '\", expected an object or a function');\n  } else {\n    Object.keys(obj).forEach(function (id) { // object style for plugins\n      PouchDB.prototype[id] = obj[id];\n    });\n  }\n  if (this.__defaults) {\n    PouchDB.__defaults = $inject_Object_assign({}, this.__defaults);\n  }\n  return PouchDB;\n};\n\nPouchDB.defaults = function (defaultOpts) {\n  function PouchAlt(name, opts) {\n    if (!(this instanceof PouchAlt)) {\n      return new PouchAlt(name, opts);\n    }\n\n    opts = opts || {};\n\n    if (name && typeof name === 'object') {\n      opts = name;\n      name = opts.name;\n      delete opts.name;\n    }\n\n    opts = $inject_Object_assign({}, PouchAlt.__defaults, opts);\n    PouchDB.call(this, name, opts);\n  }\n\n  inherits(PouchAlt, PouchDB);\n\n  PouchAlt.preferredAdapters = PouchDB.preferredAdapters.slice();\n  Object.keys(PouchDB).forEach(function (key) {\n    if (!(key in PouchAlt)) {\n      PouchAlt[key] = PouchDB[key];\n    }\n  });\n\n  // make default options transitive\n  // https://github.com/pouchdb/pouchdb/issues/5922\n  PouchAlt.__defaults = $inject_Object_assign({}, this.__defaults, defaultOpts);\n\n  return PouchAlt;\n};\n\nPouchDB.fetch = function (url, opts) {\n  return f$1(url, opts);\n};\n\n// managed automatically by set-version.js\nvar version = \"7.0.0\";\n\n// this would just be \"return doc[field]\", but fields\n// can be \"deep\" due to dot notation\nfunction getFieldFromDoc(doc, parsedField) {\n  var value = doc;\n  for (var i = 0, len = parsedField.length; i < len; i++) {\n    var key = parsedField[i];\n    value = value[key];\n    if (!value) {\n      break;\n    }\n  }\n  return value;\n}\n\nfunction compare$1(left, right) {\n  return left < right ? -1 : left > right ? 1 : 0;\n}\n\n// Converts a string in dot notation to an array of its components, with backslash escaping\nfunction parseField(fieldName) {\n  // fields may be deep (e.g. \"foo.bar.baz\"), so parse\n  var fields = [];\n  var current = '';\n  for (var i = 0, len = fieldName.length; i < len; i++) {\n    var ch = fieldName[i];\n    if (ch === '.') {\n      if (i > 0 && fieldName[i - 1] === '\\\\') { // escaped delimiter\n        current = current.substring(0, current.length - 1) + '.';\n      } else { // not escaped, so delimiter\n        fields.push(current);\n        current = '';\n      }\n    } else { // normal character\n      current += ch;\n    }\n  }\n  fields.push(current);\n  return fields;\n}\n\nvar combinationFields = ['$or', '$nor', '$not'];\nfunction isCombinationalField(field) {\n  return combinationFields.indexOf(field) > -1;\n}\n\nfunction getKey(obj) {\n  return Object.keys(obj)[0];\n}\n\nfunction getValue(obj) {\n  return obj[getKey(obj)];\n}\n\n\n// flatten an array of selectors joined by an $and operator\nfunction mergeAndedSelectors(selectors) {\n\n  // sort to ensure that e.g. if the user specified\n  // $and: [{$gt: 'a'}, {$gt: 'b'}], then it's collapsed into\n  // just {$gt: 'b'}\n  var res = {};\n\n  selectors.forEach(function (selector) {\n    Object.keys(selector).forEach(function (field) {\n      var matcher = selector[field];\n      if (typeof matcher !== 'object') {\n        matcher = {$eq: matcher};\n      }\n\n      if (isCombinationalField(field)) {\n        if (matcher instanceof Array) {\n          res[field] = matcher.map(function (m) {\n            return mergeAndedSelectors([m]);\n          });\n        } else {\n          res[field] = mergeAndedSelectors([matcher]);\n        }\n      } else {\n        var fieldMatchers = res[field] = res[field] || {};\n        Object.keys(matcher).forEach(function (operator) {\n          var value = matcher[operator];\n\n          if (operator === '$gt' || operator === '$gte') {\n            return mergeGtGte(operator, value, fieldMatchers);\n          } else if (operator === '$lt' || operator === '$lte') {\n            return mergeLtLte(operator, value, fieldMatchers);\n          } else if (operator === '$ne') {\n            return mergeNe(value, fieldMatchers);\n          } else if (operator === '$eq') {\n            return mergeEq(value, fieldMatchers);\n          }\n          fieldMatchers[operator] = value;\n        });\n      }\n    });\n  });\n\n  return res;\n}\n\n\n\n// collapse logically equivalent gt/gte values\nfunction mergeGtGte(operator, value, fieldMatchers) {\n  if (typeof fieldMatchers.$eq !== 'undefined') {\n    return; // do nothing\n  }\n  if (typeof fieldMatchers.$gte !== 'undefined') {\n    if (operator === '$gte') {\n      if (value > fieldMatchers.$gte) { // more specificity\n        fieldMatchers.$gte = value;\n      }\n    } else { // operator === '$gt'\n      if (value >= fieldMatchers.$gte) { // more specificity\n        delete fieldMatchers.$gte;\n        fieldMatchers.$gt = value;\n      }\n    }\n  } else if (typeof fieldMatchers.$gt !== 'undefined') {\n    if (operator === '$gte') {\n      if (value > fieldMatchers.$gt) { // more specificity\n        delete fieldMatchers.$gt;\n        fieldMatchers.$gte = value;\n      }\n    } else { // operator === '$gt'\n      if (value > fieldMatchers.$gt) { // more specificity\n        fieldMatchers.$gt = value;\n      }\n    }\n  } else {\n    fieldMatchers[operator] = value;\n  }\n}\n\n// collapse logically equivalent lt/lte values\nfunction mergeLtLte(operator, value, fieldMatchers) {\n  if (typeof fieldMatchers.$eq !== 'undefined') {\n    return; // do nothing\n  }\n  if (typeof fieldMatchers.$lte !== 'undefined') {\n    if (operator === '$lte') {\n      if (value < fieldMatchers.$lte) { // more specificity\n        fieldMatchers.$lte = value;\n      }\n    } else { // operator === '$gt'\n      if (value <= fieldMatchers.$lte) { // more specificity\n        delete fieldMatchers.$lte;\n        fieldMatchers.$lt = value;\n      }\n    }\n  } else if (typeof fieldMatchers.$lt !== 'undefined') {\n    if (operator === '$lte') {\n      if (value < fieldMatchers.$lt) { // more specificity\n        delete fieldMatchers.$lt;\n        fieldMatchers.$lte = value;\n      }\n    } else { // operator === '$gt'\n      if (value < fieldMatchers.$lt) { // more specificity\n        fieldMatchers.$lt = value;\n      }\n    }\n  } else {\n    fieldMatchers[operator] = value;\n  }\n}\n\n// combine $ne values into one array\nfunction mergeNe(value, fieldMatchers) {\n  if ('$ne' in fieldMatchers) {\n    // there are many things this could \"not\" be\n    fieldMatchers.$ne.push(value);\n  } else { // doesn't exist yet\n    fieldMatchers.$ne = [value];\n  }\n}\n\n// add $eq into the mix\nfunction mergeEq(value, fieldMatchers) {\n  // these all have less specificity than the $eq\n  // TODO: check for user errors here\n  delete fieldMatchers.$gt;\n  delete fieldMatchers.$gte;\n  delete fieldMatchers.$lt;\n  delete fieldMatchers.$lte;\n  delete fieldMatchers.$ne;\n  fieldMatchers.$eq = value;\n}\n\n\n//\n// normalize the selector\n//\nfunction massageSelector(input) {\n  var result = clone(input);\n  var wasAnded = false;\n  if ('$and' in result) {\n    result = mergeAndedSelectors(result['$and']);\n    wasAnded = true;\n  }\n\n  ['$or', '$nor'].forEach(function (orOrNor) {\n    if (orOrNor in result) {\n      // message each individual selector\n      // e.g. {foo: 'bar'} becomes {foo: {$eq: 'bar'}}\n      result[orOrNor].forEach(function (subSelector) {\n        var fields = Object.keys(subSelector);\n        for (var i = 0; i < fields.length; i++) {\n          var field = fields[i];\n          var matcher = subSelector[field];\n          if (typeof matcher !== 'object' || matcher === null) {\n            subSelector[field] = {$eq: matcher};\n          }\n        }\n      });\n    }\n  });\n\n  if ('$not' in result) {\n    //This feels a little like forcing, but it will work for now,\n    //I would like to come back to this and make the merging of selectors a little more generic\n    result['$not'] = mergeAndedSelectors([result['$not']]);\n  }\n\n  var fields = Object.keys(result);\n\n  for (var i = 0; i < fields.length; i++) {\n    var field = fields[i];\n    var matcher = result[field];\n\n    if (typeof matcher !== 'object' || matcher === null) {\n      matcher = {$eq: matcher};\n    } else if ('$ne' in matcher && !wasAnded) {\n      // I put these in an array, since there may be more than one\n      // but in the \"mergeAnded\" operation, I already take care of that\n      matcher.$ne = [matcher.$ne];\n    }\n    result[field] = matcher;\n  }\n\n  return result;\n}\n\nfunction pad(str, padWith, upToLength) {\n  var padding = '';\n  var targetLength = upToLength - str.length;\n  /* istanbul ignore next */\n  while (padding.length < targetLength) {\n    padding += padWith;\n  }\n  return padding;\n}\n\nfunction padLeft(str, padWith, upToLength) {\n  var padding = pad(str, padWith, upToLength);\n  return padding + str;\n}\n\nvar MIN_MAGNITUDE = -324; // verified by -Number.MIN_VALUE\nvar MAGNITUDE_DIGITS = 3; // ditto\nvar SEP = ''; // set to '_' for easier debugging \n\nfunction collate(a, b) {\n\n  if (a === b) {\n    return 0;\n  }\n\n  a = normalizeKey(a);\n  b = normalizeKey(b);\n\n  var ai = collationIndex(a);\n  var bi = collationIndex(b);\n  if ((ai - bi) !== 0) {\n    return ai - bi;\n  }\n  switch (typeof a) {\n    case 'number':\n      return a - b;\n    case 'boolean':\n      return a < b ? -1 : 1;\n    case 'string':\n      return stringCollate(a, b);\n  }\n  return Array.isArray(a) ? arrayCollate(a, b) : objectCollate(a, b);\n}\n\n// couch considers null/NaN/Infinity/-Infinity === undefined,\n// for the purposes of mapreduce indexes. also, dates get stringified.\nfunction normalizeKey(key) {\n  switch (typeof key) {\n    case 'undefined':\n      return null;\n    case 'number':\n      if (key === Infinity || key === -Infinity || isNaN(key)) {\n        return null;\n      }\n      return key;\n    case 'object':\n      var origKey = key;\n      if (Array.isArray(key)) {\n        var len = key.length;\n        key = new Array(len);\n        for (var i = 0; i < len; i++) {\n          key[i] = normalizeKey(origKey[i]);\n        }\n      /* istanbul ignore next */\n      } else if (key instanceof Date) {\n        return key.toJSON();\n      } else if (key !== null) { // generic object\n        key = {};\n        for (var k in origKey) {\n          if (origKey.hasOwnProperty(k)) {\n            var val = origKey[k];\n            if (typeof val !== 'undefined') {\n              key[k] = normalizeKey(val);\n            }\n          }\n        }\n      }\n  }\n  return key;\n}\n\nfunction indexify(key) {\n  if (key !== null) {\n    switch (typeof key) {\n      case 'boolean':\n        return key ? 1 : 0;\n      case 'number':\n        return numToIndexableString(key);\n      case 'string':\n        // We've to be sure that key does not contain \\u0000\n        // Do order-preserving replacements:\n        // 0 -> 1, 1\n        // 1 -> 1, 2\n        // 2 -> 2, 2\n        /* eslint-disable no-control-regex */\n        return key\n          .replace(/\\u0002/g, '\\u0002\\u0002')\n          .replace(/\\u0001/g, '\\u0001\\u0002')\n          .replace(/\\u0000/g, '\\u0001\\u0001');\n        /* eslint-enable no-control-regex */\n      case 'object':\n        var isArray = Array.isArray(key);\n        var arr = isArray ? key : Object.keys(key);\n        var i = -1;\n        var len = arr.length;\n        var result = '';\n        if (isArray) {\n          while (++i < len) {\n            result += toIndexableString(arr[i]);\n          }\n        } else {\n          while (++i < len) {\n            var objKey = arr[i];\n            result += toIndexableString(objKey) +\n                toIndexableString(key[objKey]);\n          }\n        }\n        return result;\n    }\n  }\n  return '';\n}\n\n// convert the given key to a string that would be appropriate\n// for lexical sorting, e.g. within a database, where the\n// sorting is the same given by the collate() function.\nfunction toIndexableString(key) {\n  var zero = '\\u0000';\n  key = normalizeKey(key);\n  return collationIndex(key) + SEP + indexify(key) + zero;\n}\n\nfunction parseNumber(str, i) {\n  var originalIdx = i;\n  var num;\n  var zero = str[i] === '1';\n  if (zero) {\n    num = 0;\n    i++;\n  } else {\n    var neg = str[i] === '0';\n    i++;\n    var numAsString = '';\n    var magAsString = str.substring(i, i + MAGNITUDE_DIGITS);\n    var magnitude = parseInt(magAsString, 10) + MIN_MAGNITUDE;\n    /* istanbul ignore next */\n    if (neg) {\n      magnitude = -magnitude;\n    }\n    i += MAGNITUDE_DIGITS;\n    while (true) {\n      var ch = str[i];\n      if (ch === '\\u0000') {\n        break;\n      } else {\n        numAsString += ch;\n      }\n      i++;\n    }\n    numAsString = numAsString.split('.');\n    if (numAsString.length === 1) {\n      num = parseInt(numAsString, 10);\n    } else {\n      /* istanbul ignore next */\n      num = parseFloat(numAsString[0] + '.' + numAsString[1]);\n    }\n    /* istanbul ignore next */\n    if (neg) {\n      num = num - 10;\n    }\n    /* istanbul ignore next */\n    if (magnitude !== 0) {\n      // parseFloat is more reliable than pow due to rounding errors\n      // e.g. Number.MAX_VALUE would return Infinity if we did\n      // num * Math.pow(10, magnitude);\n      num = parseFloat(num + 'e' + magnitude);\n    }\n  }\n  return {num: num, length : i - originalIdx};\n}\n\n// move up the stack while parsing\n// this function moved outside of parseIndexableString for performance\nfunction pop(stack, metaStack) {\n  var obj = stack.pop();\n\n  if (metaStack.length) {\n    var lastMetaElement = metaStack[metaStack.length - 1];\n    if (obj === lastMetaElement.element) {\n      // popping a meta-element, e.g. an object whose value is another object\n      metaStack.pop();\n      lastMetaElement = metaStack[metaStack.length - 1];\n    }\n    var element = lastMetaElement.element;\n    var lastElementIndex = lastMetaElement.index;\n    if (Array.isArray(element)) {\n      element.push(obj);\n    } else if (lastElementIndex === stack.length - 2) { // obj with key+value\n      var key = stack.pop();\n      element[key] = obj;\n    } else {\n      stack.push(obj); // obj with key only\n    }\n  }\n}\n\nfunction parseIndexableString(str) {\n  var stack = [];\n  var metaStack = []; // stack for arrays and objects\n  var i = 0;\n\n  /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n  while (true) {\n    var collationIndex = str[i++];\n    if (collationIndex === '\\u0000') {\n      if (stack.length === 1) {\n        return stack.pop();\n      } else {\n        pop(stack, metaStack);\n        continue;\n      }\n    }\n    switch (collationIndex) {\n      case '1':\n        stack.push(null);\n        break;\n      case '2':\n        stack.push(str[i] === '1');\n        i++;\n        break;\n      case '3':\n        var parsedNum = parseNumber(str, i);\n        stack.push(parsedNum.num);\n        i += parsedNum.length;\n        break;\n      case '4':\n        var parsedStr = '';\n        /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n        while (true) {\n          var ch = str[i];\n          if (ch === '\\u0000') {\n            break;\n          }\n          parsedStr += ch;\n          i++;\n        }\n        // perform the reverse of the order-preserving replacement\n        // algorithm (see above)\n        /* eslint-disable no-control-regex */\n        parsedStr = parsedStr.replace(/\\u0001\\u0001/g, '\\u0000')\n          .replace(/\\u0001\\u0002/g, '\\u0001')\n          .replace(/\\u0002\\u0002/g, '\\u0002');\n        /* eslint-enable no-control-regex */\n        stack.push(parsedStr);\n        break;\n      case '5':\n        var arrayElement = { element: [], index: stack.length };\n        stack.push(arrayElement.element);\n        metaStack.push(arrayElement);\n        break;\n      case '6':\n        var objElement = { element: {}, index: stack.length };\n        stack.push(objElement.element);\n        metaStack.push(objElement);\n        break;\n      /* istanbul ignore next */\n      default:\n        throw new Error(\n          'bad collationIndex or unexpectedly reached end of input: ' +\n            collationIndex);\n    }\n  }\n}\n\nfunction arrayCollate(a, b) {\n  var len = Math.min(a.length, b.length);\n  for (var i = 0; i < len; i++) {\n    var sort = collate(a[i], b[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n  }\n  return (a.length === b.length) ? 0 :\n    (a.length > b.length) ? 1 : -1;\n}\nfunction stringCollate(a, b) {\n  // See: https://github.com/daleharvey/pouchdb/issues/40\n  // This is incompatible with the CouchDB implementation, but its the\n  // best we can do for now\n  return (a === b) ? 0 : ((a > b) ? 1 : -1);\n}\nfunction objectCollate(a, b) {\n  var ak = Object.keys(a), bk = Object.keys(b);\n  var len = Math.min(ak.length, bk.length);\n  for (var i = 0; i < len; i++) {\n    // First sort the keys\n    var sort = collate(ak[i], bk[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n    // if the keys are equal sort the values\n    sort = collate(a[ak[i]], b[bk[i]]);\n    if (sort !== 0) {\n      return sort;\n    }\n\n  }\n  return (ak.length === bk.length) ? 0 :\n    (ak.length > bk.length) ? 1 : -1;\n}\n// The collation is defined by erlangs ordered terms\n// the atoms null, true, false come first, then numbers, strings,\n// arrays, then objects\n// null/undefined/NaN/Infinity/-Infinity are all considered null\nfunction collationIndex(x) {\n  var id = ['boolean', 'number', 'string', 'object'];\n  var idx = id.indexOf(typeof x);\n  //false if -1 otherwise true, but fast!!!!1\n  if (~idx) {\n    if (x === null) {\n      return 1;\n    }\n    if (Array.isArray(x)) {\n      return 5;\n    }\n    return idx < 3 ? (idx + 2) : (idx + 3);\n  }\n  /* istanbul ignore next */\n  if (Array.isArray(x)) {\n    return 5;\n  }\n}\n\n// conversion:\n// x yyy zz...zz\n// x = 0 for negative, 1 for 0, 2 for positive\n// y = exponent (for negative numbers negated) moved so that it's >= 0\n// z = mantisse\nfunction numToIndexableString(num) {\n\n  if (num === 0) {\n    return '1';\n  }\n\n  // convert number to exponential format for easier and\n  // more succinct string sorting\n  var expFormat = num.toExponential().split(/e\\+?/);\n  var magnitude = parseInt(expFormat[1], 10);\n\n  var neg = num < 0;\n\n  var result = neg ? '0' : '2';\n\n  // first sort by magnitude\n  // it's easier if all magnitudes are positive\n  var magForComparison = ((neg ? -magnitude : magnitude) - MIN_MAGNITUDE);\n  var magString = padLeft((magForComparison).toString(), '0', MAGNITUDE_DIGITS);\n\n  result += SEP + magString;\n\n  // then sort by the factor\n  var factor = Math.abs(parseFloat(expFormat[0])); // [1..10)\n  /* istanbul ignore next */\n  if (neg) { // for negative reverse ordering\n    factor = 10 - factor;\n  }\n\n  var factorStr = factor.toFixed(20);\n\n  // strip zeros from the end\n  factorStr = factorStr.replace(/\\.?0+$/, '');\n\n  result += SEP + factorStr;\n\n  return result;\n}\n\n// create a comparator based on the sort object\nfunction createFieldSorter(sort) {\n\n  function getFieldValuesAsArray(doc) {\n    return sort.map(function (sorting) {\n      var fieldName = getKey(sorting);\n      var parsedField = parseField(fieldName);\n      var docFieldValue = getFieldFromDoc(doc, parsedField);\n      return docFieldValue;\n    });\n  }\n\n  return function (aRow, bRow) {\n    var aFieldValues = getFieldValuesAsArray(aRow.doc);\n    var bFieldValues = getFieldValuesAsArray(bRow.doc);\n    var collation = collate(aFieldValues, bFieldValues);\n    if (collation !== 0) {\n      return collation;\n    }\n    // this is what mango seems to do\n    return compare$1(aRow.doc._id, bRow.doc._id);\n  };\n}\n\nfunction filterInMemoryFields(rows, requestDef, inMemoryFields) {\n  rows = rows.filter(function (row) {\n    return rowFilter(row.doc, requestDef.selector, inMemoryFields);\n  });\n\n  if (requestDef.sort) {\n    // in-memory sort\n    var fieldSorter = createFieldSorter(requestDef.sort);\n    rows = rows.sort(fieldSorter);\n    if (typeof requestDef.sort[0] !== 'string' &&\n        getValue(requestDef.sort[0]) === 'desc') {\n      rows = rows.reverse();\n    }\n  }\n\n  if ('limit' in requestDef || 'skip' in requestDef) {\n    // have to do the limit in-memory\n    var skip = requestDef.skip || 0;\n    var limit = ('limit' in requestDef ? requestDef.limit : rows.length) + skip;\n    rows = rows.slice(skip, limit);\n  }\n  return rows;\n}\n\nfunction rowFilter(doc, selector, inMemoryFields) {\n  return inMemoryFields.every(function (field) {\n    var matcher = selector[field];\n    var parsedField = parseField(field);\n    var docFieldValue = getFieldFromDoc(doc, parsedField);\n    if (isCombinationalField(field)) {\n      return matchCominationalSelector(field, matcher, doc);\n    }\n\n    return matchSelector(matcher, doc, parsedField, docFieldValue);\n  });\n}\n\nfunction matchSelector(matcher, doc, parsedField, docFieldValue) {\n  if (!matcher) {\n    // no filtering necessary; this field is just needed for sorting\n    return true;\n  }\n\n  return Object.keys(matcher).every(function (userOperator) {\n    var userValue = matcher[userOperator];\n    return match(userOperator, doc, userValue, parsedField, docFieldValue);\n  });\n}\n\nfunction matchCominationalSelector(field, matcher, doc) {\n\n  if (field === '$or') {\n    return matcher.some(function (orMatchers) {\n      return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n    });\n  }\n\n  if (field === '$not') {\n    return !rowFilter(doc, matcher, Object.keys(matcher));\n  }\n\n  //`$nor`\n  return !matcher.find(function (orMatchers) {\n    return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n  });\n\n}\n\nfunction match(userOperator, doc, userValue, parsedField, docFieldValue) {\n  if (!matchers[userOperator]) {\n    throw new Error('unknown operator \"' + userOperator +\n      '\" - should be one of $eq, $lte, $lt, $gt, $gte, $exists, $ne, $in, ' +\n      '$nin, $size, $mod, $regex, $elemMatch, $type, $allMatch or $all');\n  }\n  return matchers[userOperator](doc, userValue, parsedField, docFieldValue);\n}\n\nfunction fieldExists(docFieldValue) {\n  return typeof docFieldValue !== 'undefined' && docFieldValue !== null;\n}\n\nfunction fieldIsNotUndefined(docFieldValue) {\n  return typeof docFieldValue !== 'undefined';\n}\n\nfunction modField(docFieldValue, userValue) {\n  var divisor = userValue[0];\n  var mod = userValue[1];\n  if (divisor === 0) {\n    throw new Error('Bad divisor, cannot divide by zero');\n  }\n\n  if (parseInt(divisor, 10) !== divisor ) {\n    throw new Error('Divisor is not an integer');\n  }\n\n  if (parseInt(mod, 10) !== mod ) {\n    throw new Error('Modulus is not an integer');\n  }\n\n  if (parseInt(docFieldValue, 10) !== docFieldValue) {\n    return false;\n  }\n\n  return docFieldValue % divisor === mod;\n}\n\nfunction arrayContainsValue(docFieldValue, userValue) {\n  return userValue.some(function (val) {\n    if (docFieldValue instanceof Array) {\n      return docFieldValue.indexOf(val) > -1;\n    }\n\n    return docFieldValue === val;\n  });\n}\n\nfunction arrayContainsAllValues(docFieldValue, userValue) {\n  return userValue.every(function (val) {\n    return docFieldValue.indexOf(val) > -1;\n  });\n}\n\nfunction arraySize(docFieldValue, userValue) {\n  return docFieldValue.length === userValue;\n}\n\nfunction regexMatch(docFieldValue, userValue) {\n  var re = new RegExp(userValue);\n\n  return re.test(docFieldValue);\n}\n\nfunction typeMatch(docFieldValue, userValue) {\n\n  switch (userValue) {\n    case 'null':\n      return docFieldValue === null;\n    case 'boolean':\n      return typeof (docFieldValue) === 'boolean';\n    case 'number':\n      return typeof (docFieldValue) === 'number';\n    case 'string':\n      return typeof (docFieldValue) === 'string';\n    case 'array':\n      return docFieldValue instanceof Array;\n    case 'object':\n      return ({}).toString.call(docFieldValue) === '[object Object]';\n  }\n\n  throw new Error(userValue + ' not supported as a type.' +\n                  'Please use one of object, string, array, number, boolean or null.');\n\n}\n\nvar matchers = {\n\n  '$elemMatch': function (doc, userValue, parsedField, docFieldValue) {\n    if (!Array.isArray(docFieldValue)) {\n      return false;\n    }\n\n    if (docFieldValue.length === 0) {\n      return false;\n    }\n\n    if (typeof docFieldValue[0] === 'object') {\n      return docFieldValue.some(function (val) {\n        return rowFilter(val, userValue, Object.keys(userValue));\n      });\n    }\n\n    return docFieldValue.some(function (val) {\n      return matchSelector(userValue, doc, parsedField, val);\n    });\n  },\n\n  '$allMatch': function (doc, userValue, parsedField, docFieldValue) {\n    if (!Array.isArray(docFieldValue)) {\n      return false;\n    }\n\n    /* istanbul ignore next */\n    if (docFieldValue.length === 0) {\n      return false;\n    }\n\n    if (typeof docFieldValue[0] === 'object') {\n      return docFieldValue.every(function (val) {\n        return rowFilter(val, userValue, Object.keys(userValue));\n      });\n    }\n\n    return docFieldValue.every(function (val) {\n      return matchSelector(userValue, doc, parsedField, val);\n    });\n  },\n\n  '$eq': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) === 0;\n  },\n\n  '$gte': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) >= 0;\n  },\n\n  '$gt': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) > 0;\n  },\n\n  '$lte': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) <= 0;\n  },\n\n  '$lt': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) < 0;\n  },\n\n  '$exists': function (doc, userValue, parsedField, docFieldValue) {\n    //a field that is null is still considered to exist\n    if (userValue) {\n      return fieldIsNotUndefined(docFieldValue);\n    }\n\n    return !fieldIsNotUndefined(docFieldValue);\n  },\n\n  '$mod': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && modField(docFieldValue, userValue);\n  },\n\n  '$ne': function (doc, userValue, parsedField, docFieldValue) {\n    return userValue.every(function (neValue) {\n      return collate(docFieldValue, neValue) !== 0;\n    });\n  },\n  '$in': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && arrayContainsValue(docFieldValue, userValue);\n  },\n\n  '$nin': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && !arrayContainsValue(docFieldValue, userValue);\n  },\n\n  '$size': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && arraySize(docFieldValue, userValue);\n  },\n\n  '$all': function (doc, userValue, parsedField, docFieldValue) {\n    return Array.isArray(docFieldValue) && arrayContainsAllValues(docFieldValue, userValue);\n  },\n\n  '$regex': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && regexMatch(docFieldValue, userValue);\n  },\n\n  '$type': function (doc, userValue, parsedField, docFieldValue) {\n    return typeMatch(docFieldValue, userValue);\n  }\n};\n\n// return true if the given doc matches the supplied selector\nfunction matchesSelector(doc, selector) {\n  /* istanbul ignore if */\n  if (typeof selector !== 'object') {\n    // match the CouchDB error message\n    throw new Error('Selector error: expected a JSON object');\n  }\n\n  selector = massageSelector(selector);\n  var row = {\n    'doc': doc\n  };\n\n  var rowsMatched = filterInMemoryFields([row], { 'selector': selector }, Object.keys(selector));\n  return rowsMatched && rowsMatched.length === 1;\n}\n\nfunction evalFilter(input) {\n  return scopeEval('\"use strict\";\\nreturn ' + input + ';', {});\n}\n\nfunction evalView(input) {\n  var code = [\n    'return function(doc) {',\n    '  \"use strict\";',\n    '  var emitted = false;',\n    '  var emit = function (a, b) {',\n    '    emitted = true;',\n    '  };',\n    '  var view = ' + input + ';',\n    '  view(doc);',\n    '  if (emitted) {',\n    '    return true;',\n    '  }',\n    '};'\n  ].join('\\n');\n\n  return scopeEval(code, {});\n}\n\nfunction validate(opts, callback) {\n  if (opts.selector) {\n    if (opts.filter && opts.filter !== '_selector') {\n      var filterName = typeof opts.filter === 'string' ?\n        opts.filter : 'function';\n      return callback(new Error('selector invalid for filter \"' + filterName + '\"'));\n    }\n  }\n  callback();\n}\n\nfunction normalize(opts) {\n  if (opts.view && !opts.filter) {\n    opts.filter = '_view';\n  }\n\n  if (opts.selector && !opts.filter) {\n    opts.filter = '_selector';\n  }\n\n  if (opts.filter && typeof opts.filter === 'string') {\n    if (opts.filter === '_view') {\n      opts.view = normalizeDesignDocFunctionName(opts.view);\n    } else {\n      opts.filter = normalizeDesignDocFunctionName(opts.filter);\n    }\n  }\n}\n\nfunction shouldFilter(changesHandler, opts) {\n  return opts.filter && typeof opts.filter === 'string' &&\n    !opts.doc_ids && !isRemote(changesHandler.db);\n}\n\nfunction filter(changesHandler, opts) {\n  var callback = opts.complete;\n  if (opts.filter === '_view') {\n    if (!opts.view || typeof opts.view !== 'string') {\n      var err = createError(BAD_REQUEST,\n        '`view` filter parameter not found or invalid.');\n      return callback(err);\n    }\n    // fetch a view from a design doc, make it behave like a filter\n    var viewName = parseDesignDocFunctionName(opts.view);\n    changesHandler.db.get('_design/' + viewName[0], function (err, ddoc) {\n      /* istanbul ignore if */\n      if (changesHandler.isCancelled) {\n        return callback(null, {status: 'cancelled'});\n      }\n      /* istanbul ignore next */\n      if (err) {\n        return callback(generateErrorFromResponse(err));\n      }\n      var mapFun = ddoc && ddoc.views && ddoc.views[viewName[1]] &&\n        ddoc.views[viewName[1]].map;\n      if (!mapFun) {\n        return callback(createError(MISSING_DOC,\n          (ddoc.views ? 'missing json key: ' + viewName[1] :\n            'missing json key: views')));\n      }\n      opts.filter = evalView(mapFun);\n      changesHandler.doChanges(opts);\n    });\n  } else if (opts.selector) {\n    opts.filter = function (doc) {\n      return matchesSelector(doc, opts.selector);\n    };\n    changesHandler.doChanges(opts);\n  } else {\n    // fetch a filter from a design doc\n    var filterName = parseDesignDocFunctionName(opts.filter);\n    changesHandler.db.get('_design/' + filterName[0], function (err, ddoc) {\n      /* istanbul ignore if */\n      if (changesHandler.isCancelled) {\n        return callback(null, {status: 'cancelled'});\n      }\n      /* istanbul ignore next */\n      if (err) {\n        return callback(generateErrorFromResponse(err));\n      }\n      var filterFun = ddoc && ddoc.filters && ddoc.filters[filterName[1]];\n      if (!filterFun) {\n        return callback(createError(MISSING_DOC,\n          ((ddoc && ddoc.filters) ? 'missing json key: ' + filterName[1]\n            : 'missing json key: filters')));\n      }\n      opts.filter = evalFilter(filterFun);\n      changesHandler.doChanges(opts);\n    });\n  }\n}\n\nfunction applyChangesFilterPlugin(PouchDB) {\n  PouchDB._changesFilterPlugin = {\n    validate: validate,\n    normalize: normalize,\n    shouldFilter: shouldFilter,\n    filter: filter\n  };\n}\n\n// TODO: remove from pouchdb-core (breaking)\nPouchDB.plugin(applyChangesFilterPlugin);\n\nPouchDB.version = version;\n\nfunction toObject(array) {\n  return array.reduce(function (obj, item) {\n    obj[item] = true;\n    return obj;\n  }, {});\n}\n// List of top level reserved words for doc\nvar reservedWords = toObject([\n  '_id',\n  '_rev',\n  '_attachments',\n  '_deleted',\n  '_revisions',\n  '_revs_info',\n  '_conflicts',\n  '_deleted_conflicts',\n  '_local_seq',\n  '_rev_tree',\n  //replication documents\n  '_replication_id',\n  '_replication_state',\n  '_replication_state_time',\n  '_replication_state_reason',\n  '_replication_stats',\n  // Specific to Couchbase Sync Gateway\n  '_removed'\n]);\n\n// List of reserved words that should end up the document\nvar dataWords = toObject([\n  '_attachments',\n  //replication documents\n  '_replication_id',\n  '_replication_state',\n  '_replication_state_time',\n  '_replication_state_reason',\n  '_replication_stats'\n]);\n\nfunction parseRevisionInfo(rev) {\n  if (!/^\\d+-./.test(rev)) {\n    return createError(INVALID_REV);\n  }\n  var idx = rev.indexOf('-');\n  var left = rev.substring(0, idx);\n  var right = rev.substring(idx + 1);\n  return {\n    prefix: parseInt(left, 10),\n    id: right\n  };\n}\n\nfunction makeRevTreeFromRevisions(revisions, opts) {\n  var pos = revisions.start - revisions.ids.length + 1;\n\n  var revisionIds = revisions.ids;\n  var ids = [revisionIds[0], opts, []];\n\n  for (var i = 1, len = revisionIds.length; i < len; i++) {\n    ids = [revisionIds[i], {status: 'missing'}, [ids]];\n  }\n\n  return [{\n    pos: pos,\n    ids: ids\n  }];\n}\n\n// Preprocess documents, parse their revisions, assign an id and a\n// revision for new writes that are missing them, etc\nfunction parseDoc(doc, newEdits, dbOpts) {\n  if (!dbOpts) {\n    dbOpts = {\n      deterministic_revs: true\n    };\n  }\n\n  var nRevNum;\n  var newRevId;\n  var revInfo;\n  var opts = {status: 'available'};\n  if (doc._deleted) {\n    opts.deleted = true;\n  }\n\n  if (newEdits) {\n    if (!doc._id) {\n      doc._id = uuid();\n    }\n    newRevId = rev$$1(doc, dbOpts.deterministic_revs);\n    if (doc._rev) {\n      revInfo = parseRevisionInfo(doc._rev);\n      if (revInfo.error) {\n        return revInfo;\n      }\n      doc._rev_tree = [{\n        pos: revInfo.prefix,\n        ids: [revInfo.id, {status: 'missing'}, [[newRevId, opts, []]]]\n      }];\n      nRevNum = revInfo.prefix + 1;\n    } else {\n      doc._rev_tree = [{\n        pos: 1,\n        ids : [newRevId, opts, []]\n      }];\n      nRevNum = 1;\n    }\n  } else {\n    if (doc._revisions) {\n      doc._rev_tree = makeRevTreeFromRevisions(doc._revisions, opts);\n      nRevNum = doc._revisions.start;\n      newRevId = doc._revisions.ids[0];\n    }\n    if (!doc._rev_tree) {\n      revInfo = parseRevisionInfo(doc._rev);\n      if (revInfo.error) {\n        return revInfo;\n      }\n      nRevNum = revInfo.prefix;\n      newRevId = revInfo.id;\n      doc._rev_tree = [{\n        pos: nRevNum,\n        ids: [newRevId, opts, []]\n      }];\n    }\n  }\n\n  invalidIdError(doc._id);\n\n  doc._rev = nRevNum + '-' + newRevId;\n\n  var result = {metadata : {}, data : {}};\n  for (var key in doc) {\n    /* istanbul ignore else */\n    if (Object.prototype.hasOwnProperty.call(doc, key)) {\n      var specialKey = key[0] === '_';\n      if (specialKey && !reservedWords[key]) {\n        var error = createError(DOC_VALIDATION, key);\n        error.message = DOC_VALIDATION.message + ': ' + key;\n        throw error;\n      } else if (specialKey && !dataWords[key]) {\n        result.metadata[key.slice(1)] = doc[key];\n      } else {\n        result.data[key] = doc[key];\n      }\n    }\n  }\n  return result;\n}\n\nfunction parseBase64(data) {\n  try {\n    return thisAtob(data);\n  } catch (e) {\n    var err = createError(BAD_ARG,\n      'Attachment is not a valid base64 string');\n    return {error: err};\n  }\n}\n\nfunction preprocessString(att, blobType, callback) {\n  var asBinary = parseBase64(att.data);\n  if (asBinary.error) {\n    return callback(asBinary.error);\n  }\n\n  att.length = asBinary.length;\n  if (blobType === 'blob') {\n    att.data = binStringToBluffer(asBinary, att.content_type);\n  } else if (blobType === 'base64') {\n    att.data = thisBtoa(asBinary);\n  } else { // binary\n    att.data = asBinary;\n  }\n  binaryMd5(asBinary, function (result) {\n    att.digest = 'md5-' + result;\n    callback();\n  });\n}\n\nfunction preprocessBlob(att, blobType, callback) {\n  binaryMd5(att.data, function (md5) {\n    att.digest = 'md5-' + md5;\n    // size is for blobs (browser), length is for buffers (node)\n    att.length = att.data.size || att.data.length || 0;\n    if (blobType === 'binary') {\n      blobToBinaryString(att.data, function (binString) {\n        att.data = binString;\n        callback();\n      });\n    } else if (blobType === 'base64') {\n      blobToBase64(att.data, function (b64) {\n        att.data = b64;\n        callback();\n      });\n    } else {\n      callback();\n    }\n  });\n}\n\nfunction preprocessAttachment(att, blobType, callback) {\n  if (att.stub) {\n    return callback();\n  }\n  if (typeof att.data === 'string') { // input is a base64 string\n    preprocessString(att, blobType, callback);\n  } else { // input is a blob\n    preprocessBlob(att, blobType, callback);\n  }\n}\n\nfunction preprocessAttachments(docInfos, blobType, callback) {\n\n  if (!docInfos.length) {\n    return callback();\n  }\n\n  var docv = 0;\n  var overallErr;\n\n  docInfos.forEach(function (docInfo) {\n    var attachments = docInfo.data && docInfo.data._attachments ?\n      Object.keys(docInfo.data._attachments) : [];\n    var recv = 0;\n\n    if (!attachments.length) {\n      return done();\n    }\n\n    function processedAttachment(err) {\n      overallErr = err;\n      recv++;\n      if (recv === attachments.length) {\n        done();\n      }\n    }\n\n    for (var key in docInfo.data._attachments) {\n      if (docInfo.data._attachments.hasOwnProperty(key)) {\n        preprocessAttachment(docInfo.data._attachments[key],\n          blobType, processedAttachment);\n      }\n    }\n  });\n\n  function done() {\n    docv++;\n    if (docInfos.length === docv) {\n      if (overallErr) {\n        callback(overallErr);\n      } else {\n        callback();\n      }\n    }\n  }\n}\n\nfunction updateDoc(revLimit, prev, docInfo, results,\n                   i, cb, writeDoc, newEdits) {\n\n  if (revExists(prev.rev_tree, docInfo.metadata.rev) && !newEdits) {\n    results[i] = docInfo;\n    return cb();\n  }\n\n  // sometimes this is pre-calculated. historically not always\n  var previousWinningRev = prev.winningRev || winningRev(prev);\n  var previouslyDeleted = 'deleted' in prev ? prev.deleted :\n    isDeleted(prev, previousWinningRev);\n  var deleted = 'deleted' in docInfo.metadata ? docInfo.metadata.deleted :\n    isDeleted(docInfo.metadata);\n  var isRoot = /^1-/.test(docInfo.metadata.rev);\n\n  if (previouslyDeleted && !deleted && newEdits && isRoot) {\n    var newDoc = docInfo.data;\n    newDoc._rev = previousWinningRev;\n    newDoc._id = docInfo.metadata.id;\n    docInfo = parseDoc(newDoc, newEdits);\n  }\n\n  var merged = merge(prev.rev_tree, docInfo.metadata.rev_tree[0], revLimit);\n\n  var inConflict = newEdits && ((\n    (previouslyDeleted && deleted && merged.conflicts !== 'new_leaf') ||\n    (!previouslyDeleted && merged.conflicts !== 'new_leaf') ||\n    (previouslyDeleted && !deleted && merged.conflicts === 'new_branch')));\n\n  if (inConflict) {\n    var err = createError(REV_CONFLICT);\n    results[i] = err;\n    return cb();\n  }\n\n  var newRev = docInfo.metadata.rev;\n  docInfo.metadata.rev_tree = merged.tree;\n  docInfo.stemmedRevs = merged.stemmedRevs || [];\n  /* istanbul ignore else */\n  if (prev.rev_map) {\n    docInfo.metadata.rev_map = prev.rev_map; // used only by leveldb\n  }\n\n  // recalculate\n  var winningRev$$1 = winningRev(docInfo.metadata);\n  var winningRevIsDeleted = isDeleted(docInfo.metadata, winningRev$$1);\n\n  // calculate the total number of documents that were added/removed,\n  // from the perspective of total_rows/doc_count\n  var delta = (previouslyDeleted === winningRevIsDeleted) ? 0 :\n    previouslyDeleted < winningRevIsDeleted ? -1 : 1;\n\n  var newRevIsDeleted;\n  if (newRev === winningRev$$1) {\n    // if the new rev is the same as the winning rev, we can reuse that value\n    newRevIsDeleted = winningRevIsDeleted;\n  } else {\n    // if they're not the same, then we need to recalculate\n    newRevIsDeleted = isDeleted(docInfo.metadata, newRev);\n  }\n\n  writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,\n    true, delta, i, cb);\n}\n\nfunction rootIsMissing(docInfo) {\n  return docInfo.metadata.rev_tree[0].ids[1].status === 'missing';\n}\n\nfunction processDocs(revLimit, docInfos, api, fetchedDocs, tx, results,\n                     writeDoc, opts, overallCallback) {\n\n  // Default to 1000 locally\n  revLimit = revLimit || 1000;\n\n  function insertDoc(docInfo, resultsIdx, callback) {\n    // Cant insert new deleted documents\n    var winningRev$$1 = winningRev(docInfo.metadata);\n    var deleted = isDeleted(docInfo.metadata, winningRev$$1);\n    if ('was_delete' in opts && deleted) {\n      results[resultsIdx] = createError(MISSING_DOC, 'deleted');\n      return callback();\n    }\n\n    // 4712 - detect whether a new document was inserted with a _rev\n    var inConflict = newEdits && rootIsMissing(docInfo);\n\n    if (inConflict) {\n      var err = createError(REV_CONFLICT);\n      results[resultsIdx] = err;\n      return callback();\n    }\n\n    var delta = deleted ? 0 : 1;\n\n    writeDoc(docInfo, winningRev$$1, deleted, deleted, false,\n      delta, resultsIdx, callback);\n  }\n\n  var newEdits = opts.new_edits;\n  var idsToDocs = new ExportedMap();\n\n  var docsDone = 0;\n  var docsToDo = docInfos.length;\n\n  function checkAllDocsDone() {\n    if (++docsDone === docsToDo && overallCallback) {\n      overallCallback();\n    }\n  }\n\n  docInfos.forEach(function (currentDoc, resultsIdx) {\n\n    if (currentDoc._id && isLocalId(currentDoc._id)) {\n      var fun = currentDoc._deleted ? '_removeLocal' : '_putLocal';\n      api[fun](currentDoc, {ctx: tx}, function (err, res) {\n        results[resultsIdx] = err || res;\n        checkAllDocsDone();\n      });\n      return;\n    }\n\n    var id = currentDoc.metadata.id;\n    if (idsToDocs.has(id)) {\n      docsToDo--; // duplicate\n      idsToDocs.get(id).push([currentDoc, resultsIdx]);\n    } else {\n      idsToDocs.set(id, [[currentDoc, resultsIdx]]);\n    }\n  });\n\n  // in the case of new_edits, the user can provide multiple docs\n  // with the same id. these need to be processed sequentially\n  idsToDocs.forEach(function (docs, id) {\n    var numDone = 0;\n\n    function docWritten() {\n      if (++numDone < docs.length) {\n        nextDoc();\n      } else {\n        checkAllDocsDone();\n      }\n    }\n    function nextDoc() {\n      var value = docs[numDone];\n      var currentDoc = value[0];\n      var resultsIdx = value[1];\n\n      if (fetchedDocs.has(id)) {\n        updateDoc(revLimit, fetchedDocs.get(id), currentDoc, results,\n          resultsIdx, docWritten, writeDoc, newEdits);\n      } else {\n        // Ensure stemming applies to new writes as well\n        var merged = merge([], currentDoc.metadata.rev_tree[0], revLimit);\n        currentDoc.metadata.rev_tree = merged.tree;\n        currentDoc.stemmedRevs = merged.stemmedRevs || [];\n        insertDoc(currentDoc, resultsIdx, docWritten);\n      }\n    }\n    nextDoc();\n  });\n}\n\n// IndexedDB requires a versioned database structure, so we use the\n// version here to manage migrations.\nvar ADAPTER_VERSION = 5;\n\n// The object stores created for each database\n// DOC_STORE stores the document meta data, its revision history and state\n// Keyed by document id\nvar DOC_STORE = 'document-store';\n// BY_SEQ_STORE stores a particular version of a document, keyed by its\n// sequence id\nvar BY_SEQ_STORE = 'by-sequence';\n// Where we store attachments\nvar ATTACH_STORE = 'attach-store';\n// Where we store many-to-many relations\n// between attachment digests and seqs\nvar ATTACH_AND_SEQ_STORE = 'attach-seq-store';\n\n// Where we store database-wide meta data in a single record\n// keyed by id: META_STORE\nvar META_STORE = 'meta-store';\n// Where we store local documents\nvar LOCAL_STORE = 'local-store';\n// Where we detect blob support\nvar DETECT_BLOB_SUPPORT_STORE = 'detect-blob-support';\n\nfunction safeJsonParse(str) {\n  // This try/catch guards against stack overflow errors.\n  // JSON.parse() is faster than vuvuzela.parse() but vuvuzela\n  // cannot overflow.\n  try {\n    return JSON.parse(str);\n  } catch (e) {\n    /* istanbul ignore next */\n    return vuvuzela.parse(str);\n  }\n}\n\nfunction safeJsonStringify(json) {\n  try {\n    return JSON.stringify(json);\n  } catch (e) {\n    /* istanbul ignore next */\n    return vuvuzela.stringify(json);\n  }\n}\n\nfunction idbError(callback) {\n  return function (evt) {\n    var message = 'unknown_error';\n    if (evt.target && evt.target.error) {\n      message = evt.target.error.name || evt.target.error.message;\n    }\n    callback(createError(IDB_ERROR, message, evt.type));\n  };\n}\n\n// Unfortunately, the metadata has to be stringified\n// when it is put into the database, because otherwise\n// IndexedDB can throw errors for deeply-nested objects.\n// Originally we just used JSON.parse/JSON.stringify; now\n// we use this custom vuvuzela library that avoids recursion.\n// If we could do it all over again, we'd probably use a\n// format for the revision trees other than JSON.\nfunction encodeMetadata(metadata, winningRev, deleted) {\n  return {\n    data: safeJsonStringify(metadata),\n    winningRev: winningRev,\n    deletedOrLocal: deleted ? '1' : '0',\n    seq: metadata.seq, // highest seq for this doc\n    id: metadata.id\n  };\n}\n\nfunction decodeMetadata(storedObject) {\n  if (!storedObject) {\n    return null;\n  }\n  var metadata = safeJsonParse(storedObject.data);\n  metadata.winningRev = storedObject.winningRev;\n  metadata.deleted = storedObject.deletedOrLocal === '1';\n  metadata.seq = storedObject.seq;\n  return metadata;\n}\n\n// read the doc back out from the database. we don't store the\n// _id or _rev because we already have _doc_id_rev.\nfunction decodeDoc(doc) {\n  if (!doc) {\n    return doc;\n  }\n  var idx = doc._doc_id_rev.lastIndexOf(':');\n  doc._id = doc._doc_id_rev.substring(0, idx - 1);\n  doc._rev = doc._doc_id_rev.substring(idx + 1);\n  delete doc._doc_id_rev;\n  return doc;\n}\n\n// Read a blob from the database, encoding as necessary\n// and translating from base64 if the IDB doesn't support\n// native Blobs\nfunction readBlobData(body, type, asBlob, callback) {\n  if (asBlob) {\n    if (!body) {\n      callback(createBlob([''], {type: type}));\n    } else if (typeof body !== 'string') { // we have blob support\n      callback(body);\n    } else { // no blob support\n      callback(b64ToBluffer(body, type));\n    }\n  } else { // as base64 string\n    if (!body) {\n      callback('');\n    } else if (typeof body !== 'string') { // we have blob support\n      readAsBinaryString(body, function (binary) {\n        callback(thisBtoa(binary));\n      });\n    } else { // no blob support\n      callback(body);\n    }\n  }\n}\n\nfunction fetchAttachmentsIfNecessary(doc, opts, txn, cb) {\n  var attachments = Object.keys(doc._attachments || {});\n  if (!attachments.length) {\n    return cb && cb();\n  }\n  var numDone = 0;\n\n  function checkDone() {\n    if (++numDone === attachments.length && cb) {\n      cb();\n    }\n  }\n\n  function fetchAttachment(doc, att) {\n    var attObj = doc._attachments[att];\n    var digest = attObj.digest;\n    var req = txn.objectStore(ATTACH_STORE).get(digest);\n    req.onsuccess = function (e) {\n      attObj.body = e.target.result.body;\n      checkDone();\n    };\n  }\n\n  attachments.forEach(function (att) {\n    if (opts.attachments && opts.include_docs) {\n      fetchAttachment(doc, att);\n    } else {\n      doc._attachments[att].stub = true;\n      checkDone();\n    }\n  });\n}\n\n// IDB-specific postprocessing necessary because\n// we don't know whether we stored a true Blob or\n// a base64-encoded string, and if it's a Blob it\n// needs to be read outside of the transaction context\nfunction postProcessAttachments(results, asBlob) {\n  return Promise.all(results.map(function (row) {\n    if (row.doc && row.doc._attachments) {\n      var attNames = Object.keys(row.doc._attachments);\n      return Promise.all(attNames.map(function (att) {\n        var attObj = row.doc._attachments[att];\n        if (!('body' in attObj)) { // already processed\n          return;\n        }\n        var body = attObj.body;\n        var type = attObj.content_type;\n        return new Promise(function (resolve) {\n          readBlobData(body, type, asBlob, function (data) {\n            row.doc._attachments[att] = $inject_Object_assign(\n              pick(attObj, ['digest', 'content_type']),\n              {data: data}\n            );\n            resolve();\n          });\n        });\n      }));\n    }\n  }));\n}\n\nfunction compactRevs(revs, docId, txn) {\n\n  var possiblyOrphanedDigests = [];\n  var seqStore = txn.objectStore(BY_SEQ_STORE);\n  var attStore = txn.objectStore(ATTACH_STORE);\n  var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n  var count = revs.length;\n\n  function checkDone() {\n    count--;\n    if (!count) { // done processing all revs\n      deleteOrphanedAttachments();\n    }\n  }\n\n  function deleteOrphanedAttachments() {\n    if (!possiblyOrphanedDigests.length) {\n      return;\n    }\n    possiblyOrphanedDigests.forEach(function (digest) {\n      var countReq = attAndSeqStore.index('digestSeq').count(\n        IDBKeyRange.bound(\n          digest + '::', digest + '::\\uffff', false, false));\n      countReq.onsuccess = function (e) {\n        var count = e.target.result;\n        if (!count) {\n          // orphaned\n          attStore.delete(digest);\n        }\n      };\n    });\n  }\n\n  revs.forEach(function (rev) {\n    var index = seqStore.index('_doc_id_rev');\n    var key = docId + \"::\" + rev;\n    index.getKey(key).onsuccess = function (e) {\n      var seq = e.target.result;\n      if (typeof seq !== 'number') {\n        return checkDone();\n      }\n      seqStore.delete(seq);\n\n      var cursor = attAndSeqStore.index('seq')\n        .openCursor(IDBKeyRange.only(seq));\n\n      cursor.onsuccess = function (event) {\n        var cursor = event.target.result;\n        if (cursor) {\n          var digest = cursor.value.digestSeq.split('::')[0];\n          possiblyOrphanedDigests.push(digest);\n          attAndSeqStore.delete(cursor.primaryKey);\n          cursor.continue();\n        } else { // done\n          checkDone();\n        }\n      };\n    };\n  });\n}\n\nfunction openTransactionSafely(idb, stores, mode) {\n  try {\n    return {\n      txn: idb.transaction(stores, mode)\n    };\n  } catch (err) {\n    return {\n      error: err\n    };\n  }\n}\n\nvar changesHandler = new Changes();\n\nfunction idbBulkDocs(dbOpts, req, opts, api, idb, callback) {\n  var docInfos = req.docs;\n  var txn;\n  var docStore;\n  var bySeqStore;\n  var attachStore;\n  var attachAndSeqStore;\n  var metaStore;\n  var docInfoError;\n  var metaDoc;\n\n  for (var i = 0, len = docInfos.length; i < len; i++) {\n    var doc = docInfos[i];\n    if (doc._id && isLocalId(doc._id)) {\n      continue;\n    }\n    doc = docInfos[i] = parseDoc(doc, opts.new_edits, dbOpts);\n    if (doc.error && !docInfoError) {\n      docInfoError = doc;\n    }\n  }\n\n  if (docInfoError) {\n    return callback(docInfoError);\n  }\n\n  var allDocsProcessed = false;\n  var docCountDelta = 0;\n  var results = new Array(docInfos.length);\n  var fetchedDocs = new ExportedMap();\n  var preconditionErrored = false;\n  var blobType = api._meta.blobSupport ? 'blob' : 'base64';\n\n  preprocessAttachments(docInfos, blobType, function (err) {\n    if (err) {\n      return callback(err);\n    }\n    startTransaction();\n  });\n\n  function startTransaction() {\n\n    var stores = [\n      DOC_STORE, BY_SEQ_STORE,\n      ATTACH_STORE,\n      LOCAL_STORE, ATTACH_AND_SEQ_STORE,\n      META_STORE\n    ];\n    var txnResult = openTransactionSafely(idb, stores, 'readwrite');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    txn = txnResult.txn;\n    txn.onabort = idbError(callback);\n    txn.ontimeout = idbError(callback);\n    txn.oncomplete = complete;\n    docStore = txn.objectStore(DOC_STORE);\n    bySeqStore = txn.objectStore(BY_SEQ_STORE);\n    attachStore = txn.objectStore(ATTACH_STORE);\n    attachAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n    metaStore = txn.objectStore(META_STORE);\n\n    metaStore.get(META_STORE).onsuccess = function (e) {\n      metaDoc = e.target.result;\n      updateDocCountIfReady();\n    };\n\n    verifyAttachments(function (err) {\n      if (err) {\n        preconditionErrored = true;\n        return callback(err);\n      }\n      fetchExistingDocs();\n    });\n  }\n\n  function onAllDocsProcessed() {\n    allDocsProcessed = true;\n    updateDocCountIfReady();\n  }\n\n  function idbProcessDocs() {\n    processDocs(dbOpts.revs_limit, docInfos, api, fetchedDocs,\n                txn, results, writeDoc, opts, onAllDocsProcessed);\n  }\n\n  function updateDocCountIfReady() {\n    if (!metaDoc || !allDocsProcessed) {\n      return;\n    }\n    // caching the docCount saves a lot of time in allDocs() and\n    // info(), which is why we go to all the trouble of doing this\n    metaDoc.docCount += docCountDelta;\n    metaStore.put(metaDoc);\n  }\n\n  function fetchExistingDocs() {\n\n    if (!docInfos.length) {\n      return;\n    }\n\n    var numFetched = 0;\n\n    function checkDone() {\n      if (++numFetched === docInfos.length) {\n        idbProcessDocs();\n      }\n    }\n\n    function readMetadata(event) {\n      var metadata = decodeMetadata(event.target.result);\n\n      if (metadata) {\n        fetchedDocs.set(metadata.id, metadata);\n      }\n      checkDone();\n    }\n\n    for (var i = 0, len = docInfos.length; i < len; i++) {\n      var docInfo = docInfos[i];\n      if (docInfo._id && isLocalId(docInfo._id)) {\n        checkDone(); // skip local docs\n        continue;\n      }\n      var req = docStore.get(docInfo.metadata.id);\n      req.onsuccess = readMetadata;\n    }\n  }\n\n  function complete() {\n    if (preconditionErrored) {\n      return;\n    }\n\n    changesHandler.notify(api._meta.name);\n    callback(null, results);\n  }\n\n  function verifyAttachment(digest, callback) {\n\n    var req = attachStore.get(digest);\n    req.onsuccess = function (e) {\n      if (!e.target.result) {\n        var err = createError(MISSING_STUB,\n          'unknown stub attachment with digest ' +\n          digest);\n        err.status = 412;\n        callback(err);\n      } else {\n        callback();\n      }\n    };\n  }\n\n  function verifyAttachments(finish) {\n\n\n    var digests = [];\n    docInfos.forEach(function (docInfo) {\n      if (docInfo.data && docInfo.data._attachments) {\n        Object.keys(docInfo.data._attachments).forEach(function (filename) {\n          var att = docInfo.data._attachments[filename];\n          if (att.stub) {\n            digests.push(att.digest);\n          }\n        });\n      }\n    });\n    if (!digests.length) {\n      return finish();\n    }\n    var numDone = 0;\n    var err;\n\n    function checkDone() {\n      if (++numDone === digests.length) {\n        finish(err);\n      }\n    }\n    digests.forEach(function (digest) {\n      verifyAttachment(digest, function (attErr) {\n        if (attErr && !err) {\n          err = attErr;\n        }\n        checkDone();\n      });\n    });\n  }\n\n  function writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,\n                    isUpdate, delta, resultsIdx, callback) {\n\n    docInfo.metadata.winningRev = winningRev$$1;\n    docInfo.metadata.deleted = winningRevIsDeleted;\n\n    var doc = docInfo.data;\n    doc._id = docInfo.metadata.id;\n    doc._rev = docInfo.metadata.rev;\n\n    if (newRevIsDeleted) {\n      doc._deleted = true;\n    }\n\n    var hasAttachments = doc._attachments &&\n      Object.keys(doc._attachments).length;\n    if (hasAttachments) {\n      return writeAttachments(docInfo, winningRev$$1, winningRevIsDeleted,\n        isUpdate, resultsIdx, callback);\n    }\n\n    docCountDelta += delta;\n    updateDocCountIfReady();\n\n    finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,\n      isUpdate, resultsIdx, callback);\n  }\n\n  function finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,\n                     isUpdate, resultsIdx, callback) {\n\n    var doc = docInfo.data;\n    var metadata = docInfo.metadata;\n\n    doc._doc_id_rev = metadata.id + '::' + metadata.rev;\n    delete doc._id;\n    delete doc._rev;\n\n    function afterPutDoc(e) {\n      var revsToDelete = docInfo.stemmedRevs || [];\n\n      if (isUpdate && api.auto_compaction) {\n        revsToDelete = revsToDelete.concat(compactTree(docInfo.metadata));\n      }\n\n      if (revsToDelete && revsToDelete.length) {\n        compactRevs(revsToDelete, docInfo.metadata.id, txn);\n      }\n\n      metadata.seq = e.target.result;\n      // Current _rev is calculated from _rev_tree on read\n      // delete metadata.rev;\n      var metadataToStore = encodeMetadata(metadata, winningRev$$1,\n        winningRevIsDeleted);\n      var metaDataReq = docStore.put(metadataToStore);\n      metaDataReq.onsuccess = afterPutMetadata;\n    }\n\n    function afterPutDocError(e) {\n      // ConstraintError, need to update, not put (see #1638 for details)\n      e.preventDefault(); // avoid transaction abort\n      e.stopPropagation(); // avoid transaction onerror\n      var index = bySeqStore.index('_doc_id_rev');\n      var getKeyReq = index.getKey(doc._doc_id_rev);\n      getKeyReq.onsuccess = function (e) {\n        var putReq = bySeqStore.put(doc, e.target.result);\n        putReq.onsuccess = afterPutDoc;\n      };\n    }\n\n    function afterPutMetadata() {\n      results[resultsIdx] = {\n        ok: true,\n        id: metadata.id,\n        rev: metadata.rev\n      };\n      fetchedDocs.set(docInfo.metadata.id, docInfo.metadata);\n      insertAttachmentMappings(docInfo, metadata.seq, callback);\n    }\n\n    var putReq = bySeqStore.put(doc);\n\n    putReq.onsuccess = afterPutDoc;\n    putReq.onerror = afterPutDocError;\n  }\n\n  function writeAttachments(docInfo, winningRev$$1, winningRevIsDeleted,\n                            isUpdate, resultsIdx, callback) {\n\n\n    var doc = docInfo.data;\n\n    var numDone = 0;\n    var attachments = Object.keys(doc._attachments);\n\n    function collectResults() {\n      if (numDone === attachments.length) {\n        finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,\n          isUpdate, resultsIdx, callback);\n      }\n    }\n\n    function attachmentSaved() {\n      numDone++;\n      collectResults();\n    }\n\n    attachments.forEach(function (key) {\n      var att = docInfo.data._attachments[key];\n      if (!att.stub) {\n        var data = att.data;\n        delete att.data;\n        att.revpos = parseInt(winningRev$$1, 10);\n        var digest = att.digest;\n        saveAttachment(digest, data, attachmentSaved);\n      } else {\n        numDone++;\n        collectResults();\n      }\n    });\n  }\n\n  // map seqs to attachment digests, which\n  // we will need later during compaction\n  function insertAttachmentMappings(docInfo, seq, callback) {\n\n    var attsAdded = 0;\n    var attsToAdd = Object.keys(docInfo.data._attachments || {});\n\n    if (!attsToAdd.length) {\n      return callback();\n    }\n\n    function checkDone() {\n      if (++attsAdded === attsToAdd.length) {\n        callback();\n      }\n    }\n\n    function add(att) {\n      var digest = docInfo.data._attachments[att].digest;\n      var req = attachAndSeqStore.put({\n        seq: seq,\n        digestSeq: digest + '::' + seq\n      });\n\n      req.onsuccess = checkDone;\n      req.onerror = function (e) {\n        // this callback is for a constaint error, which we ignore\n        // because this docid/rev has already been associated with\n        // the digest (e.g. when new_edits == false)\n        e.preventDefault(); // avoid transaction abort\n        e.stopPropagation(); // avoid transaction onerror\n        checkDone();\n      };\n    }\n    for (var i = 0; i < attsToAdd.length; i++) {\n      add(attsToAdd[i]); // do in parallel\n    }\n  }\n\n  function saveAttachment(digest, data, callback) {\n\n\n    var getKeyReq = attachStore.count(digest);\n    getKeyReq.onsuccess = function (e) {\n      var count = e.target.result;\n      if (count) {\n        return callback(); // already exists\n      }\n      var newAtt = {\n        digest: digest,\n        body: data\n      };\n      var putReq = attachStore.put(newAtt);\n      putReq.onsuccess = callback;\n    };\n  }\n}\n\n// Abstraction over IDBCursor and getAll()/getAllKeys() that allows us to batch our operations\n// while falling back to a normal IDBCursor operation on browsers that don't support getAll() or\n// getAllKeys(). This allows for a much faster implementation than just straight-up cursors, because\n// we're not processing each document one-at-a-time.\nfunction runBatchedCursor(objectStore, keyRange, descending, batchSize, onBatch) {\n\n  if (batchSize === -1) {\n    batchSize = 1000;\n  }\n\n  // Bail out of getAll()/getAllKeys() in the following cases:\n  // 1) either method is unsupported - we need both\n  // 2) batchSize is 1 (might as well use IDBCursor)\n  // 3) descending  no real way to do this via getAll()/getAllKeys()\n\n  var useGetAll = typeof objectStore.getAll === 'function' &&\n    typeof objectStore.getAllKeys === 'function' &&\n    batchSize > 1 && !descending;\n\n  var keysBatch;\n  var valuesBatch;\n  var pseudoCursor;\n\n  function onGetAll(e) {\n    valuesBatch = e.target.result;\n    if (keysBatch) {\n      onBatch(keysBatch, valuesBatch, pseudoCursor);\n    }\n  }\n\n  function onGetAllKeys(e) {\n    keysBatch = e.target.result;\n    if (valuesBatch) {\n      onBatch(keysBatch, valuesBatch, pseudoCursor);\n    }\n  }\n\n  function continuePseudoCursor() {\n    if (!keysBatch.length) { // no more results\n      return onBatch();\n    }\n    // fetch next batch, exclusive start\n    var lastKey = keysBatch[keysBatch.length - 1];\n    var newKeyRange;\n    if (keyRange && keyRange.upper) {\n      try {\n        newKeyRange = IDBKeyRange.bound(lastKey, keyRange.upper,\n          true, keyRange.upperOpen);\n      } catch (e) {\n        if (e.name === \"DataError\" && e.code === 0) {\n          return onBatch(); // we're done, startkey and endkey are equal\n        }\n      }\n    } else {\n      newKeyRange = IDBKeyRange.lowerBound(lastKey, true);\n    }\n    keyRange = newKeyRange;\n    keysBatch = null;\n    valuesBatch = null;\n    objectStore.getAll(keyRange, batchSize).onsuccess = onGetAll;\n    objectStore.getAllKeys(keyRange, batchSize).onsuccess = onGetAllKeys;\n  }\n\n  function onCursor(e) {\n    var cursor = e.target.result;\n    if (!cursor) { // done\n      return onBatch();\n    }\n    // regular IDBCursor acts like a batch where batch size is always 1\n    onBatch([cursor.key], [cursor.value], cursor);\n  }\n\n  if (useGetAll) {\n    pseudoCursor = {\"continue\": continuePseudoCursor};\n    objectStore.getAll(keyRange, batchSize).onsuccess = onGetAll;\n    objectStore.getAllKeys(keyRange, batchSize).onsuccess = onGetAllKeys;\n  } else if (descending) {\n    objectStore.openCursor(keyRange, 'prev').onsuccess = onCursor;\n  } else {\n    objectStore.openCursor(keyRange).onsuccess = onCursor;\n  }\n}\n\n// simple shim for objectStore.getAll(), falling back to IDBCursor\nfunction getAll(objectStore, keyRange, onSuccess) {\n  if (typeof objectStore.getAll === 'function') {\n    // use native getAll\n    objectStore.getAll(keyRange).onsuccess = onSuccess;\n    return;\n  }\n  // fall back to cursors\n  var values = [];\n\n  function onCursor(e) {\n    var cursor = e.target.result;\n    if (cursor) {\n      values.push(cursor.value);\n      cursor.continue();\n    } else {\n      onSuccess({\n        target: {\n          result: values\n        }\n      });\n    }\n  }\n\n  objectStore.openCursor(keyRange).onsuccess = onCursor;\n}\n\nfunction allDocsKeys(keys, docStore, onBatch) {\n  // It's not guaranted to be returned in right order  \n  var valuesBatch = new Array(keys.length);\n  var count = 0;\n  keys.forEach(function (key, index) {\n    docStore.get(key).onsuccess = function (event) {\n      if (event.target.result) {\n        valuesBatch[index] = event.target.result;\n      } else {\n        valuesBatch[index] = {key: key, error: 'not_found'};\n      }\n      count++;\n      if (count === keys.length) {\n        onBatch(keys, valuesBatch, {});\n      }\n    };\n  });\n}\n\nfunction createKeyRange(start, end, inclusiveEnd, key, descending) {\n  try {\n    if (start && end) {\n      if (descending) {\n        return IDBKeyRange.bound(end, start, !inclusiveEnd, false);\n      } else {\n        return IDBKeyRange.bound(start, end, false, !inclusiveEnd);\n      }\n    } else if (start) {\n      if (descending) {\n        return IDBKeyRange.upperBound(start);\n      } else {\n        return IDBKeyRange.lowerBound(start);\n      }\n    } else if (end) {\n      if (descending) {\n        return IDBKeyRange.lowerBound(end, !inclusiveEnd);\n      } else {\n        return IDBKeyRange.upperBound(end, !inclusiveEnd);\n      }\n    } else if (key) {\n      return IDBKeyRange.only(key);\n    }\n  } catch (e) {\n    return {error: e};\n  }\n  return null;\n}\n\nfunction idbAllDocs(opts, idb, callback) {\n  var start = 'startkey' in opts ? opts.startkey : false;\n  var end = 'endkey' in opts ? opts.endkey : false;\n  var key = 'key' in opts ? opts.key : false;\n  var keys = 'keys' in opts ? opts.keys : false; \n  var skip = opts.skip || 0;\n  var limit = typeof opts.limit === 'number' ? opts.limit : -1;\n  var inclusiveEnd = opts.inclusive_end !== false;\n\n  var keyRange ; \n  var keyRangeError;\n  if (!keys) {\n    keyRange = createKeyRange(start, end, inclusiveEnd, key, opts.descending);\n    keyRangeError = keyRange && keyRange.error;\n    if (keyRangeError && \n      !(keyRangeError.name === \"DataError\" && keyRangeError.code === 0)) {\n      // DataError with error code 0 indicates start is less than end, so\n      // can just do an empty query. Else need to throw\n      return callback(createError(IDB_ERROR,\n        keyRangeError.name, keyRangeError.message));\n    }\n  }\n\n  var stores = [DOC_STORE, BY_SEQ_STORE, META_STORE];\n\n  if (opts.attachments) {\n    stores.push(ATTACH_STORE);\n  }\n  var txnResult = openTransactionSafely(idb, stores, 'readonly');\n  if (txnResult.error) {\n    return callback(txnResult.error);\n  }\n  var txn = txnResult.txn;\n  txn.oncomplete = onTxnComplete;\n  txn.onabort = idbError(callback);\n  var docStore = txn.objectStore(DOC_STORE);\n  var seqStore = txn.objectStore(BY_SEQ_STORE);\n  var metaStore = txn.objectStore(META_STORE);\n  var docIdRevIndex = seqStore.index('_doc_id_rev');\n  var results = [];\n  var docCount;\n  var updateSeq;\n\n  metaStore.get(META_STORE).onsuccess = function (e) {\n    docCount = e.target.result.docCount;\n  };\n\n  /* istanbul ignore if */\n  if (opts.update_seq) {\n    getMaxUpdateSeq(seqStore, function (e) { \n      if (e.target.result && e.target.result.length > 0) {\n        updateSeq = e.target.result[0];\n      }\n    });\n  }\n\n  function getMaxUpdateSeq(objectStore, onSuccess) {\n    function onCursor(e) {\n      var cursor = e.target.result;\n      var maxKey = undefined;\n      if (cursor && cursor.key) {\n        maxKey = cursor.key;\n      } \n      return onSuccess({\n        target: {\n          result: [maxKey]\n        }\n      });\n    }\n    objectStore.openCursor(null, 'prev').onsuccess = onCursor;\n  }\n\n  // if the user specifies include_docs=true, then we don't\n  // want to block the main cursor while we're fetching the doc\n  function fetchDocAsynchronously(metadata, row, winningRev$$1) {\n    var key = metadata.id + \"::\" + winningRev$$1;\n    docIdRevIndex.get(key).onsuccess =  function onGetDoc(e) {\n      row.doc = decodeDoc(e.target.result) || {};\n      if (opts.conflicts) {\n        var conflicts = collectConflicts(metadata);\n        if (conflicts.length) {\n          row.doc._conflicts = conflicts;\n        }\n      }\n      fetchAttachmentsIfNecessary(row.doc, opts, txn);\n    };\n  }\n\n  function allDocsInner(winningRev$$1, metadata) {\n    var row = {\n      id: metadata.id,\n      key: metadata.id,\n      value: {\n        rev: winningRev$$1\n      }\n    };\n    var deleted = metadata.deleted;\n    if (deleted) {\n      if (keys) {\n        results.push(row);\n        // deleted docs are okay with \"keys\" requests\n        row.value.deleted = true;\n        row.doc = null;\n      }\n    } else if (skip-- <= 0) {\n      results.push(row);\n      if (opts.include_docs) {\n        fetchDocAsynchronously(metadata, row, winningRev$$1);\n      }\n    }\n  }\n\n  function processBatch(batchValues) {\n    for (var i = 0, len = batchValues.length; i < len; i++) {\n      if (results.length === limit) {\n        break;\n      }\n      var batchValue = batchValues[i];\n      if (batchValue.error && keys) {\n        // key was not found with \"keys\" requests\n        results.push(batchValue);\n        continue;\n      }\n      var metadata = decodeMetadata(batchValue);\n      var winningRev$$1 = metadata.winningRev;\n      allDocsInner(winningRev$$1, metadata);\n    }\n  }\n\n  function onBatch(batchKeys, batchValues, cursor) {\n    if (!cursor) {\n      return;\n    }\n    processBatch(batchValues);\n    if (results.length < limit) {\n      cursor.continue();\n    }\n  }\n\n  function onGetAll(e) {\n    var values = e.target.result;\n    if (opts.descending) {\n      values = values.reverse();\n    }\n    processBatch(values);\n  }\n\n  function onResultsReady() {\n    var returnVal = {\n      total_rows: docCount,\n      offset: opts.skip,\n      rows: results\n    };\n    \n    /* istanbul ignore if */\n    if (opts.update_seq && updateSeq !== undefined) {\n      returnVal.update_seq = updateSeq;\n    }\n    callback(null, returnVal);\n  }\n\n  function onTxnComplete() {\n    if (opts.attachments) {\n      postProcessAttachments(results, opts.binary).then(onResultsReady);\n    } else {\n      onResultsReady();\n    }\n  }\n\n  // don't bother doing any requests if start > end or limit === 0\n  if (keyRangeError || limit === 0) {\n    return;\n  }\n  if (keys) {\n    return allDocsKeys(opts.keys, docStore, onBatch);\n  }\n  if (limit === -1) { // just fetch everything\n    return getAll(docStore, keyRange, onGetAll);\n  }\n  // else do a cursor\n  // choose a batch size based on the skip, since we'll need to skip that many\n  runBatchedCursor(docStore, keyRange, opts.descending, limit + skip, onBatch);\n}\n\n//\n// Blobs are not supported in all versions of IndexedDB, notably\n// Chrome <37 and Android <5. In those versions, storing a blob will throw.\n//\n// Various other blob bugs exist in Chrome v37-42 (inclusive).\n// Detecting them is expensive and confusing to users, and Chrome 37-42\n// is at very low usage worldwide, so we do a hacky userAgent check instead.\n//\n// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120\n// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916\n// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836\n//\nfunction checkBlobSupport(txn) {\n  return new Promise(function (resolve) {\n    var blob$$1 = createBlob(['']);\n    var req = txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob$$1, 'key');\n\n    req.onsuccess = function () {\n      var matchedChrome = navigator.userAgent.match(/Chrome\\/(\\d+)/);\n      var matchedEdge = navigator.userAgent.match(/Edge\\//);\n      // MS Edge pretends to be Chrome 42:\n      // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx\n      resolve(matchedEdge || !matchedChrome ||\n        parseInt(matchedChrome[1], 10) >= 43);\n    };\n\n    req.onerror = txn.onabort = function (e) {\n      // If the transaction aborts now its due to not being able to\n      // write to the database, likely due to the disk being full\n      e.preventDefault();\n      e.stopPropagation();\n      resolve(false);\n    };\n  }).catch(function () {\n    return false; // error, so assume unsupported\n  });\n}\n\nfunction countDocs(txn, cb) {\n  var index = txn.objectStore(DOC_STORE).index('deletedOrLocal');\n  index.count(IDBKeyRange.only('0')).onsuccess = function (e) {\n    cb(e.target.result);\n  };\n}\n\n// This task queue ensures that IDB open calls are done in their own tick\n\nvar running = false;\nvar queue = [];\n\nfunction tryCode(fun, err, res, PouchDB) {\n  try {\n    fun(err, res);\n  } catch (err) {\n    // Shouldn't happen, but in some odd cases\n    // IndexedDB implementations might throw a sync\n    // error, in which case this will at least log it.\n    PouchDB.emit('error', err);\n  }\n}\n\nfunction applyNext() {\n  if (running || !queue.length) {\n    return;\n  }\n  running = true;\n  queue.shift()();\n}\n\nfunction enqueueTask(action, callback, PouchDB) {\n  queue.push(function runAction() {\n    action(function runCallback(err, res) {\n      tryCode(callback, err, res, PouchDB);\n      running = false;\n      nextTick(function runNext() {\n        applyNext(PouchDB);\n      });\n    });\n  });\n  applyNext();\n}\n\nfunction changes(opts, api, dbName, idb) {\n  opts = clone(opts);\n\n  if (opts.continuous) {\n    var id = dbName + ':' + uuid();\n    changesHandler.addListener(dbName, id, api, opts);\n    changesHandler.notify(dbName);\n    return {\n      cancel: function () {\n        changesHandler.removeListener(dbName, id);\n      }\n    };\n  }\n\n  var docIds = opts.doc_ids && new ExportedSet(opts.doc_ids);\n\n  opts.since = opts.since || 0;\n  var lastSeq = opts.since;\n\n  var limit = 'limit' in opts ? opts.limit : -1;\n  if (limit === 0) {\n    limit = 1; // per CouchDB _changes spec\n  }\n\n  var results = [];\n  var numResults = 0;\n  var filter = filterChange(opts);\n  var docIdsToMetadata = new ExportedMap();\n\n  var txn;\n  var bySeqStore;\n  var docStore;\n  var docIdRevIndex;\n\n  function onBatch(batchKeys, batchValues, cursor) {\n    if (!cursor || !batchKeys.length) { // done\n      return;\n    }\n\n    var winningDocs = new Array(batchKeys.length);\n    var metadatas = new Array(batchKeys.length);\n\n    function processMetadataAndWinningDoc(metadata, winningDoc) {\n      var change = opts.processChange(winningDoc, metadata, opts);\n      lastSeq = change.seq = metadata.seq;\n\n      var filtered = filter(change);\n      if (typeof filtered === 'object') { // anything but true/false indicates error\n        return Promise.reject(filtered);\n      }\n\n      if (!filtered) {\n        return Promise.resolve();\n      }\n      numResults++;\n      if (opts.return_docs) {\n        results.push(change);\n      }\n      // process the attachment immediately\n      // for the benefit of live listeners\n      if (opts.attachments && opts.include_docs) {\n        return new Promise(function (resolve) {\n          fetchAttachmentsIfNecessary(winningDoc, opts, txn, function () {\n            postProcessAttachments([change], opts.binary).then(function () {\n              resolve(change);\n            });\n          });\n        });\n      } else {\n        return Promise.resolve(change);\n      }\n    }\n\n    function onBatchDone() {\n      var promises = [];\n      for (var i = 0, len = winningDocs.length; i < len; i++) {\n        if (numResults === limit) {\n          break;\n        }\n        var winningDoc = winningDocs[i];\n        if (!winningDoc) {\n          continue;\n        }\n        var metadata = metadatas[i];\n        promises.push(processMetadataAndWinningDoc(metadata, winningDoc));\n      }\n\n      Promise.all(promises).then(function (changes) {\n        for (var i = 0, len = changes.length; i < len; i++) {\n          if (changes[i]) {\n            opts.onChange(changes[i]);\n          }\n        }\n      }).catch(opts.complete);\n\n      if (numResults !== limit) {\n        cursor.continue();\n      }\n    }\n\n    // Fetch all metadatas/winningdocs from this batch in parallel, then process\n    // them all only once all data has been collected. This is done in parallel\n    // because it's faster than doing it one-at-a-time.\n    var numDone = 0;\n    batchValues.forEach(function (value, i) {\n      var doc = decodeDoc(value);\n      var seq = batchKeys[i];\n      fetchWinningDocAndMetadata(doc, seq, function (metadata, winningDoc) {\n        metadatas[i] = metadata;\n        winningDocs[i] = winningDoc;\n        if (++numDone === batchKeys.length) {\n          onBatchDone();\n        }\n      });\n    });\n  }\n\n  function onGetMetadata(doc, seq, metadata, cb) {\n    if (metadata.seq !== seq) {\n      // some other seq is later\n      return cb();\n    }\n\n    if (metadata.winningRev === doc._rev) {\n      // this is the winning doc\n      return cb(metadata, doc);\n    }\n\n    // fetch winning doc in separate request\n    var docIdRev = doc._id + '::' + metadata.winningRev;\n    var req = docIdRevIndex.get(docIdRev);\n    req.onsuccess = function (e) {\n      cb(metadata, decodeDoc(e.target.result));\n    };\n  }\n\n  function fetchWinningDocAndMetadata(doc, seq, cb) {\n    if (docIds && !docIds.has(doc._id)) {\n      return cb();\n    }\n\n    var metadata = docIdsToMetadata.get(doc._id);\n    if (metadata) { // cached\n      return onGetMetadata(doc, seq, metadata, cb);\n    }\n    // metadata not cached, have to go fetch it\n    docStore.get(doc._id).onsuccess = function (e) {\n      metadata = decodeMetadata(e.target.result);\n      docIdsToMetadata.set(doc._id, metadata);\n      onGetMetadata(doc, seq, metadata, cb);\n    };\n  }\n\n  function finish() {\n    opts.complete(null, {\n      results: results,\n      last_seq: lastSeq\n    });\n  }\n\n  function onTxnComplete() {\n    if (!opts.continuous && opts.attachments) {\n      // cannot guarantee that postProcessing was already done,\n      // so do it again\n      postProcessAttachments(results).then(finish);\n    } else {\n      finish();\n    }\n  }\n\n  var objectStores = [DOC_STORE, BY_SEQ_STORE];\n  if (opts.attachments) {\n    objectStores.push(ATTACH_STORE);\n  }\n  var txnResult = openTransactionSafely(idb, objectStores, 'readonly');\n  if (txnResult.error) {\n    return opts.complete(txnResult.error);\n  }\n  txn = txnResult.txn;\n  txn.onabort = idbError(opts.complete);\n  txn.oncomplete = onTxnComplete;\n\n  bySeqStore = txn.objectStore(BY_SEQ_STORE);\n  docStore = txn.objectStore(DOC_STORE);\n  docIdRevIndex = bySeqStore.index('_doc_id_rev');\n\n  var keyRange = (opts.since && !opts.descending) ?\n    IDBKeyRange.lowerBound(opts.since, true) : null;\n\n  runBatchedCursor(bySeqStore, keyRange, opts.descending, limit, onBatch);\n}\n\nvar cachedDBs = new ExportedMap();\nvar blobSupportPromise;\nvar openReqList = new ExportedMap();\n\nfunction IdbPouch(opts, callback) {\n  var api = this;\n\n  enqueueTask(function (thisCallback) {\n    init(api, opts, thisCallback);\n  }, callback, api.constructor);\n}\n\nfunction init(api, opts, callback) {\n\n  var dbName = opts.name;\n\n  var idb = null;\n  api._meta = null;\n\n  // called when creating a fresh new database\n  function createSchema(db) {\n    var docStore = db.createObjectStore(DOC_STORE, {keyPath : 'id'});\n    db.createObjectStore(BY_SEQ_STORE, {autoIncrement: true})\n      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});\n    db.createObjectStore(ATTACH_STORE, {keyPath: 'digest'});\n    db.createObjectStore(META_STORE, {keyPath: 'id', autoIncrement: false});\n    db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\n\n    // added in v2\n    docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {unique : false});\n\n    // added in v3\n    db.createObjectStore(LOCAL_STORE, {keyPath: '_id'});\n\n    // added in v4\n    var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE,\n      {autoIncrement: true});\n    attAndSeqStore.createIndex('seq', 'seq');\n    attAndSeqStore.createIndex('digestSeq', 'digestSeq', {unique: true});\n  }\n\n  // migration to version 2\n  // unfortunately \"deletedOrLocal\" is a misnomer now that we no longer\n  // store local docs in the main doc-store, but whaddyagonnado\n  function addDeletedOrLocalIndex(txn, callback) {\n    var docStore = txn.objectStore(DOC_STORE);\n    docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {unique : false});\n\n    docStore.openCursor().onsuccess = function (event) {\n      var cursor = event.target.result;\n      if (cursor) {\n        var metadata = cursor.value;\n        var deleted = isDeleted(metadata);\n        metadata.deletedOrLocal = deleted ? \"1\" : \"0\";\n        docStore.put(metadata);\n        cursor.continue();\n      } else {\n        callback();\n      }\n    };\n  }\n\n  // migration to version 3 (part 1)\n  function createLocalStoreSchema(db) {\n    db.createObjectStore(LOCAL_STORE, {keyPath: '_id'})\n      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});\n  }\n\n  // migration to version 3 (part 2)\n  function migrateLocalStore(txn, cb) {\n    var localStore = txn.objectStore(LOCAL_STORE);\n    var docStore = txn.objectStore(DOC_STORE);\n    var seqStore = txn.objectStore(BY_SEQ_STORE);\n\n    var cursor = docStore.openCursor();\n    cursor.onsuccess = function (event) {\n      var cursor = event.target.result;\n      if (cursor) {\n        var metadata = cursor.value;\n        var docId = metadata.id;\n        var local = isLocalId(docId);\n        var rev = winningRev(metadata);\n        if (local) {\n          var docIdRev = docId + \"::\" + rev;\n          // remove all seq entries\n          // associated with this docId\n          var start = docId + \"::\";\n          var end = docId + \"::~\";\n          var index = seqStore.index('_doc_id_rev');\n          var range = IDBKeyRange.bound(start, end, false, false);\n          var seqCursor = index.openCursor(range);\n          seqCursor.onsuccess = function (e) {\n            seqCursor = e.target.result;\n            if (!seqCursor) {\n              // done\n              docStore.delete(cursor.primaryKey);\n              cursor.continue();\n            } else {\n              var data = seqCursor.value;\n              if (data._doc_id_rev === docIdRev) {\n                localStore.put(data);\n              }\n              seqStore.delete(seqCursor.primaryKey);\n              seqCursor.continue();\n            }\n          };\n        } else {\n          cursor.continue();\n        }\n      } else if (cb) {\n        cb();\n      }\n    };\n  }\n\n  // migration to version 4 (part 1)\n  function addAttachAndSeqStore(db) {\n    var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE,\n      {autoIncrement: true});\n    attAndSeqStore.createIndex('seq', 'seq');\n    attAndSeqStore.createIndex('digestSeq', 'digestSeq', {unique: true});\n  }\n\n  // migration to version 4 (part 2)\n  function migrateAttsAndSeqs(txn, callback) {\n    var seqStore = txn.objectStore(BY_SEQ_STORE);\n    var attStore = txn.objectStore(ATTACH_STORE);\n    var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n\n    // need to actually populate the table. this is the expensive part,\n    // so as an optimization, check first that this database even\n    // contains attachments\n    var req = attStore.count();\n    req.onsuccess = function (e) {\n      var count = e.target.result;\n      if (!count) {\n        return callback(); // done\n      }\n\n      seqStore.openCursor().onsuccess = function (e) {\n        var cursor = e.target.result;\n        if (!cursor) {\n          return callback(); // done\n        }\n        var doc = cursor.value;\n        var seq = cursor.primaryKey;\n        var atts = Object.keys(doc._attachments || {});\n        var digestMap = {};\n        for (var j = 0; j < atts.length; j++) {\n          var att = doc._attachments[atts[j]];\n          digestMap[att.digest] = true; // uniq digests, just in case\n        }\n        var digests = Object.keys(digestMap);\n        for (j = 0; j < digests.length; j++) {\n          var digest = digests[j];\n          attAndSeqStore.put({\n            seq: seq,\n            digestSeq: digest + '::' + seq\n          });\n        }\n        cursor.continue();\n      };\n    };\n  }\n\n  // migration to version 5\n  // Instead of relying on on-the-fly migration of metadata,\n  // this brings the doc-store to its modern form:\n  // - metadata.winningrev\n  // - metadata.seq\n  // - stringify the metadata when storing it\n  function migrateMetadata(txn) {\n\n    function decodeMetadataCompat(storedObject) {\n      if (!storedObject.data) {\n        // old format, when we didn't store it stringified\n        storedObject.deleted = storedObject.deletedOrLocal === '1';\n        return storedObject;\n      }\n      return decodeMetadata(storedObject);\n    }\n\n    // ensure that every metadata has a winningRev and seq,\n    // which was previously created on-the-fly but better to migrate\n    var bySeqStore = txn.objectStore(BY_SEQ_STORE);\n    var docStore = txn.objectStore(DOC_STORE);\n    var cursor = docStore.openCursor();\n    cursor.onsuccess = function (e) {\n      var cursor = e.target.result;\n      if (!cursor) {\n        return; // done\n      }\n      var metadata = decodeMetadataCompat(cursor.value);\n\n      metadata.winningRev = metadata.winningRev ||\n        winningRev(metadata);\n\n      function fetchMetadataSeq() {\n        // metadata.seq was added post-3.2.0, so if it's missing,\n        // we need to fetch it manually\n        var start = metadata.id + '::';\n        var end = metadata.id + '::\\uffff';\n        var req = bySeqStore.index('_doc_id_rev').openCursor(\n          IDBKeyRange.bound(start, end));\n\n        var metadataSeq = 0;\n        req.onsuccess = function (e) {\n          var cursor = e.target.result;\n          if (!cursor) {\n            metadata.seq = metadataSeq;\n            return onGetMetadataSeq();\n          }\n          var seq = cursor.primaryKey;\n          if (seq > metadataSeq) {\n            metadataSeq = seq;\n          }\n          cursor.continue();\n        };\n      }\n\n      function onGetMetadataSeq() {\n        var metadataToStore = encodeMetadata(metadata,\n          metadata.winningRev, metadata.deleted);\n\n        var req = docStore.put(metadataToStore);\n        req.onsuccess = function () {\n          cursor.continue();\n        };\n      }\n\n      if (metadata.seq) {\n        return onGetMetadataSeq();\n      }\n\n      fetchMetadataSeq();\n    };\n\n  }\n\n  api._remote = false;\n  api.type = function () {\n    return 'idb';\n  };\n\n  api._id = toPromise(function (callback) {\n    callback(null, api._meta.instanceId);\n  });\n\n  api._bulkDocs = function idb_bulkDocs(req, reqOpts, callback) {\n    idbBulkDocs(opts, req, reqOpts, api, idb, callback);\n  };\n\n  // First we look up the metadata in the ids database, then we fetch the\n  // current revision(s) from the by sequence store\n  api._get = function idb_get(id, opts, callback) {\n    var doc;\n    var metadata;\n    var err;\n    var txn = opts.ctx;\n    if (!txn) {\n      var txnResult = openTransactionSafely(idb,\n        [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      txn = txnResult.txn;\n    }\n\n    function finish() {\n      callback(err, {doc: doc, metadata: metadata, ctx: txn});\n    }\n\n    txn.objectStore(DOC_STORE).get(id).onsuccess = function (e) {\n      metadata = decodeMetadata(e.target.result);\n      // we can determine the result here if:\n      // 1. there is no such document\n      // 2. the document is deleted and we don't ask about specific rev\n      // When we ask with opts.rev we expect the answer to be either\n      // doc (possibly with _deleted=true) or missing error\n      if (!metadata) {\n        err = createError(MISSING_DOC, 'missing');\n        return finish();\n      }\n\n      var rev;\n      if (!opts.rev) {\n        rev = metadata.winningRev;\n        var deleted = isDeleted(metadata);\n        if (deleted) {\n          err = createError(MISSING_DOC, \"deleted\");\n          return finish();\n        }\n      } else {\n        rev = opts.latest ? latest(opts.rev, metadata) : opts.rev;\n      }\n\n      var objectStore = txn.objectStore(BY_SEQ_STORE);\n      var key = metadata.id + '::' + rev;\n\n      objectStore.index('_doc_id_rev').get(key).onsuccess = function (e) {\n        doc = e.target.result;\n        if (doc) {\n          doc = decodeDoc(doc);\n        }\n        if (!doc) {\n          err = createError(MISSING_DOC, 'missing');\n          return finish();\n        }\n        finish();\n      };\n    };\n  };\n\n  api._getAttachment = function (docId, attachId, attachment, opts, callback) {\n    var txn;\n    if (opts.ctx) {\n      txn = opts.ctx;\n    } else {\n      var txnResult = openTransactionSafely(idb,\n        [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      txn = txnResult.txn;\n    }\n    var digest = attachment.digest;\n    var type = attachment.content_type;\n\n    txn.objectStore(ATTACH_STORE).get(digest).onsuccess = function (e) {\n      var body = e.target.result.body;\n      readBlobData(body, type, opts.binary, function (blobData) {\n        callback(null, blobData);\n      });\n    };\n  };\n\n  api._info = function idb_info(callback) {\n    var updateSeq;\n    var docCount;\n\n    var txnResult = openTransactionSafely(idb, [META_STORE, BY_SEQ_STORE], 'readonly');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var txn = txnResult.txn;\n    txn.objectStore(META_STORE).get(META_STORE).onsuccess = function (e) {\n      docCount = e.target.result.docCount;\n    };\n    txn.objectStore(BY_SEQ_STORE).openCursor(null, 'prev').onsuccess = function (e) {\n      var cursor = e.target.result;\n      updateSeq = cursor ? cursor.key : 0;\n    };\n\n    txn.oncomplete = function () {\n      callback(null, {\n        doc_count: docCount,\n        update_seq: updateSeq,\n        // for debugging\n        idb_attachment_format: (api._meta.blobSupport ? 'binary' : 'base64')\n      });\n    };\n  };\n\n  api._allDocs = function idb_allDocs(opts, callback) {\n    idbAllDocs(opts, idb, callback);\n  };\n\n  api._changes = function idbChanges(opts) {\n    return changes(opts, api, dbName, idb);\n  };\n\n  api._close = function (callback) {\n    // https://developer.mozilla.org/en-US/docs/IndexedDB/IDBDatabase#close\n    // \"Returns immediately and closes the connection in a separate thread...\"\n    idb.close();\n    cachedDBs.delete(dbName);\n    callback();\n  };\n\n  api._getRevisionTree = function (docId, callback) {\n    var txnResult = openTransactionSafely(idb, [DOC_STORE], 'readonly');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var txn = txnResult.txn;\n    var req = txn.objectStore(DOC_STORE).get(docId);\n    req.onsuccess = function (event) {\n      var doc = decodeMetadata(event.target.result);\n      if (!doc) {\n        callback(createError(MISSING_DOC));\n      } else {\n        callback(null, doc.rev_tree);\n      }\n    };\n  };\n\n  // This function removes revisions of document docId\n  // which are listed in revs and sets this document\n  // revision to to rev_tree\n  api._doCompaction = function (docId, revs, callback) {\n    var stores = [\n      DOC_STORE,\n      BY_SEQ_STORE,\n      ATTACH_STORE,\n      ATTACH_AND_SEQ_STORE\n    ];\n    var txnResult = openTransactionSafely(idb, stores, 'readwrite');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var txn = txnResult.txn;\n\n    var docStore = txn.objectStore(DOC_STORE);\n\n    docStore.get(docId).onsuccess = function (event) {\n      var metadata = decodeMetadata(event.target.result);\n      traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n                                                         revHash, ctx, opts) {\n        var rev = pos + '-' + revHash;\n        if (revs.indexOf(rev) !== -1) {\n          opts.status = 'missing';\n        }\n      });\n      compactRevs(revs, docId, txn);\n      var winningRev$$1 = metadata.winningRev;\n      var deleted = metadata.deleted;\n      txn.objectStore(DOC_STORE).put(\n        encodeMetadata(metadata, winningRev$$1, deleted));\n    };\n    txn.onabort = idbError(callback);\n    txn.oncomplete = function () {\n      callback();\n    };\n  };\n\n\n  api._getLocal = function (id, callback) {\n    var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readonly');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var tx = txnResult.txn;\n    var req = tx.objectStore(LOCAL_STORE).get(id);\n\n    req.onerror = idbError(callback);\n    req.onsuccess = function (e) {\n      var doc = e.target.result;\n      if (!doc) {\n        callback(createError(MISSING_DOC));\n      } else {\n        delete doc['_doc_id_rev']; // for backwards compat\n        callback(null, doc);\n      }\n    };\n  };\n\n  api._putLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    delete doc._revisions; // ignore this, trust the rev\n    var oldRev = doc._rev;\n    var id = doc._id;\n    if (!oldRev) {\n      doc._rev = '0-1';\n    } else {\n      doc._rev = '0-' + (parseInt(oldRev.split('-')[1], 10) + 1);\n    }\n\n    var tx = opts.ctx;\n    var ret;\n    if (!tx) {\n      var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      tx = txnResult.txn;\n      tx.onerror = idbError(callback);\n      tx.oncomplete = function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      };\n    }\n\n    var oStore = tx.objectStore(LOCAL_STORE);\n    var req;\n    if (oldRev) {\n      req = oStore.get(id);\n      req.onsuccess = function (e) {\n        var oldDoc = e.target.result;\n        if (!oldDoc || oldDoc._rev !== oldRev) {\n          callback(createError(REV_CONFLICT));\n        } else { // update\n          var req = oStore.put(doc);\n          req.onsuccess = function () {\n            ret = {ok: true, id: doc._id, rev: doc._rev};\n            if (opts.ctx) { // return immediately\n              callback(null, ret);\n            }\n          };\n        }\n      };\n    } else { // new doc\n      req = oStore.add(doc);\n      req.onerror = function (e) {\n        // constraint error, already exists\n        callback(createError(REV_CONFLICT));\n        e.preventDefault(); // avoid transaction abort\n        e.stopPropagation(); // avoid transaction onerror\n      };\n      req.onsuccess = function () {\n        ret = {ok: true, id: doc._id, rev: doc._rev};\n        if (opts.ctx) { // return immediately\n          callback(null, ret);\n        }\n      };\n    }\n  };\n\n  api._removeLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    var tx = opts.ctx;\n    if (!tx) {\n      var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      tx = txnResult.txn;\n      tx.oncomplete = function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      };\n    }\n    var ret;\n    var id = doc._id;\n    var oStore = tx.objectStore(LOCAL_STORE);\n    var req = oStore.get(id);\n\n    req.onerror = idbError(callback);\n    req.onsuccess = function (e) {\n      var oldDoc = e.target.result;\n      if (!oldDoc || oldDoc._rev !== doc._rev) {\n        callback(createError(MISSING_DOC));\n      } else {\n        oStore.delete(id);\n        ret = {ok: true, id: id, rev: '0-0'};\n        if (opts.ctx) { // return immediately\n          callback(null, ret);\n        }\n      }\n    };\n  };\n\n  api._destroy = function (opts, callback) {\n    changesHandler.removeAllListeners(dbName);\n\n    //Close open request for \"dbName\" database to fix ie delay.\n    var openReq = openReqList.get(dbName);\n    if (openReq && openReq.result) {\n      openReq.result.close();\n      cachedDBs.delete(dbName);\n    }\n    var req = indexedDB.deleteDatabase(dbName);\n\n    req.onsuccess = function () {\n      //Remove open request from the list.\n      openReqList.delete(dbName);\n      if (hasLocalStorage() && (dbName in localStorage)) {\n        delete localStorage[dbName];\n      }\n      callback(null, { 'ok': true });\n    };\n\n    req.onerror = idbError(callback);\n  };\n\n  var cached = cachedDBs.get(dbName);\n\n  if (cached) {\n    idb = cached.idb;\n    api._meta = cached.global;\n    return nextTick(function () {\n      callback(null, api);\n    });\n  }\n\n  var req = indexedDB.open(dbName, ADAPTER_VERSION);\n  openReqList.set(dbName, req);\n\n  req.onupgradeneeded = function (e) {\n    var db = e.target.result;\n    if (e.oldVersion < 1) {\n      return createSchema(db); // new db, initial schema\n    }\n    // do migrations\n\n    var txn = e.currentTarget.transaction;\n    // these migrations have to be done in this function, before\n    // control is returned to the event loop, because IndexedDB\n\n    if (e.oldVersion < 3) {\n      createLocalStoreSchema(db); // v2 -> v3\n    }\n    if (e.oldVersion < 4) {\n      addAttachAndSeqStore(db); // v3 -> v4\n    }\n\n    var migrations = [\n      addDeletedOrLocalIndex, // v1 -> v2\n      migrateLocalStore,      // v2 -> v3\n      migrateAttsAndSeqs,     // v3 -> v4\n      migrateMetadata         // v4 -> v5\n    ];\n\n    var i = e.oldVersion;\n\n    function next() {\n      var migration = migrations[i - 1];\n      i++;\n      if (migration) {\n        migration(txn, next);\n      }\n    }\n\n    next();\n  };\n\n  req.onsuccess = function (e) {\n\n    idb = e.target.result;\n\n    idb.onversionchange = function () {\n      idb.close();\n      cachedDBs.delete(dbName);\n    };\n\n    idb.onabort = function (e) {\n      guardedConsole('error', 'Database has a global failure', e.target.error);\n      idb.close();\n      cachedDBs.delete(dbName);\n    };\n\n    // Do a few setup operations (in parallel as much as possible):\n    // 1. Fetch meta doc\n    // 2. Check blob support\n    // 3. Calculate docCount\n    // 4. Generate an instanceId if necessary\n    // 5. Store docCount and instanceId on meta doc\n\n    var txn = idb.transaction([\n      META_STORE,\n      DETECT_BLOB_SUPPORT_STORE,\n      DOC_STORE\n    ], 'readwrite');\n\n    var storedMetaDoc = false;\n    var metaDoc;\n    var docCount;\n    var blobSupport;\n    var instanceId;\n\n    function completeSetup() {\n      if (typeof blobSupport === 'undefined' || !storedMetaDoc) {\n        return;\n      }\n      api._meta = {\n        name: dbName,\n        instanceId: instanceId,\n        blobSupport: blobSupport\n      };\n\n      cachedDBs.set(dbName, {\n        idb: idb,\n        global: api._meta\n      });\n      callback(null, api);\n    }\n\n    function storeMetaDocIfReady() {\n      if (typeof docCount === 'undefined' || typeof metaDoc === 'undefined') {\n        return;\n      }\n      var instanceKey = dbName + '_id';\n      if (instanceKey in metaDoc) {\n        instanceId = metaDoc[instanceKey];\n      } else {\n        metaDoc[instanceKey] = instanceId = uuid();\n      }\n      metaDoc.docCount = docCount;\n      txn.objectStore(META_STORE).put(metaDoc);\n    }\n\n    //\n    // fetch or generate the instanceId\n    //\n    txn.objectStore(META_STORE).get(META_STORE).onsuccess = function (e) {\n      metaDoc = e.target.result || { id: META_STORE };\n      storeMetaDocIfReady();\n    };\n\n    //\n    // countDocs\n    //\n    countDocs(txn, function (count) {\n      docCount = count;\n      storeMetaDocIfReady();\n    });\n\n    //\n    // check blob support\n    //\n    if (!blobSupportPromise) {\n      // make sure blob support is only checked once\n      blobSupportPromise = checkBlobSupport(txn);\n    }\n\n    blobSupportPromise.then(function (val) {\n      blobSupport = val;\n      completeSetup();\n    });\n\n    // only when the metadata put transaction has completed,\n    // consider the setup done\n    txn.oncomplete = function () {\n      storedMetaDoc = true;\n      completeSetup();\n    };\n    txn.onabort = idbError(callback);\n  };\n\n  req.onerror = function () {\n    var msg = 'Failed to open indexedDB, are you in private browsing mode?';\n    guardedConsole('error', msg);\n    callback(createError(IDB_ERROR, msg));\n  };\n}\n\nIdbPouch.valid = function () {\n  // Following #7085 buggy idb versions (typically Safari < 10.1) are\n  // considered valid.\n\n  // On Firefox SecurityError is thrown while referencing indexedDB if cookies\n  // are not allowed. `typeof indexedDB` also triggers the error.\n  try {\n    // some outdated implementations of IDB that appear on Samsung\n    // and HTC Android devices <4.4 are missing IDBKeyRange\n    return typeof indexedDB !== 'undefined' && typeof IDBKeyRange !== 'undefined';\n  } catch (e) {\n    return false;\n  }\n};\n\nfunction IDBPouch (PouchDB) {\n  PouchDB.adapter('idb', IdbPouch, true);\n}\n\n// dead simple promise pool, inspired by https://github.com/timdp/es6-promise-pool\n// but much smaller in code size. limits the number of concurrent promises that are executed\n\n\nfunction pool(promiseFactories, limit) {\n  return new Promise(function (resolve, reject) {\n    var running = 0;\n    var current = 0;\n    var done = 0;\n    var len = promiseFactories.length;\n    var err;\n\n    function runNext() {\n      running++;\n      promiseFactories[current++]().then(onSuccess, onError);\n    }\n\n    function doNext() {\n      if (++done === len) {\n        /* istanbul ignore if */\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      } else {\n        runNextBatch();\n      }\n    }\n\n    function onSuccess() {\n      running--;\n      doNext();\n    }\n\n    /* istanbul ignore next */\n    function onError(thisErr) {\n      running--;\n      err = err || thisErr;\n      doNext();\n    }\n\n    function runNextBatch() {\n      while (running < limit && current < len) {\n        runNext();\n      }\n    }\n\n    runNextBatch();\n  });\n}\n\nvar CHANGES_BATCH_SIZE = 25;\nvar MAX_SIMULTANEOUS_REVS = 50;\nvar CHANGES_TIMEOUT_BUFFER = 5000;\nvar DEFAULT_HEARTBEAT = 10000;\n\nvar supportsBulkGetMap = {};\n\nfunction readAttachmentsAsBlobOrBuffer(row) {\n  var doc = row.doc || row.ok;\n  var atts = doc._attachments;\n  if (!atts) {\n    return;\n  }\n  Object.keys(atts).forEach(function (filename) {\n    var att = atts[filename];\n    att.data = b64ToBluffer(att.data, att.content_type);\n  });\n}\n\nfunction encodeDocId(id) {\n  if (/^_design/.test(id)) {\n    return '_design/' + encodeURIComponent(id.slice(8));\n  }\n  if (/^_local/.test(id)) {\n    return '_local/' + encodeURIComponent(id.slice(7));\n  }\n  return encodeURIComponent(id);\n}\n\nfunction preprocessAttachments$1(doc) {\n  if (!doc._attachments || !Object.keys(doc._attachments)) {\n    return Promise.resolve();\n  }\n\n  return Promise.all(Object.keys(doc._attachments).map(function (key) {\n    var attachment = doc._attachments[key];\n    if (attachment.data && typeof attachment.data !== 'string') {\n      return new Promise(function (resolve) {\n        blobToBase64(attachment.data, resolve);\n      }).then(function (b64) {\n        attachment.data = b64;\n      });\n    }\n  }));\n}\n\nfunction hasUrlPrefix(opts) {\n  if (!opts.prefix) {\n    return false;\n  }\n  var protocol = parseUri(opts.prefix).protocol;\n  return protocol === 'http' || protocol === 'https';\n}\n\n// Get all the information you possibly can about the URI given by name and\n// return it as a suitable object.\nfunction getHost(name, opts) {\n  // encode db name if opts.prefix is a url (#5574)\n  if (hasUrlPrefix(opts)) {\n    var dbName = opts.name.substr(opts.prefix.length);\n    // Ensure prefix has a trailing slash\n    var prefix = opts.prefix.replace(/\\/?$/, '/');\n    name = prefix + encodeURIComponent(dbName);\n  }\n\n  var uri = parseUri(name);\n  if (uri.user || uri.password) {\n    uri.auth = {username: uri.user, password: uri.password};\n  }\n\n  // Split the path part of the URI into parts using '/' as the delimiter\n  // after removing any leading '/' and any trailing '/'\n  var parts = uri.path.replace(/(^\\/|\\/$)/g, '').split('/');\n\n  uri.db = parts.pop();\n  // Prevent double encoding of URI component\n  if (uri.db.indexOf('%') === -1) {\n    uri.db = encodeURIComponent(uri.db);\n  }\n\n  uri.path = parts.join('/');\n\n  return uri;\n}\n\n// Generate a URL with the host data given by opts and the given path\nfunction genDBUrl(opts, path) {\n  return genUrl(opts, opts.db + '/' + path);\n}\n\n// Generate a URL with the host data given by opts and the given path\nfunction genUrl(opts, path) {\n  // If the host already has a path, then we need to have a path delimiter\n  // Otherwise, the path delimiter is the empty string\n  var pathDel = !opts.path ? '' : '/';\n\n  // If the host already has a path, then we need to have a path delimiter\n  // Otherwise, the path delimiter is the empty string\n  return opts.protocol + '://' + opts.host +\n         (opts.port ? (':' + opts.port) : '') +\n         '/' + opts.path + pathDel + path;\n}\n\nfunction paramsToStr(params) {\n  return '?' + Object.keys(params).map(function (k) {\n    return k + '=' + encodeURIComponent(params[k]);\n  }).join('&');\n}\n\nfunction shouldCacheBust(opts) {\n  var ua = (typeof navigator !== 'undefined' && navigator.userAgent) ?\n      navigator.userAgent.toLowerCase() : '';\n  var isIE = ua.indexOf('msie') !== -1;\n  var isTrident = ua.indexOf('trident') !== -1;\n  var isEdge = ua.indexOf('edge') !== -1;\n  var isGET = !('method' in opts) || opts.method === 'GET';\n  return (isIE || isTrident || isEdge) && isGET;\n}\n\n// Implements the PouchDB API for dealing with CouchDB instances over HTTP\nfunction HttpPouch(opts, callback) {\n\n  // The functions that will be publicly available for HttpPouch\n  var api = this;\n\n  var host = getHost(opts.name, opts);\n  var dbUrl = genDBUrl(host, '');\n\n  opts = clone(opts);\n\n  var ourFetch = function (url, options) {\n\n    options = options || {};\n    options.headers = options.headers || new h();\n\n    if (opts.auth || host.auth) {\n      var nAuth = opts.auth || host.auth;\n      var str = nAuth.username + ':' + nAuth.password;\n      var token = thisBtoa(unescape(encodeURIComponent(str)));\n      options.headers.set('Authorization', 'Basic ' + token);\n    }\n\n    var headers = opts.headers || {};\n    Object.keys(headers).forEach(function (key) {\n      options.headers.append(key, headers[key]);\n    });\n\n    /* istanbul ignore if */\n    if (shouldCacheBust(options)) {\n      url += (url.indexOf('?') === -1 ? '?' : '&') + '_nonce=' + Date.now();\n    }\n\n    var fetchFun = opts.fetch || f$1;\n    return fetchFun(url, options);\n  };\n\n  function adapterFun$$1(name, fun) {\n    return adapterFun(name, getArguments(function (args) {\n      setup().then(function () {\n        return fun.apply(this, args);\n      }).catch(function (e) {\n        var callback = args.pop();\n        callback(e);\n      });\n    })).bind(api);\n  }\n\n  function fetchJSON(url, options, callback) {\n\n    var result = {};\n\n    options = options || {};\n    options.headers = options.headers || new h();\n\n    if (!options.headers.get('Content-Type')) {\n      options.headers.set('Content-Type', 'application/json');\n    }\n    if (!options.headers.get('Accept')) {\n      options.headers.set('Accept', 'application/json');\n    }\n\n    return ourFetch(url, options).then(function (response) {\n      result.ok = response.ok;\n      result.status = response.status;\n      return response.json();\n    }).then(function (json) {\n      result.data = json;\n      if (!result.ok) {\n        result.data.status = result.status;\n        var err = generateErrorFromResponse(result.data);\n        if (callback) {\n          return callback(err);\n        } else {\n          throw err;\n        }\n      }\n\n      if (Array.isArray(result.data)) {\n        result.data = result.data.map(function (v) {\n          if (v.error || v.missing) {\n            return generateErrorFromResponse(v);\n          } else {\n            return v;\n          }\n        });\n      }\n\n      if (callback) {\n        callback(null, result.data);\n      } else {\n        return result;\n      }\n    });\n  }\n\n  var setupPromise;\n\n  function setup() {\n    if (opts.skip_setup) {\n      return Promise.resolve();\n    }\n\n    // If there is a setup in process or previous successful setup\n    // done then we will use that\n    // If previous setups have been rejected we will try again\n    if (setupPromise) {\n      return setupPromise;\n    }\n\n    setupPromise = fetchJSON(dbUrl).catch(function (err) {\n      if (err && err.status && err.status === 404) {\n        // Doesnt exist, create it\n        explainError(404, 'PouchDB is just detecting if the remote exists.');\n        return fetchJSON(dbUrl, {method: 'PUT'});\n      } else {\n        return Promise.reject(err);\n      }\n    }).catch(function (err) {\n      // If we try to create a database that already exists, skipped in\n      // istanbul since its catching a race condition.\n      /* istanbul ignore if */\n      if (err && err.status && err.status === 412) {\n        return true;\n      }\n      return Promise.reject(err);\n    });\n\n    setupPromise.catch(function () {\n      setupPromise = null;\n    });\n\n    return setupPromise;\n  }\n\n  nextTick(function () {\n    callback(null, api);\n  });\n\n  api._remote = true;\n\n  /* istanbul ignore next */\n  api.type = function () {\n    return 'http';\n  };\n\n  api.id = adapterFun$$1('id', function (callback) {\n    ourFetch(genUrl(host, '')).then(function (response) {\n      return response.json();\n    }).then(function (result) {\n      var uuid$$1 = (result && result.uuid) ?\n          (result.uuid + host.db) : genDBUrl(host, '');\n      callback(null, uuid$$1);\n    }).catch(function (err) {\n      callback(err);\n    });\n  });\n\n  // Sends a POST request to the host calling the couchdb _compact function\n  //    version: The version of CouchDB it is running\n  api.compact = adapterFun$$1('compact', function (opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = clone(opts);\n\n    fetchJSON(genDBUrl(host, '_compact'), {method: 'POST'}).then(function () {\n      function ping() {\n        api.info(function (err, res) {\n          // CouchDB may send a \"compact_running:true\" if it's\n          // already compacting. PouchDB Server doesn't.\n          /* istanbul ignore else */\n          if (res && !res.compact_running) {\n            callback(null, {ok: true});\n          } else {\n            setTimeout(ping, opts.interval || 200);\n          }\n        });\n      }\n      // Ping the http if it's finished compaction\n      ping();\n    });\n  });\n\n  api.bulkGet = adapterFun('bulkGet', function (opts, callback) {\n    var self = this;\n\n    function doBulkGet(cb) {\n      var params = {};\n      if (opts.revs) {\n        params.revs = true;\n      }\n      if (opts.attachments) {\n        /* istanbul ignore next */\n        params.attachments = true;\n      }\n      if (opts.latest) {\n        params.latest = true;\n      }\n      fetchJSON(genDBUrl(host, '_bulk_get' + paramsToStr(params)), {\n        method: 'POST',\n        body: JSON.stringify({ docs: opts.docs})\n      }).then(function (result) {\n        if (opts.attachments && opts.binary) {\n          result.data.results.forEach(function (res) {\n            res.docs.forEach(readAttachmentsAsBlobOrBuffer);\n          });\n        }\n        cb(null, result.data);\n      }).catch(cb);\n    }\n\n    /* istanbul ignore next */\n    function doBulkGetShim() {\n      // avoid \"url too long error\" by splitting up into multiple requests\n      var batchSize = MAX_SIMULTANEOUS_REVS;\n      var numBatches = Math.ceil(opts.docs.length / batchSize);\n      var numDone = 0;\n      var results = new Array(numBatches);\n\n      function onResult(batchNum) {\n        return function (err, res) {\n          // err is impossible because shim returns a list of errs in that case\n          results[batchNum] = res.results;\n          if (++numDone === numBatches) {\n            callback(null, {results: flatten(results)});\n          }\n        };\n      }\n\n      for (var i = 0; i < numBatches; i++) {\n        var subOpts = pick(opts, ['revs', 'attachments', 'binary', 'latest']);\n        subOpts.docs = opts.docs.slice(i * batchSize,\n          Math.min(opts.docs.length, (i + 1) * batchSize));\n        bulkGet(self, subOpts, onResult(i));\n      }\n    }\n\n    // mark the whole database as either supporting or not supporting _bulk_get\n    var dbUrl = genUrl(host, '');\n    var supportsBulkGet = supportsBulkGetMap[dbUrl];\n\n    /* istanbul ignore next */\n    if (typeof supportsBulkGet !== 'boolean') {\n      // check if this database supports _bulk_get\n      doBulkGet(function (err, res) {\n        if (err) {\n          supportsBulkGetMap[dbUrl] = false;\n          explainError(\n            err.status,\n            'PouchDB is just detecting if the remote ' +\n            'supports the _bulk_get API.'\n          );\n          doBulkGetShim();\n        } else {\n          supportsBulkGetMap[dbUrl] = true;\n          callback(null, res);\n        }\n      });\n    } else if (supportsBulkGet) {\n      doBulkGet(callback);\n    } else {\n      doBulkGetShim();\n    }\n  });\n\n  // Calls GET on the host, which gets back a JSON string containing\n  //    couchdb: A welcome string\n  //    version: The version of CouchDB it is running\n  api._info = function (callback) {\n    setup().then(function () {\n      return ourFetch(genDBUrl(host, ''));\n    }).then(function (response) {\n      return response.json();\n    }).then(function (info) {\n      info.host = genDBUrl(host, '');\n      callback(null, info);\n    }).catch(callback);\n  };\n\n  api.fetch = function (path, options) {\n    return setup().then(function () {\n      return ourFetch(genDBUrl(host, path), options);\n    });\n  };\n\n  // Get the document with the given id from the database given by host.\n  // The id could be solely the _id in the database, or it may be a\n  // _design/ID or _local/ID path\n  api.get = adapterFun$$1('get', function (id, opts, callback) {\n    // If no options were given, set the callback to the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = clone(opts);\n\n    // List of parameters to add to the GET request\n    var params = {};\n\n    if (opts.revs) {\n      params.revs = true;\n    }\n\n    if (opts.revs_info) {\n      params.revs_info = true;\n    }\n\n    if (opts.latest) {\n      params.latest = true;\n    }\n\n    if (opts.open_revs) {\n      if (opts.open_revs !== \"all\") {\n        opts.open_revs = JSON.stringify(opts.open_revs);\n      }\n      params.open_revs = opts.open_revs;\n    }\n\n    if (opts.rev) {\n      params.rev = opts.rev;\n    }\n\n    if (opts.conflicts) {\n      params.conflicts = opts.conflicts;\n    }\n\n    /* istanbul ignore if */\n    if (opts.update_seq) {\n      params.update_seq = opts.update_seq;\n    }\n\n    id = encodeDocId(id);\n\n    function fetchAttachments(doc) {\n      var atts = doc._attachments;\n      var filenames = atts && Object.keys(atts);\n      if (!atts || !filenames.length) {\n        return;\n      }\n      // we fetch these manually in separate XHRs, because\n      // Sync Gateway would normally send it back as multipart/mixed,\n      // which we cannot parse. Also, this is more efficient than\n      // receiving attachments as base64-encoded strings.\n      function fetchData(filename) {\n        var att = atts[filename];\n        var path = encodeDocId(doc._id) + '/' + encodeAttachmentId(filename) +\n            '?rev=' + doc._rev;\n        return ourFetch(genDBUrl(host, path)).then(function (response) {\n          if (typeof process !== 'undefined' && !process.browser) {\n            return response.buffer();\n          } else {\n            /* istanbul ignore next */\n            return response.blob();\n          }\n        }).then(function (blob) {\n          if (opts.binary) {\n            // TODO: Can we remove this?\n            if (typeof process !== 'undefined' && !process.browser) {\n              blob.type = att.content_type;\n            }\n            return blob;\n          }\n          return new Promise(function (resolve) {\n            blobToBase64(blob, resolve);\n          });\n        }).then(function (data) {\n          delete att.stub;\n          delete att.length;\n          att.data = data;\n        });\n      }\n\n      var promiseFactories = filenames.map(function (filename) {\n        return function () {\n          return fetchData(filename);\n        };\n      });\n\n      // This limits the number of parallel xhr requests to 5 any time\n      // to avoid issues with maximum browser request limits\n      return pool(promiseFactories, 5);\n    }\n\n    function fetchAllAttachments(docOrDocs) {\n      if (Array.isArray(docOrDocs)) {\n        return Promise.all(docOrDocs.map(function (doc) {\n          if (doc.ok) {\n            return fetchAttachments(doc.ok);\n          }\n        }));\n      }\n      return fetchAttachments(docOrDocs);\n    }\n\n    var url = genDBUrl(host, id + paramsToStr(params));\n    fetchJSON(url).then(function (res) {\n      return Promise.resolve().then(function () {\n        if (opts.attachments) {\n          return fetchAllAttachments(res.data);\n        }\n      }).then(function () {\n        callback(null, res.data);\n      });\n    }).catch(function (e) {\n      e.docId = id;\n      callback(e);\n    });\n  });\n\n\n  // Delete the document given by doc from the database given by host.\n  api.remove = adapterFun$$1('remove', function (docOrId, optsOrRev, opts, cb) {\n    var doc;\n    if (typeof optsOrRev === 'string') {\n      // id, rev, opts, callback style\n      doc = {\n        _id: docOrId,\n        _rev: optsOrRev\n      };\n      if (typeof opts === 'function') {\n        cb = opts;\n        opts = {};\n      }\n    } else {\n      // doc, opts, callback style\n      doc = docOrId;\n      if (typeof optsOrRev === 'function') {\n        cb = optsOrRev;\n        opts = {};\n      } else {\n        cb = opts;\n        opts = optsOrRev;\n      }\n    }\n\n    var rev = (doc._rev || opts.rev);\n    var url = genDBUrl(host, encodeDocId(doc._id)) + '?rev=' + rev;\n\n    fetchJSON(url, {method: 'DELETE'}, cb).catch(cb);\n  });\n\n  function encodeAttachmentId(attachmentId) {\n    return attachmentId.split(\"/\").map(encodeURIComponent).join(\"/\");\n  }\n\n  // Get the attachment\n  api.getAttachment = adapterFun$$1('getAttachment', function (docId, attachmentId,\n                                                            opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    var params = opts.rev ? ('?rev=' + opts.rev) : '';\n    var url = genDBUrl(host, encodeDocId(docId)) + '/' +\n        encodeAttachmentId(attachmentId) + params;\n    var contentType;\n    ourFetch(url, {method: 'GET'}).then(function (response) {\n      contentType = response.headers.get('content-type');\n      if (!response.ok) {\n        throw response;\n      } else {\n        if (typeof process !== 'undefined' && !process.browser) {\n          return response.buffer();\n        } else {\n          /* istanbul ignore next */\n          return response.blob();\n        }\n      }\n    }).then(function (blob) {\n      // TODO: also remove\n      if (typeof process !== 'undefined' && !process.browser) {\n        blob.type = contentType;\n      }\n      callback(null, blob);\n    }).catch(function (err) {\n      callback(err);\n    });\n  });\n\n  // Remove the attachment given by the id and rev\n  api.removeAttachment =  adapterFun$$1('removeAttachment', function (docId,\n                                                                   attachmentId,\n                                                                   rev,\n                                                                   callback) {\n    var url = genDBUrl(host, encodeDocId(docId) + '/' +\n                       encodeAttachmentId(attachmentId)) + '?rev=' + rev;\n    fetchJSON(url, {method: 'DELETE'}, callback).catch(callback);\n  });\n\n  // Add the attachment given by blob and its contentType property\n  // to the document with the given id, the revision given by rev, and\n  // add it to the database given by host.\n  api.putAttachment = adapterFun$$1('putAttachment', function (docId, attachmentId,\n                                                            rev, blob,\n                                                            type, callback) {\n    if (typeof type === 'function') {\n      callback = type;\n      type = blob;\n      blob = rev;\n      rev = null;\n    }\n    var id = encodeDocId(docId) + '/' + encodeAttachmentId(attachmentId);\n    var url = genDBUrl(host, id);\n    if (rev) {\n      url += '?rev=' + rev;\n    }\n\n    if (typeof blob === 'string') {\n      // input is assumed to be a base64 string\n      var binary;\n      try {\n        binary = thisAtob(blob);\n      } catch (err) {\n        return callback(createError(BAD_ARG,\n                        'Attachment is not a valid base64 string'));\n      }\n      blob = binary ? binStringToBluffer(binary, type) : '';\n    }\n\n    // Add the attachment\n    fetchJSON(url, {\n      headers: new h({'Content-Type': type}),\n      method: 'PUT',\n      body: blob\n    }, callback).catch(callback);\n  });\n\n  // Update/create multiple documents given by req in the database\n  // given by host.\n  api._bulkDocs = function (req, opts, callback) {\n    // If new_edits=false then it prevents the database from creating\n    // new revision numbers for the documents. Instead it just uses\n    // the old ones. This is used in database replication.\n    req.new_edits = opts.new_edits;\n\n    setup().then(function () {\n      return Promise.all(req.docs.map(preprocessAttachments$1));\n    }).then(function () {\n      // Update/create the documents\n      return fetchJSON(genDBUrl(host, '_bulk_docs'), {\n        method: 'POST',\n        body: JSON.stringify(req)\n      }, callback);\n    }).catch(callback);\n  };\n\n\n  // Update/create document\n  api._put = function (doc, opts, callback) {\n    setup().then(function () {\n      return preprocessAttachments$1(doc);\n    }).then(function () {\n      return fetchJSON(genDBUrl(host, encodeDocId(doc._id)), {\n        method: 'PUT',\n        body: JSON.stringify(doc)\n      });\n    }).then(function (result) {\n      callback(null, result.data);\n    }).catch(function (err) {\n      err.docId = doc && doc._id;\n      callback(err);\n    });\n  };\n\n\n  // Get a listing of the documents in the database given\n  // by host and ordered by increasing id.\n  api.allDocs = adapterFun$$1('allDocs', function (opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = clone(opts);\n\n    // List of parameters to add to the GET request\n    var params = {};\n    var body;\n    var method = 'GET';\n\n    if (opts.conflicts) {\n      params.conflicts = true;\n    }\n\n    /* istanbul ignore if */\n    if (opts.update_seq) {\n      params.update_seq = true;\n    }\n\n    if (opts.descending) {\n      params.descending = true;\n    }\n\n    if (opts.include_docs) {\n      params.include_docs = true;\n    }\n\n    // added in CouchDB 1.6.0\n    if (opts.attachments) {\n      params.attachments = true;\n    }\n\n    if (opts.key) {\n      params.key = JSON.stringify(opts.key);\n    }\n\n    if (opts.start_key) {\n      opts.startkey = opts.start_key;\n    }\n\n    if (opts.startkey) {\n      params.startkey = JSON.stringify(opts.startkey);\n    }\n\n    if (opts.end_key) {\n      opts.endkey = opts.end_key;\n    }\n\n    if (opts.endkey) {\n      params.endkey = JSON.stringify(opts.endkey);\n    }\n\n    if (typeof opts.inclusive_end !== 'undefined') {\n      params.inclusive_end = !!opts.inclusive_end;\n    }\n\n    if (typeof opts.limit !== 'undefined') {\n      params.limit = opts.limit;\n    }\n\n    if (typeof opts.skip !== 'undefined') {\n      params.skip = opts.skip;\n    }\n\n    var paramStr = paramsToStr(params);\n\n    if (typeof opts.keys !== 'undefined') {\n      method = 'POST';\n      body = {keys: opts.keys};\n    }\n\n    fetchJSON(genDBUrl(host, '_all_docs' + paramStr), {\n       method: method,\n      body: JSON.stringify(body)\n    }).then(function (result) {\n      if (opts.include_docs && opts.attachments && opts.binary) {\n        result.data.rows.forEach(readAttachmentsAsBlobOrBuffer);\n      }\n      callback(null, result.data);\n    }).catch(callback);\n  });\n\n  // Get a list of changes made to documents in the database given by host.\n  // TODO According to the README, there should be two other methods here,\n  // api.changes.addListener and api.changes.removeListener.\n  api._changes = function (opts) {\n\n    // We internally page the results of a changes request, this means\n    // if there is a large set of changes to be returned we can start\n    // processing them quicker instead of waiting on the entire\n    // set of changes to return and attempting to process them at once\n    var batchSize = 'batch_size' in opts ? opts.batch_size : CHANGES_BATCH_SIZE;\n\n    opts = clone(opts);\n\n    if (opts.continuous && !('heartbeat' in opts)) {\n      opts.heartbeat = DEFAULT_HEARTBEAT;\n    }\n\n    var requestTimeout = ('timeout' in opts) ? opts.timeout : 30 * 1000;\n\n    // ensure CHANGES_TIMEOUT_BUFFER applies\n    if ('timeout' in opts && opts.timeout &&\n      (requestTimeout - opts.timeout) < CHANGES_TIMEOUT_BUFFER) {\n        requestTimeout = opts.timeout + CHANGES_TIMEOUT_BUFFER;\n    }\n\n    /* istanbul ignore if */\n    if ('heartbeat' in opts && opts.heartbeat &&\n       (requestTimeout - opts.heartbeat) < CHANGES_TIMEOUT_BUFFER) {\n        requestTimeout = opts.heartbeat + CHANGES_TIMEOUT_BUFFER;\n    }\n\n    var params = {};\n    if ('timeout' in opts && opts.timeout) {\n      params.timeout = opts.timeout;\n    }\n\n    var limit = (typeof opts.limit !== 'undefined') ? opts.limit : false;\n    var leftToFetch = limit;\n\n    if (opts.style) {\n      params.style = opts.style;\n    }\n\n    if (opts.include_docs || opts.filter && typeof opts.filter === 'function') {\n      params.include_docs = true;\n    }\n\n    if (opts.attachments) {\n      params.attachments = true;\n    }\n\n    if (opts.continuous) {\n      params.feed = 'longpoll';\n    }\n\n    if (opts.seq_interval) {\n      params.seq_interval = opts.seq_interval;\n    }\n\n    if (opts.conflicts) {\n      params.conflicts = true;\n    }\n\n    if (opts.descending) {\n      params.descending = true;\n    }\n    \n    /* istanbul ignore if */\n    if (opts.update_seq) {\n      params.update_seq = true;\n    }\n\n    if ('heartbeat' in opts) {\n      // If the heartbeat value is false, it disables the default heartbeat\n      if (opts.heartbeat) {\n        params.heartbeat = opts.heartbeat;\n      }\n    }\n\n    if (opts.filter && typeof opts.filter === 'string') {\n      params.filter = opts.filter;\n    }\n\n    if (opts.view && typeof opts.view === 'string') {\n      params.filter = '_view';\n      params.view = opts.view;\n    }\n\n    // If opts.query_params exists, pass it through to the changes request.\n    // These parameters may be used by the filter on the source database.\n    if (opts.query_params && typeof opts.query_params === 'object') {\n      for (var param_name in opts.query_params) {\n        /* istanbul ignore else */\n        if (opts.query_params.hasOwnProperty(param_name)) {\n          params[param_name] = opts.query_params[param_name];\n        }\n      }\n    }\n\n    var method = 'GET';\n    var body;\n\n    if (opts.doc_ids) {\n      // set this automagically for the user; it's annoying that couchdb\n      // requires both a \"filter\" and a \"doc_ids\" param.\n      params.filter = '_doc_ids';\n      method = 'POST';\n      body = {doc_ids: opts.doc_ids };\n    }\n    /* istanbul ignore next */\n    else if (opts.selector) {\n      // set this automagically for the user, similar to above\n      params.filter = '_selector';\n      method = 'POST';\n      body = {selector: opts.selector };\n    }\n\n    var controller = new a();\n    var lastFetchedSeq;\n\n    // Get all the changes starting wtih the one immediately after the\n    // sequence number given by since.\n    var fetchData = function (since, callback) {\n      if (opts.aborted) {\n        return;\n      }\n      params.since = since;\n      // \"since\" can be any kind of json object in Cloudant/CouchDB 2.x\n      /* istanbul ignore next */\n      if (typeof params.since === \"object\") {\n        params.since = JSON.stringify(params.since);\n      }\n\n      if (opts.descending) {\n        if (limit) {\n          params.limit = leftToFetch;\n        }\n      } else {\n        params.limit = (!limit || leftToFetch > batchSize) ?\n          batchSize : leftToFetch;\n      }\n\n      // Set the options for the ajax call\n      var url = genDBUrl(host, '_changes' + paramsToStr(params));\n      var fetchOpts = {\n        signal: controller.signal,\n        method: method,\n        body: JSON.stringify(body)\n      };\n      lastFetchedSeq = since;\n\n      /* istanbul ignore if */\n      if (opts.aborted) {\n        return;\n      }\n\n      // Get the changes\n      setup().then(function () {\n        return fetchJSON(url, fetchOpts, callback);\n      }).catch(callback);\n    };\n\n    // If opts.since exists, get all the changes from the sequence\n    // number given by opts.since. Otherwise, get all the changes\n    // from the sequence number 0.\n    var results = {results: []};\n\n    var fetched = function (err, res) {\n      if (opts.aborted) {\n        return;\n      }\n      var raw_results_length = 0;\n      // If the result of the ajax call (res) contains changes (res.results)\n      if (res && res.results) {\n        raw_results_length = res.results.length;\n        results.last_seq = res.last_seq;\n        var pending = null;\n        var lastSeq = null;\n        // Attach 'pending' property if server supports it (CouchDB 2.0+)\n        /* istanbul ignore if */\n        if (typeof res.pending === 'number') {\n          pending = res.pending;\n        }\n        if (typeof results.last_seq === 'string' || typeof results.last_seq === 'number') {\n          lastSeq = results.last_seq;\n        }\n        // For each change\n        var req = {};\n        req.query = opts.query_params;\n        res.results = res.results.filter(function (c) {\n          leftToFetch--;\n          var ret = filterChange(opts)(c);\n          if (ret) {\n            if (opts.include_docs && opts.attachments && opts.binary) {\n              readAttachmentsAsBlobOrBuffer(c);\n            }\n            if (opts.return_docs) {\n              results.results.push(c);\n            }\n            opts.onChange(c, pending, lastSeq);\n          }\n          return ret;\n        });\n      } else if (err) {\n        // In case of an error, stop listening for changes and call\n        // opts.complete\n        opts.aborted = true;\n        opts.complete(err);\n        return;\n      }\n\n      // The changes feed may have timed out with no results\n      // if so reuse last update sequence\n      if (res && res.last_seq) {\n        lastFetchedSeq = res.last_seq;\n      }\n\n      var finished = (limit && leftToFetch <= 0) ||\n        (res && raw_results_length < batchSize) ||\n        (opts.descending);\n\n      if ((opts.continuous && !(limit && leftToFetch <= 0)) || !finished) {\n        // Queue a call to fetch again with the newest sequence number\n        nextTick(function () { fetchData(lastFetchedSeq, fetched); });\n      } else {\n        // We're done, call the callback\n        opts.complete(null, results);\n      }\n    };\n\n    fetchData(opts.since || 0, fetched);\n\n    // Return a method to cancel this method from processing any more\n    return {\n      cancel: function () {\n        opts.aborted = true;\n        controller.abort();\n      }\n    };\n  };\n\n  // Given a set of document/revision IDs (given by req), tets the subset of\n  // those that do NOT correspond to revisions stored in the database.\n  // See http://wiki.apache.org/couchdb/HttpPostRevsDiff\n  api.revsDiff = adapterFun$$1('revsDiff', function (req, opts, callback) {\n    // If no options were given, set the callback to be the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    // Get the missing document/revision IDs\n    fetchJSON(genDBUrl(host, '_revs_diff'), {\n      method: 'POST',\n      body: JSON.stringify(req)\n    }, callback).catch(callback);\n  });\n\n  api._close = function (callback) {\n    callback();\n  };\n\n  api._destroy = function (options, callback) {\n    fetchJSON(genDBUrl(host, ''), {method: 'DELETE'}).then(function (json) {\n      callback(null, json);\n    }).catch(function (err) {\n      /* istanbul ignore if */\n      if (err.status === 404) {\n        callback(null, {ok: true});\n      } else {\n        callback(err);\n      }\n    });\n  };\n}\n\n// HttpPouch is a valid adapter.\nHttpPouch.valid = function () {\n  return true;\n};\n\nfunction HttpPouch$1 (PouchDB) {\n  PouchDB.adapter('http', HttpPouch, false);\n  PouchDB.adapter('https', HttpPouch, false);\n}\n\nfunction QueryParseError(message) {\n  this.status = 400;\n  this.name = 'query_parse_error';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, QueryParseError);\n  } catch (e) {}\n}\n\ninherits(QueryParseError, Error);\n\nfunction NotFoundError(message) {\n  this.status = 404;\n  this.name = 'not_found';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, NotFoundError);\n  } catch (e) {}\n}\n\ninherits(NotFoundError, Error);\n\nfunction BuiltInError(message) {\n  this.status = 500;\n  this.name = 'invalid_value';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, BuiltInError);\n  } catch (e) {}\n}\n\ninherits(BuiltInError, Error);\n\nfunction promisedCallback(promise, callback) {\n  if (callback) {\n    promise.then(function (res) {\n      nextTick(function () {\n        callback(null, res);\n      });\n    }, function (reason) {\n      nextTick(function () {\n        callback(reason);\n      });\n    });\n  }\n  return promise;\n}\n\nfunction callbackify(fun) {\n  return getArguments(function (args) {\n    var cb = args.pop();\n    var promise = fun.apply(this, args);\n    if (typeof cb === 'function') {\n      promisedCallback(promise, cb);\n    }\n    return promise;\n  });\n}\n\n// Promise finally util similar to Q.finally\nfunction fin(promise, finalPromiseFactory) {\n  return promise.then(function (res) {\n    return finalPromiseFactory().then(function () {\n      return res;\n    });\n  }, function (reason) {\n    return finalPromiseFactory().then(function () {\n      throw reason;\n    });\n  });\n}\n\nfunction sequentialize(queue, promiseFactory) {\n  return function () {\n    var args = arguments;\n    var that = this;\n    return queue.add(function () {\n      return promiseFactory.apply(that, args);\n    });\n  };\n}\n\n// uniq an array of strings, order not guaranteed\n// similar to underscore/lodash _.uniq\nfunction uniq(arr) {\n  var theSet = new ExportedSet(arr);\n  var result = new Array(theSet.size);\n  var index = -1;\n  theSet.forEach(function (value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\nfunction mapToKeysArray(map) {\n  var result = new Array(map.size);\n  var index = -1;\n  map.forEach(function (value, key) {\n    result[++index] = key;\n  });\n  return result;\n}\n\nfunction createBuiltInError(name) {\n  var message = 'builtin ' + name +\n    ' function requires map values to be numbers' +\n    ' or number arrays';\n  return new BuiltInError(message);\n}\n\nfunction sum(values) {\n  var result = 0;\n  for (var i = 0, len = values.length; i < len; i++) {\n    var num = values[i];\n    if (typeof num !== 'number') {\n      if (Array.isArray(num)) {\n        // lists of numbers are also allowed, sum them separately\n        result = typeof result === 'number' ? [result] : result;\n        for (var j = 0, jLen = num.length; j < jLen; j++) {\n          var jNum = num[j];\n          if (typeof jNum !== 'number') {\n            throw createBuiltInError('_sum');\n          } else if (typeof result[j] === 'undefined') {\n            result.push(jNum);\n          } else {\n            result[j] += jNum;\n          }\n        }\n      } else { // not array/number\n        throw createBuiltInError('_sum');\n      }\n    } else if (typeof result === 'number') {\n      result += num;\n    } else { // add number to array\n      result[0] += num;\n    }\n  }\n  return result;\n}\n\nvar log = guardedConsole.bind(null, 'log');\nvar isArray = Array.isArray;\nvar toJSON = JSON.parse;\n\nfunction evalFunctionWithEval(func, emit) {\n  return scopeEval(\n    \"return (\" + func.replace(/;\\s*$/, \"\") + \");\",\n    {\n      emit: emit,\n      sum: sum,\n      log: log,\n      isArray: isArray,\n      toJSON: toJSON\n    }\n  );\n}\n\n/*\n * Simple task queue to sequentialize actions. Assumes\n * callbacks will eventually fire (once).\n */\n\n\nfunction TaskQueue$1() {\n  this.promise = new Promise(function (fulfill) {fulfill(); });\n}\nTaskQueue$1.prototype.add = function (promiseFactory) {\n  this.promise = this.promise.catch(function () {\n    // just recover\n  }).then(function () {\n    return promiseFactory();\n  });\n  return this.promise;\n};\nTaskQueue$1.prototype.finish = function () {\n  return this.promise;\n};\n\nfunction stringify(input) {\n  if (!input) {\n    return 'undefined'; // backwards compat for empty reduce\n  }\n  // for backwards compat with mapreduce, functions/strings are stringified\n  // as-is. everything else is JSON-stringified.\n  switch (typeof input) {\n    case 'function':\n      // e.g. a mapreduce map\n      return input.toString();\n    case 'string':\n      // e.g. a mapreduce built-in _reduce function\n      return input.toString();\n    default:\n      // e.g. a JSON object in the case of mango queries\n      return JSON.stringify(input);\n  }\n}\n\n/* create a string signature for a view so we can cache it and uniq it */\nfunction createViewSignature(mapFun, reduceFun) {\n  // the \"undefined\" part is for backwards compatibility\n  return stringify(mapFun) + stringify(reduceFun) + 'undefined';\n}\n\nfunction createView(sourceDB, viewName, mapFun, reduceFun, temporary, localDocName) {\n  var viewSignature = createViewSignature(mapFun, reduceFun);\n\n  var cachedViews;\n  if (!temporary) {\n    // cache this to ensure we don't try to update the same view twice\n    cachedViews = sourceDB._cachedViews = sourceDB._cachedViews || {};\n    if (cachedViews[viewSignature]) {\n      return cachedViews[viewSignature];\n    }\n  }\n\n  var promiseForView = sourceDB.info().then(function (info) {\n\n    var depDbName = info.db_name + '-mrview-' +\n      (temporary ? 'temp' : stringMd5(viewSignature));\n\n    // save the view name in the source db so it can be cleaned up if necessary\n    // (e.g. when the _design doc is deleted, remove all associated view data)\n    function diffFunction(doc) {\n      doc.views = doc.views || {};\n      var fullViewName = viewName;\n      if (fullViewName.indexOf('/') === -1) {\n        fullViewName = viewName + '/' + viewName;\n      }\n      var depDbs = doc.views[fullViewName] = doc.views[fullViewName] || {};\n      /* istanbul ignore if */\n      if (depDbs[depDbName]) {\n        return; // no update necessary\n      }\n      depDbs[depDbName] = true;\n      return doc;\n    }\n    return upsert(sourceDB, '_local/' + localDocName, diffFunction).then(function () {\n      return sourceDB.registerDependentDatabase(depDbName).then(function (res) {\n        var db = res.db;\n        db.auto_compaction = true;\n        var view = {\n          name: depDbName,\n          db: db,\n          sourceDB: sourceDB,\n          adapter: sourceDB.adapter,\n          mapFun: mapFun,\n          reduceFun: reduceFun\n        };\n        return view.db.get('_local/lastSeq').catch(function (err) {\n          /* istanbul ignore if */\n          if (err.status !== 404) {\n            throw err;\n          }\n        }).then(function (lastSeqDoc) {\n          view.seq = lastSeqDoc ? lastSeqDoc.seq : 0;\n          if (cachedViews) {\n            view.db.once('destroyed', function () {\n              delete cachedViews[viewSignature];\n            });\n          }\n          return view;\n        });\n      });\n    });\n  });\n\n  if (cachedViews) {\n    cachedViews[viewSignature] = promiseForView;\n  }\n  return promiseForView;\n}\n\nvar persistentQueues = {};\nvar tempViewQueue = new TaskQueue$1();\nvar CHANGES_BATCH_SIZE$1 = 50;\n\nfunction parseViewName(name) {\n  // can be either 'ddocname/viewname' or just 'viewname'\n  // (where the ddoc name is the same)\n  return name.indexOf('/') === -1 ? [name, name] : name.split('/');\n}\n\nfunction isGenOne(changes) {\n  // only return true if the current change is 1-\n  // and there are no other leafs\n  return changes.length === 1 && /^1-/.test(changes[0].rev);\n}\n\nfunction emitError(db, e) {\n  try {\n    db.emit('error', e);\n  } catch (err) {\n    guardedConsole('error',\n      'The user\\'s map/reduce function threw an uncaught error.\\n' +\n      'You can debug this error by doing:\\n' +\n      'myDatabase.on(\\'error\\', function (err) { debugger; });\\n' +\n      'Please double-check your map/reduce function.');\n    guardedConsole('error', e);\n  }\n}\n\n/**\n * Returns an \"abstract\" mapreduce object of the form:\n *\n *   {\n *     query: queryFun,\n *     viewCleanup: viewCleanupFun\n *   }\n *\n * Arguments are:\n *\n * localDoc: string\n *   This is for the local doc that gets saved in order to track the\n *   \"dependent\" DBs and clean them up for viewCleanup. It should be\n *   unique, so that indexer plugins don't collide with each other.\n * mapper: function (mapFunDef, emit)\n *   Returns a map function based on the mapFunDef, which in the case of\n *   normal map/reduce is just the de-stringified function, but may be\n *   something else, such as an object in the case of pouchdb-find.\n * reducer: function (reduceFunDef)\n *   Ditto, but for reducing. Modules don't have to support reducing\n *   (e.g. pouchdb-find).\n * ddocValidator: function (ddoc, viewName)\n *   Throws an error if the ddoc or viewName is not valid.\n *   This could be a way to communicate to the user that the configuration for the\n *   indexer is invalid.\n */\nfunction createAbstractMapReduce(localDocName, mapper, reducer, ddocValidator) {\n\n  function tryMap(db, fun, doc) {\n    // emit an event if there was an error thrown by a map function.\n    // putting try/catches in a single function also avoids deoptimizations.\n    try {\n      fun(doc);\n    } catch (e) {\n      emitError(db, e);\n    }\n  }\n\n  function tryReduce(db, fun, keys, values, rereduce) {\n    // same as above, but returning the result or an error. there are two separate\n    // functions to avoid extra memory allocations since the tryCode() case is used\n    // for custom map functions (common) vs this function, which is only used for\n    // custom reduce functions (rare)\n    try {\n      return {output : fun(keys, values, rereduce)};\n    } catch (e) {\n      emitError(db, e);\n      return {error: e};\n    }\n  }\n\n  function sortByKeyThenValue(x, y) {\n    var keyCompare = collate(x.key, y.key);\n    return keyCompare !== 0 ? keyCompare : collate(x.value, y.value);\n  }\n\n  function sliceResults(results, limit, skip) {\n    skip = skip || 0;\n    if (typeof limit === 'number') {\n      return results.slice(skip, limit + skip);\n    } else if (skip > 0) {\n      return results.slice(skip);\n    }\n    return results;\n  }\n\n  function rowToDocId(row) {\n    var val = row.value;\n    // Users can explicitly specify a joined doc _id, or it\n    // defaults to the doc _id that emitted the key/value.\n    var docId = (val && typeof val === 'object' && val._id) || row.id;\n    return docId;\n  }\n\n  function readAttachmentsAsBlobOrBuffer(res) {\n    res.rows.forEach(function (row) {\n      var atts = row.doc && row.doc._attachments;\n      if (!atts) {\n        return;\n      }\n      Object.keys(atts).forEach(function (filename) {\n        var att = atts[filename];\n        atts[filename].data = b64ToBluffer(att.data, att.content_type);\n      });\n    });\n  }\n\n  function postprocessAttachments(opts) {\n    return function (res) {\n      if (opts.include_docs && opts.attachments && opts.binary) {\n        readAttachmentsAsBlobOrBuffer(res);\n      }\n      return res;\n    };\n  }\n\n  function addHttpParam(paramName, opts, params, asJson) {\n    // add an http param from opts to params, optionally json-encoded\n    var val = opts[paramName];\n    if (typeof val !== 'undefined') {\n      if (asJson) {\n        val = encodeURIComponent(JSON.stringify(val));\n      }\n      params.push(paramName + '=' + val);\n    }\n  }\n\n  function coerceInteger(integerCandidate) {\n    if (typeof integerCandidate !== 'undefined') {\n      var asNumber = Number(integerCandidate);\n      // prevents e.g. '1foo' or '1.1' being coerced to 1\n      if (!isNaN(asNumber) && asNumber === parseInt(integerCandidate, 10)) {\n        return asNumber;\n      } else {\n        return integerCandidate;\n      }\n    }\n  }\n\n  function coerceOptions(opts) {\n    opts.group_level = coerceInteger(opts.group_level);\n    opts.limit = coerceInteger(opts.limit);\n    opts.skip = coerceInteger(opts.skip);\n    return opts;\n  }\n\n  function checkPositiveInteger(number) {\n    if (number) {\n      if (typeof number !== 'number') {\n        return  new QueryParseError('Invalid value for integer: \"' +\n          number + '\"');\n      }\n      if (number < 0) {\n        return new QueryParseError('Invalid value for positive integer: ' +\n          '\"' + number + '\"');\n      }\n    }\n  }\n\n  function checkQueryParseError(options, fun) {\n    var startkeyName = options.descending ? 'endkey' : 'startkey';\n    var endkeyName = options.descending ? 'startkey' : 'endkey';\n\n    if (typeof options[startkeyName] !== 'undefined' &&\n      typeof options[endkeyName] !== 'undefined' &&\n      collate(options[startkeyName], options[endkeyName]) > 0) {\n      throw new QueryParseError('No rows can match your key range, ' +\n        'reverse your start_key and end_key or set {descending : true}');\n    } else if (fun.reduce && options.reduce !== false) {\n      if (options.include_docs) {\n        throw new QueryParseError('{include_docs:true} is invalid for reduce');\n      } else if (options.keys && options.keys.length > 1 &&\n        !options.group && !options.group_level) {\n        throw new QueryParseError('Multi-key fetches for reduce views must use ' +\n          '{group: true}');\n      }\n    }\n    ['group_level', 'limit', 'skip'].forEach(function (optionName) {\n      var error = checkPositiveInteger(options[optionName]);\n      if (error) {\n        throw error;\n      }\n    });\n  }\n\n  function httpQuery(db, fun, opts) {\n    // List of parameters to add to the PUT request\n    var params = [];\n    var body;\n    var method = 'GET';\n    var ok, status;\n\n    // If opts.reduce exists and is defined, then add it to the list\n    // of parameters.\n    // If reduce=false then the results are that of only the map function\n    // not the final result of map and reduce.\n    addHttpParam('reduce', opts, params);\n    addHttpParam('include_docs', opts, params);\n    addHttpParam('attachments', opts, params);\n    addHttpParam('limit', opts, params);\n    addHttpParam('descending', opts, params);\n    addHttpParam('group', opts, params);\n    addHttpParam('group_level', opts, params);\n    addHttpParam('skip', opts, params);\n    addHttpParam('stale', opts, params);\n    addHttpParam('conflicts', opts, params);\n    addHttpParam('startkey', opts, params, true);\n    addHttpParam('start_key', opts, params, true);\n    addHttpParam('endkey', opts, params, true);\n    addHttpParam('end_key', opts, params, true);\n    addHttpParam('inclusive_end', opts, params);\n    addHttpParam('key', opts, params, true);\n    addHttpParam('update_seq', opts, params);\n\n    // Format the list of parameters into a valid URI query string\n    params = params.join('&');\n    params = params === '' ? '' : '?' + params;\n\n    // If keys are supplied, issue a POST to circumvent GET query string limits\n    // see http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options\n    if (typeof opts.keys !== 'undefined') {\n      var MAX_URL_LENGTH = 2000;\n      // according to http://stackoverflow.com/a/417184/680742,\n      // the de facto URL length limit is 2000 characters\n\n      var keysAsString =\n        'keys=' + encodeURIComponent(JSON.stringify(opts.keys));\n      if (keysAsString.length + params.length + 1 <= MAX_URL_LENGTH) {\n        // If the keys are short enough, do a GET. we do this to work around\n        // Safari not understanding 304s on POSTs (see pouchdb/pouchdb#1239)\n        params += (params[0] === '?' ? '&' : '?') + keysAsString;\n      } else {\n        method = 'POST';\n        if (typeof fun === 'string') {\n          body = {keys: opts.keys};\n        } else { // fun is {map : mapfun}, so append to this\n          fun.keys = opts.keys;\n        }\n      }\n    }\n\n    // We are referencing a query defined in the design doc\n    if (typeof fun === 'string') {\n      var parts = parseViewName(fun);\n      return db.fetch('_design/' + parts[0] + '/_view/' + parts[1] + params, {\n        headers: new h({'Content-Type': 'application/json'}),\n        method: method,\n        body: JSON.stringify(body)\n      }).then(function (response) {\n        ok = response.ok;\n        status = response.status;\n        return response.json();\n      }).then(function (result) {\n        if (!ok) {\n          result.status = status;\n          throw generateErrorFromResponse(result);\n        }\n        // fail the entire request if the result contains an error\n        result.rows.forEach(function (row) {\n          /* istanbul ignore if */\n          if (row.value && row.value.error && row.value.error === \"builtin_reduce_error\") {\n            throw new Error(row.reason);\n          }\n        });\n        return result;\n      }).then(postprocessAttachments(opts));\n    }\n\n    // We are using a temporary view, terrible for performance, good for testing\n    body = body || {};\n    Object.keys(fun).forEach(function (key) {\n      if (Array.isArray(fun[key])) {\n        body[key] = fun[key];\n      } else {\n        body[key] = fun[key].toString();\n      }\n    });\n\n    return db.fetch('_temp_view' + params, {\n      headers: new h({'Content-Type': 'application/json'}),\n      method: 'POST',\n      body: JSON.stringify(body)\n    }).then(function (response) {\n        ok = response.ok;\n        status = response.status;\n      return response.json();\n    }).then(function (result) {\n      if (!ok) {\n        result.status = status;\n        throw generateErrorFromResponse(result);\n      }\n      return result;\n    }).then(postprocessAttachments(opts));\n  }\n\n  // custom adapters can define their own api._query\n  // and override the default behavior\n  /* istanbul ignore next */\n  function customQuery(db, fun, opts) {\n    return new Promise(function (resolve, reject) {\n      db._query(fun, opts, function (err, res) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(res);\n      });\n    });\n  }\n\n  // custom adapters can define their own api._viewCleanup\n  // and override the default behavior\n  /* istanbul ignore next */\n  function customViewCleanup(db) {\n    return new Promise(function (resolve, reject) {\n      db._viewCleanup(function (err, res) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(res);\n      });\n    });\n  }\n\n  function defaultsTo(value) {\n    return function (reason) {\n      /* istanbul ignore else */\n      if (reason.status === 404) {\n        return value;\n      } else {\n        throw reason;\n      }\n    };\n  }\n\n  // returns a promise for a list of docs to update, based on the input docId.\n  // the order doesn't matter, because post-3.2.0, bulkDocs\n  // is an atomic operation in all three adapters.\n  function getDocsToPersist(docId, view, docIdsToChangesAndEmits) {\n    var metaDocId = '_local/doc_' + docId;\n    var defaultMetaDoc = {_id: metaDocId, keys: []};\n    var docData = docIdsToChangesAndEmits.get(docId);\n    var indexableKeysToKeyValues = docData[0];\n    var changes = docData[1];\n\n    function getMetaDoc() {\n      if (isGenOne(changes)) {\n        // generation 1, so we can safely assume initial state\n        // for performance reasons (avoids unnecessary GETs)\n        return Promise.resolve(defaultMetaDoc);\n      }\n      return view.db.get(metaDocId).catch(defaultsTo(defaultMetaDoc));\n    }\n\n    function getKeyValueDocs(metaDoc) {\n      if (!metaDoc.keys.length) {\n        // no keys, no need for a lookup\n        return Promise.resolve({rows: []});\n      }\n      return view.db.allDocs({\n        keys: metaDoc.keys,\n        include_docs: true\n      });\n    }\n\n    function processKeyValueDocs(metaDoc, kvDocsRes) {\n      var kvDocs = [];\n      var oldKeys = new ExportedSet();\n\n      for (var i = 0, len = kvDocsRes.rows.length; i < len; i++) {\n        var row = kvDocsRes.rows[i];\n        var doc = row.doc;\n        if (!doc) { // deleted\n          continue;\n        }\n        kvDocs.push(doc);\n        oldKeys.add(doc._id);\n        doc._deleted = !indexableKeysToKeyValues.has(doc._id);\n        if (!doc._deleted) {\n          var keyValue = indexableKeysToKeyValues.get(doc._id);\n          if ('value' in keyValue) {\n            doc.value = keyValue.value;\n          }\n        }\n      }\n      var newKeys = mapToKeysArray(indexableKeysToKeyValues);\n      newKeys.forEach(function (key) {\n        if (!oldKeys.has(key)) {\n          // new doc\n          var kvDoc = {\n            _id: key\n          };\n          var keyValue = indexableKeysToKeyValues.get(key);\n          if ('value' in keyValue) {\n            kvDoc.value = keyValue.value;\n          }\n          kvDocs.push(kvDoc);\n        }\n      });\n      metaDoc.keys = uniq(newKeys.concat(metaDoc.keys));\n      kvDocs.push(metaDoc);\n\n      return kvDocs;\n    }\n\n    return getMetaDoc().then(function (metaDoc) {\n      return getKeyValueDocs(metaDoc).then(function (kvDocsRes) {\n        return processKeyValueDocs(metaDoc, kvDocsRes);\n      });\n    });\n  }\n\n  // updates all emitted key/value docs and metaDocs in the mrview database\n  // for the given batch of documents from the source database\n  function saveKeyValues(view, docIdsToChangesAndEmits, seq) {\n    var seqDocId = '_local/lastSeq';\n    return view.db.get(seqDocId)\n      .catch(defaultsTo({_id: seqDocId, seq: 0}))\n      .then(function (lastSeqDoc) {\n        var docIds = mapToKeysArray(docIdsToChangesAndEmits);\n        return Promise.all(docIds.map(function (docId) {\n          return getDocsToPersist(docId, view, docIdsToChangesAndEmits);\n        })).then(function (listOfDocsToPersist) {\n          var docsToPersist = flatten(listOfDocsToPersist);\n          lastSeqDoc.seq = seq;\n          docsToPersist.push(lastSeqDoc);\n          // write all docs in a single operation, update the seq once\n          return view.db.bulkDocs({docs : docsToPersist});\n        });\n      });\n  }\n\n  function getQueue(view) {\n    var viewName = typeof view === 'string' ? view : view.name;\n    var queue = persistentQueues[viewName];\n    if (!queue) {\n      queue = persistentQueues[viewName] = new TaskQueue$1();\n    }\n    return queue;\n  }\n\n  function updateView(view) {\n    return sequentialize(getQueue(view), function () {\n      return updateViewInQueue(view);\n    })();\n  }\n\n  function updateViewInQueue(view) {\n    // bind the emit function once\n    var mapResults;\n    var doc;\n\n    function emit(key, value) {\n      var output = {id: doc._id, key: normalizeKey(key)};\n      // Don't explicitly store the value unless it's defined and non-null.\n      // This saves on storage space, because often people don't use it.\n      if (typeof value !== 'undefined' && value !== null) {\n        output.value = normalizeKey(value);\n      }\n      mapResults.push(output);\n    }\n\n    var mapFun = mapper(view.mapFun, emit);\n\n    var currentSeq = view.seq || 0;\n\n    function processChange(docIdsToChangesAndEmits, seq) {\n      return function () {\n        return saveKeyValues(view, docIdsToChangesAndEmits, seq);\n      };\n    }\n\n    var queue = new TaskQueue$1();\n\n    function processNextBatch() {\n      return view.sourceDB.changes({\n        return_docs: true,\n        conflicts: true,\n        include_docs: true,\n        style: 'all_docs',\n        since: currentSeq,\n        limit: CHANGES_BATCH_SIZE$1\n      }).then(processBatch);\n    }\n\n    function processBatch(response) {\n      var results = response.results;\n      if (!results.length) {\n        return;\n      }\n      var docIdsToChangesAndEmits = createDocIdsToChangesAndEmits(results);\n      queue.add(processChange(docIdsToChangesAndEmits, currentSeq));\n      if (results.length < CHANGES_BATCH_SIZE$1) {\n        return;\n      }\n      return processNextBatch();\n    }\n\n    function createDocIdsToChangesAndEmits(results) {\n      var docIdsToChangesAndEmits = new ExportedMap();\n      for (var i = 0, len = results.length; i < len; i++) {\n        var change = results[i];\n        if (change.doc._id[0] !== '_') {\n          mapResults = [];\n          doc = change.doc;\n\n          if (!doc._deleted) {\n            tryMap(view.sourceDB, mapFun, doc);\n          }\n          mapResults.sort(sortByKeyThenValue);\n\n          var indexableKeysToKeyValues = createIndexableKeysToKeyValues(mapResults);\n          docIdsToChangesAndEmits.set(change.doc._id, [\n            indexableKeysToKeyValues,\n            change.changes\n          ]);\n        }\n        currentSeq = change.seq;\n      }\n      return docIdsToChangesAndEmits;\n    }\n\n    function createIndexableKeysToKeyValues(mapResults) {\n      var indexableKeysToKeyValues = new ExportedMap();\n      var lastKey;\n      for (var i = 0, len = mapResults.length; i < len; i++) {\n        var emittedKeyValue = mapResults[i];\n        var complexKey = [emittedKeyValue.key, emittedKeyValue.id];\n        if (i > 0 && collate(emittedKeyValue.key, lastKey) === 0) {\n          complexKey.push(i); // dup key+id, so make it unique\n        }\n        indexableKeysToKeyValues.set(toIndexableString(complexKey), emittedKeyValue);\n        lastKey = emittedKeyValue.key;\n      }\n      return indexableKeysToKeyValues;\n    }\n\n    return processNextBatch().then(function () {\n      return queue.finish();\n    }).then(function () {\n      view.seq = currentSeq;\n    });\n  }\n\n  function reduceView(view, results, options) {\n    if (options.group_level === 0) {\n      delete options.group_level;\n    }\n\n    var shouldGroup = options.group || options.group_level;\n\n    var reduceFun = reducer(view.reduceFun);\n\n    var groups = [];\n    var lvl = isNaN(options.group_level) ? Number.POSITIVE_INFINITY :\n      options.group_level;\n    results.forEach(function (e) {\n      var last = groups[groups.length - 1];\n      var groupKey = shouldGroup ? e.key : null;\n\n      // only set group_level for array keys\n      if (shouldGroup && Array.isArray(groupKey)) {\n        groupKey = groupKey.slice(0, lvl);\n      }\n\n      if (last && collate(last.groupKey, groupKey) === 0) {\n        last.keys.push([e.key, e.id]);\n        last.values.push(e.value);\n        return;\n      }\n      groups.push({\n        keys: [[e.key, e.id]],\n        values: [e.value],\n        groupKey: groupKey\n      });\n    });\n    results = [];\n    for (var i = 0, len = groups.length; i < len; i++) {\n      var e = groups[i];\n      var reduceTry = tryReduce(view.sourceDB, reduceFun, e.keys, e.values, false);\n      if (reduceTry.error && reduceTry.error instanceof BuiltInError) {\n        // CouchDB returns an error if a built-in errors out\n        throw reduceTry.error;\n      }\n      results.push({\n        // CouchDB just sets the value to null if a non-built-in errors out\n        value: reduceTry.error ? null : reduceTry.output,\n        key: e.groupKey\n      });\n    }\n    // no total_rows/offset when reducing\n    return {rows: sliceResults(results, options.limit, options.skip)};\n  }\n\n  function queryView(view, opts) {\n    return sequentialize(getQueue(view), function () {\n      return queryViewInQueue(view, opts);\n    })();\n  }\n\n  function queryViewInQueue(view, opts) {\n    var totalRows;\n    var shouldReduce = view.reduceFun && opts.reduce !== false;\n    var skip = opts.skip || 0;\n    if (typeof opts.keys !== 'undefined' && !opts.keys.length) {\n      // equivalent query\n      opts.limit = 0;\n      delete opts.keys;\n    }\n\n    function fetchFromView(viewOpts) {\n      viewOpts.include_docs = true;\n      return view.db.allDocs(viewOpts).then(function (res) {\n        totalRows = res.total_rows;\n        return res.rows.map(function (result) {\n\n          // implicit migration - in older versions of PouchDB,\n          // we explicitly stored the doc as {id: ..., key: ..., value: ...}\n          // this is tested in a migration test\n          /* istanbul ignore next */\n          if ('value' in result.doc && typeof result.doc.value === 'object' &&\n            result.doc.value !== null) {\n            var keys = Object.keys(result.doc.value).sort();\n            // this detection method is not perfect, but it's unlikely the user\n            // emitted a value which was an object with these 3 exact keys\n            var expectedKeys = ['id', 'key', 'value'];\n            if (!(keys < expectedKeys || keys > expectedKeys)) {\n              return result.doc.value;\n            }\n          }\n\n          var parsedKeyAndDocId = parseIndexableString(result.doc._id);\n          return {\n            key: parsedKeyAndDocId[0],\n            id: parsedKeyAndDocId[1],\n            value: ('value' in result.doc ? result.doc.value : null)\n          };\n        });\n      });\n    }\n\n    function onMapResultsReady(rows) {\n      var finalResults;\n      if (shouldReduce) {\n        finalResults = reduceView(view, rows, opts);\n      } else {\n        finalResults = {\n          total_rows: totalRows,\n          offset: skip,\n          rows: rows\n        };\n      }\n      /* istanbul ignore if */\n      if (opts.update_seq) {\n        finalResults.update_seq = view.seq;\n      }\n      if (opts.include_docs) {\n        var docIds = uniq(rows.map(rowToDocId));\n\n        return view.sourceDB.allDocs({\n          keys: docIds,\n          include_docs: true,\n          conflicts: opts.conflicts,\n          attachments: opts.attachments,\n          binary: opts.binary\n        }).then(function (allDocsRes) {\n          var docIdsToDocs = new ExportedMap();\n          allDocsRes.rows.forEach(function (row) {\n            docIdsToDocs.set(row.id, row.doc);\n          });\n          rows.forEach(function (row) {\n            var docId = rowToDocId(row);\n            var doc = docIdsToDocs.get(docId);\n            if (doc) {\n              row.doc = doc;\n            }\n          });\n          return finalResults;\n        });\n      } else {\n        return finalResults;\n      }\n    }\n\n    if (typeof opts.keys !== 'undefined') {\n      var keys = opts.keys;\n      var fetchPromises = keys.map(function (key) {\n        var viewOpts = {\n          startkey : toIndexableString([key]),\n          endkey   : toIndexableString([key, {}])\n        };\n        /* istanbul ignore if */\n        if (opts.update_seq) {\n          viewOpts.update_seq = true;\n        }\n        return fetchFromView(viewOpts);\n      });\n      return Promise.all(fetchPromises).then(flatten).then(onMapResultsReady);\n    } else { // normal query, no 'keys'\n      var viewOpts = {\n        descending : opts.descending\n      };\n      /* istanbul ignore if */\n      if (opts.update_seq) {\n        viewOpts.update_seq = true;\n      }\n      var startkey;\n      var endkey;\n      if ('start_key' in opts) {\n        startkey = opts.start_key;\n      }\n      if ('startkey' in opts) {\n        startkey = opts.startkey;\n      }\n      if ('end_key' in opts) {\n        endkey = opts.end_key;\n      }\n      if ('endkey' in opts) {\n        endkey = opts.endkey;\n      }\n      if (typeof startkey !== 'undefined') {\n        viewOpts.startkey = opts.descending ?\n          toIndexableString([startkey, {}]) :\n          toIndexableString([startkey]);\n      }\n      if (typeof endkey !== 'undefined') {\n        var inclusiveEnd = opts.inclusive_end !== false;\n        if (opts.descending) {\n          inclusiveEnd = !inclusiveEnd;\n        }\n\n        viewOpts.endkey = toIndexableString(\n          inclusiveEnd ? [endkey, {}] : [endkey]);\n      }\n      if (typeof opts.key !== 'undefined') {\n        var keyStart = toIndexableString([opts.key]);\n        var keyEnd = toIndexableString([opts.key, {}]);\n        if (viewOpts.descending) {\n          viewOpts.endkey = keyStart;\n          viewOpts.startkey = keyEnd;\n        } else {\n          viewOpts.startkey = keyStart;\n          viewOpts.endkey = keyEnd;\n        }\n      }\n      if (!shouldReduce) {\n        if (typeof opts.limit === 'number') {\n          viewOpts.limit = opts.limit;\n        }\n        viewOpts.skip = skip;\n      }\n      return fetchFromView(viewOpts).then(onMapResultsReady);\n    }\n  }\n\n  function httpViewCleanup(db) {\n    return db.fetch('_view_cleanup', {\n      headers: new h({'Content-Type': 'application/json'}),\n      method: 'POST'\n    }).then(function (response) {\n      return response.json();\n    });\n  }\n\n  function localViewCleanup(db) {\n    return db.get('_local/' + localDocName).then(function (metaDoc) {\n      var docsToViews = new ExportedMap();\n      Object.keys(metaDoc.views).forEach(function (fullViewName) {\n        var parts = parseViewName(fullViewName);\n        var designDocName = '_design/' + parts[0];\n        var viewName = parts[1];\n        var views = docsToViews.get(designDocName);\n        if (!views) {\n          views = new ExportedSet();\n          docsToViews.set(designDocName, views);\n        }\n        views.add(viewName);\n      });\n      var opts = {\n        keys : mapToKeysArray(docsToViews),\n        include_docs : true\n      };\n      return db.allDocs(opts).then(function (res) {\n        var viewsToStatus = {};\n        res.rows.forEach(function (row) {\n          var ddocName = row.key.substring(8); // cuts off '_design/'\n          docsToViews.get(row.key).forEach(function (viewName) {\n            var fullViewName = ddocName + '/' + viewName;\n            /* istanbul ignore if */\n            if (!metaDoc.views[fullViewName]) {\n              // new format, without slashes, to support PouchDB 2.2.0\n              // migration test in pouchdb's browser.migration.js verifies this\n              fullViewName = viewName;\n            }\n            var viewDBNames = Object.keys(metaDoc.views[fullViewName]);\n            // design doc deleted, or view function nonexistent\n            var statusIsGood = row.doc && row.doc.views &&\n              row.doc.views[viewName];\n            viewDBNames.forEach(function (viewDBName) {\n              viewsToStatus[viewDBName] =\n                viewsToStatus[viewDBName] || statusIsGood;\n            });\n          });\n        });\n        var dbsToDelete = Object.keys(viewsToStatus).filter(\n          function (viewDBName) { return !viewsToStatus[viewDBName]; });\n        var destroyPromises = dbsToDelete.map(function (viewDBName) {\n          return sequentialize(getQueue(viewDBName), function () {\n            return new db.constructor(viewDBName, db.__opts).destroy();\n          })();\n        });\n        return Promise.all(destroyPromises).then(function () {\n          return {ok: true};\n        });\n      });\n    }, defaultsTo({ok: true}));\n  }\n\n  function queryPromised(db, fun, opts) {\n    /* istanbul ignore next */\n    if (typeof db._query === 'function') {\n      return customQuery(db, fun, opts);\n    }\n    if (isRemote(db)) {\n      return httpQuery(db, fun, opts);\n    }\n\n    if (typeof fun !== 'string') {\n      // temp_view\n      checkQueryParseError(opts, fun);\n\n      tempViewQueue.add(function () {\n        var createViewPromise = createView(\n          /* sourceDB */ db,\n          /* viewName */ 'temp_view/temp_view',\n          /* mapFun */ fun.map,\n          /* reduceFun */ fun.reduce,\n          /* temporary */ true,\n          /* localDocName */ localDocName);\n        return createViewPromise.then(function (view) {\n          return fin(updateView(view).then(function () {\n            return queryView(view, opts);\n          }), function () {\n            return view.db.destroy();\n          });\n        });\n      });\n      return tempViewQueue.finish();\n    } else {\n      // persistent view\n      var fullViewName = fun;\n      var parts = parseViewName(fullViewName);\n      var designDocName = parts[0];\n      var viewName = parts[1];\n      return db.get('_design/' + designDocName).then(function (doc) {\n        var fun = doc.views && doc.views[viewName];\n\n        if (!fun) {\n          // basic validator; it's assumed that every subclass would want this\n          throw new NotFoundError('ddoc ' + doc._id + ' has no view named ' +\n            viewName);\n        }\n\n        ddocValidator(doc, viewName);\n        checkQueryParseError(opts, fun);\n\n        var createViewPromise = createView(\n          /* sourceDB */ db,\n          /* viewName */ fullViewName,\n          /* mapFun */ fun.map,\n          /* reduceFun */ fun.reduce,\n          /* temporary */ false,\n          /* localDocName */ localDocName);\n        return createViewPromise.then(function (view) {\n          if (opts.stale === 'ok' || opts.stale === 'update_after') {\n            if (opts.stale === 'update_after') {\n              nextTick(function () {\n                updateView(view);\n              });\n            }\n            return queryView(view, opts);\n          } else { // stale not ok\n            return updateView(view).then(function () {\n              return queryView(view, opts);\n            });\n          }\n        });\n      });\n    }\n  }\n\n  function abstractQuery(fun, opts, callback) {\n    var db = this;\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = opts ? coerceOptions(opts) : {};\n\n    if (typeof fun === 'function') {\n      fun = {map : fun};\n    }\n\n    var promise = Promise.resolve().then(function () {\n      return queryPromised(db, fun, opts);\n    });\n    promisedCallback(promise, callback);\n    return promise;\n  }\n\n  var abstractViewCleanup = callbackify(function () {\n    var db = this;\n    /* istanbul ignore next */\n    if (typeof db._viewCleanup === 'function') {\n      return customViewCleanup(db);\n    }\n    if (isRemote(db)) {\n      return httpViewCleanup(db);\n    }\n    return localViewCleanup(db);\n  });\n\n  return {\n    query: abstractQuery,\n    viewCleanup: abstractViewCleanup\n  };\n}\n\nvar builtInReduce = {\n  _sum: function (keys, values) {\n    return sum(values);\n  },\n\n  _count: function (keys, values) {\n    return values.length;\n  },\n\n  _stats: function (keys, values) {\n    // no need to implement rereduce=true, because Pouch\n    // will never call it\n    function sumsqr(values) {\n      var _sumsqr = 0;\n      for (var i = 0, len = values.length; i < len; i++) {\n        var num = values[i];\n        _sumsqr += (num * num);\n      }\n      return _sumsqr;\n    }\n    return {\n      sum     : sum(values),\n      min     : Math.min.apply(null, values),\n      max     : Math.max.apply(null, values),\n      count   : values.length,\n      sumsqr : sumsqr(values)\n    };\n  }\n};\n\nfunction getBuiltIn(reduceFunString) {\n  if (/^_sum/.test(reduceFunString)) {\n    return builtInReduce._sum;\n  } else if (/^_count/.test(reduceFunString)) {\n    return builtInReduce._count;\n  } else if (/^_stats/.test(reduceFunString)) {\n    return builtInReduce._stats;\n  } else if (/^_/.test(reduceFunString)) {\n    throw new Error(reduceFunString + ' is not a supported reduce function.');\n  }\n}\n\nfunction mapper(mapFun, emit) {\n  // for temp_views one can use emit(doc, emit), see #38\n  if (typeof mapFun === \"function\" && mapFun.length === 2) {\n    var origMap = mapFun;\n    return function (doc) {\n      return origMap(doc, emit);\n    };\n  } else {\n    return evalFunctionWithEval(mapFun.toString(), emit);\n  }\n}\n\nfunction reducer(reduceFun) {\n  var reduceFunString = reduceFun.toString();\n  var builtIn = getBuiltIn(reduceFunString);\n  if (builtIn) {\n    return builtIn;\n  } else {\n    return evalFunctionWithEval(reduceFunString);\n  }\n}\n\nfunction ddocValidator(ddoc, viewName) {\n  var fun = ddoc.views && ddoc.views[viewName];\n  if (typeof fun.map !== 'string') {\n    throw new NotFoundError('ddoc ' + ddoc._id + ' has no string view named ' +\n      viewName + ', instead found object of type: ' + typeof fun.map);\n  }\n}\n\nvar localDocName = 'mrviews';\nvar abstract = createAbstractMapReduce(localDocName, mapper, reducer, ddocValidator);\n\nfunction query(fun, opts, callback) {\n  return abstract.query.call(this, fun, opts, callback);\n}\n\nfunction viewCleanup(callback) {\n  return abstract.viewCleanup.call(this, callback);\n}\n\nvar mapreduce = {\n  query: query,\n  viewCleanup: viewCleanup\n};\n\nfunction isGenOne$1(rev) {\n  return /^1-/.test(rev);\n}\n\nfunction fileHasChanged(localDoc, remoteDoc, filename) {\n  return !localDoc._attachments ||\n         !localDoc._attachments[filename] ||\n         localDoc._attachments[filename].digest !== remoteDoc._attachments[filename].digest;\n}\n\nfunction getDocAttachments(db, doc) {\n  var filenames = Object.keys(doc._attachments);\n  return Promise.all(filenames.map(function (filename) {\n    return db.getAttachment(doc._id, filename, {rev: doc._rev});\n  }));\n}\n\nfunction getDocAttachmentsFromTargetOrSource(target, src, doc) {\n  var doCheckForLocalAttachments = isRemote(src) && !isRemote(target);\n  var filenames = Object.keys(doc._attachments);\n\n  if (!doCheckForLocalAttachments) {\n    return getDocAttachments(src, doc);\n  }\n\n  return target.get(doc._id).then(function (localDoc) {\n    return Promise.all(filenames.map(function (filename) {\n      if (fileHasChanged(localDoc, doc, filename)) {\n        return src.getAttachment(doc._id, filename);\n      }\n\n      return target.getAttachment(localDoc._id, filename);\n    }));\n  }).catch(function (error) {\n    /* istanbul ignore if */\n    if (error.status !== 404) {\n      throw error;\n    }\n\n    return getDocAttachments(src, doc);\n  });\n}\n\nfunction createBulkGetOpts(diffs) {\n  var requests = [];\n  Object.keys(diffs).forEach(function (id) {\n    var missingRevs = diffs[id].missing;\n    missingRevs.forEach(function (missingRev) {\n      requests.push({\n        id: id,\n        rev: missingRev\n      });\n    });\n  });\n\n  return {\n    docs: requests,\n    revs: true,\n    latest: true\n  };\n}\n\n//\n// Fetch all the documents from the src as described in the \"diffs\",\n// which is a mapping of docs IDs to revisions. If the state ever\n// changes to \"cancelled\", then the returned promise will be rejected.\n// Else it will be resolved with a list of fetched documents.\n//\nfunction getDocs(src, target, diffs, state) {\n  diffs = clone(diffs); // we do not need to modify this\n\n  var resultDocs = [],\n      ok = true;\n\n  function getAllDocs() {\n\n    var bulkGetOpts = createBulkGetOpts(diffs);\n\n    if (!bulkGetOpts.docs.length) { // optimization: skip empty requests\n      return;\n    }\n\n    return src.bulkGet(bulkGetOpts).then(function (bulkGetResponse) {\n      /* istanbul ignore if */\n      if (state.cancelled) {\n        throw new Error('cancelled');\n      }\n      return Promise.all(bulkGetResponse.results.map(function (bulkGetInfo) {\n        return Promise.all(bulkGetInfo.docs.map(function (doc) {\n          var remoteDoc = doc.ok;\n\n          if (doc.error) {\n            // when AUTO_COMPACTION is set, docs can be returned which look\n            // like this: {\"missing\":\"1-7c3ac256b693c462af8442f992b83696\"}\n            ok = false;\n          }\n\n          if (!remoteDoc || !remoteDoc._attachments) {\n            return remoteDoc;\n          }\n\n          return getDocAttachmentsFromTargetOrSource(target, src, remoteDoc)\n                   .then(function (attachments) {\n                           var filenames = Object.keys(remoteDoc._attachments);\n                           attachments\n                             .forEach(function (attachment, i) {\n                                        var att = remoteDoc._attachments[filenames[i]];\n                                        delete att.stub;\n                                        delete att.length;\n                                        att.data = attachment;\n                                      });\n\n                                      return remoteDoc;\n                                    });\n        }));\n      }))\n\n      .then(function (results) {\n        resultDocs = resultDocs.concat(flatten(results).filter(Boolean));\n      });\n    });\n  }\n\n  function hasAttachments(doc) {\n    return doc._attachments && Object.keys(doc._attachments).length > 0;\n  }\n\n  function hasConflicts(doc) {\n    return doc._conflicts && doc._conflicts.length > 0;\n  }\n\n  function fetchRevisionOneDocs(ids) {\n    // Optimization: fetch gen-1 docs and attachments in\n    // a single request using _all_docs\n    return src.allDocs({\n      keys: ids,\n      include_docs: true,\n      conflicts: true\n    }).then(function (res) {\n      if (state.cancelled) {\n        throw new Error('cancelled');\n      }\n      res.rows.forEach(function (row) {\n        if (row.deleted || !row.doc || !isGenOne$1(row.value.rev) ||\n            hasAttachments(row.doc) || hasConflicts(row.doc)) {\n          // if any of these conditions apply, we need to fetch using get()\n          return;\n        }\n\n        // strip _conflicts array to appease CSG (#5793)\n        /* istanbul ignore if */\n        if (row.doc._conflicts) {\n          delete row.doc._conflicts;\n        }\n\n        // the doc we got back from allDocs() is sufficient\n        resultDocs.push(row.doc);\n        delete diffs[row.id];\n      });\n    });\n  }\n\n  function getRevisionOneDocs() {\n    // filter out the generation 1 docs and get them\n    // leaving the non-generation one docs to be got otherwise\n    var ids = Object.keys(diffs).filter(function (id) {\n      var missing = diffs[id].missing;\n      return missing.length === 1 && isGenOne$1(missing[0]);\n    });\n    if (ids.length > 0) {\n      return fetchRevisionOneDocs(ids);\n    }\n  }\n\n  function returnResult() {\n    return { ok:ok, docs:resultDocs };\n  }\n\n  return Promise.resolve()\n    .then(getRevisionOneDocs)\n    .then(getAllDocs)\n    .then(returnResult);\n}\n\nvar CHECKPOINT_VERSION = 1;\nvar REPLICATOR = \"pouchdb\";\n// This is an arbitrary number to limit the\n// amount of replication history we save in the checkpoint.\n// If we save too much, the checkpoing docs will become very big,\n// if we save fewer, we'll run a greater risk of having to\n// read all the changes from 0 when checkpoint PUTs fail\n// CouchDB 2.0 has a more involved history pruning,\n// but let's go for the simple version for now.\nvar CHECKPOINT_HISTORY_SIZE = 5;\nvar LOWEST_SEQ = 0;\n\nfunction updateCheckpoint(db, id, checkpoint, session, returnValue) {\n  return db.get(id).catch(function (err) {\n    if (err.status === 404) {\n      if (db.adapter === 'http' || db.adapter === 'https') {\n        explainError(\n          404, 'PouchDB is just checking if a remote checkpoint exists.'\n        );\n      }\n      return {\n        session_id: session,\n        _id: id,\n        history: [],\n        replicator: REPLICATOR,\n        version: CHECKPOINT_VERSION\n      };\n    }\n    throw err;\n  }).then(function (doc) {\n    if (returnValue.cancelled) {\n      return;\n    }\n\n    // if the checkpoint has not changed, do not update\n    if (doc.last_seq === checkpoint) {\n      return;\n    }\n\n    // Filter out current entry for this replication\n    doc.history = (doc.history || []).filter(function (item) {\n      return item.session_id !== session;\n    });\n\n    // Add the latest checkpoint to history\n    doc.history.unshift({\n      last_seq: checkpoint,\n      session_id: session\n    });\n\n    // Just take the last pieces in history, to\n    // avoid really big checkpoint docs.\n    // see comment on history size above\n    doc.history = doc.history.slice(0, CHECKPOINT_HISTORY_SIZE);\n\n    doc.version = CHECKPOINT_VERSION;\n    doc.replicator = REPLICATOR;\n\n    doc.session_id = session;\n    doc.last_seq = checkpoint;\n\n    return db.put(doc).catch(function (err) {\n      if (err.status === 409) {\n        // retry; someone is trying to write a checkpoint simultaneously\n        return updateCheckpoint(db, id, checkpoint, session, returnValue);\n      }\n      throw err;\n    });\n  });\n}\n\nfunction Checkpointer(src, target, id, returnValue, opts) {\n  this.src = src;\n  this.target = target;\n  this.id = id;\n  this.returnValue = returnValue;\n  this.opts = opts || {};\n}\n\nCheckpointer.prototype.writeCheckpoint = function (checkpoint, session) {\n  var self = this;\n  return this.updateTarget(checkpoint, session).then(function () {\n    return self.updateSource(checkpoint, session);\n  });\n};\n\nCheckpointer.prototype.updateTarget = function (checkpoint, session) {\n  if (this.opts.writeTargetCheckpoint) {\n    return updateCheckpoint(this.target, this.id, checkpoint,\n      session, this.returnValue);\n  } else {\n    return Promise.resolve(true);\n  }\n};\n\nCheckpointer.prototype.updateSource = function (checkpoint, session) {\n  if (this.opts.writeSourceCheckpoint) {\n    var self = this;\n    return updateCheckpoint(this.src, this.id, checkpoint,\n      session, this.returnValue)\n      .catch(function (err) {\n        if (isForbiddenError(err)) {\n          self.opts.writeSourceCheckpoint = false;\n          return true;\n        }\n        throw err;\n      });\n  } else {\n    return Promise.resolve(true);\n  }\n};\n\nvar comparisons = {\n  \"undefined\": function (targetDoc, sourceDoc) {\n    // This is the previous comparison function\n    if (collate(targetDoc.last_seq, sourceDoc.last_seq) === 0) {\n      return sourceDoc.last_seq;\n    }\n    /* istanbul ignore next */\n    return 0;\n  },\n  \"1\": function (targetDoc, sourceDoc) {\n    // This is the comparison function ported from CouchDB\n    return compareReplicationLogs(sourceDoc, targetDoc).last_seq;\n  }\n};\n\nCheckpointer.prototype.getCheckpoint = function () {\n  var self = this;\n\n  if (self.opts && self.opts.writeSourceCheckpoint && !self.opts.writeTargetCheckpoint) {\n    return self.src.get(self.id).then(function (sourceDoc) {\n      return sourceDoc.last_seq || LOWEST_SEQ;\n    }).catch(function (err) {\n      /* istanbul ignore if */\n      if (err.status !== 404) {\n        throw err;\n      }\n      return LOWEST_SEQ;\n    });\n  }\n\n  return self.target.get(self.id).then(function (targetDoc) {\n    if (self.opts && self.opts.writeTargetCheckpoint && !self.opts.writeSourceCheckpoint) {\n      return targetDoc.last_seq || LOWEST_SEQ;\n    }\n\n    return self.src.get(self.id).then(function (sourceDoc) {\n      // Since we can't migrate an old version doc to a new one\n      // (no session id), we just go with the lowest seq in this case\n      /* istanbul ignore if */\n      if (targetDoc.version !== sourceDoc.version) {\n        return LOWEST_SEQ;\n      }\n\n      var version;\n      if (targetDoc.version) {\n        version = targetDoc.version.toString();\n      } else {\n        version = \"undefined\";\n      }\n\n      if (version in comparisons) {\n        return comparisons[version](targetDoc, sourceDoc);\n      }\n      /* istanbul ignore next */\n      return LOWEST_SEQ;\n    }, function (err) {\n      if (err.status === 404 && targetDoc.last_seq) {\n        return self.src.put({\n          _id: self.id,\n          last_seq: LOWEST_SEQ\n        }).then(function () {\n          return LOWEST_SEQ;\n        }, function (err) {\n          if (isForbiddenError(err)) {\n            self.opts.writeSourceCheckpoint = false;\n            return targetDoc.last_seq;\n          }\n          /* istanbul ignore next */\n          return LOWEST_SEQ;\n        });\n      }\n      throw err;\n    });\n  }).catch(function (err) {\n    if (err.status !== 404) {\n      throw err;\n    }\n    return LOWEST_SEQ;\n  });\n};\n// This checkpoint comparison is ported from CouchDBs source\n// they come from here:\n// https://github.com/apache/couchdb-couch-replicator/blob/master/src/couch_replicator.erl#L863-L906\n\nfunction compareReplicationLogs(srcDoc, tgtDoc) {\n  if (srcDoc.session_id === tgtDoc.session_id) {\n    return {\n      last_seq: srcDoc.last_seq,\n      history: srcDoc.history\n    };\n  }\n\n  return compareReplicationHistory(srcDoc.history, tgtDoc.history);\n}\n\nfunction compareReplicationHistory(sourceHistory, targetHistory) {\n  // the erlang loop via function arguments is not so easy to repeat in JS\n  // therefore, doing this as recursion\n  var S = sourceHistory[0];\n  var sourceRest = sourceHistory.slice(1);\n  var T = targetHistory[0];\n  var targetRest = targetHistory.slice(1);\n\n  if (!S || targetHistory.length === 0) {\n    return {\n      last_seq: LOWEST_SEQ,\n      history: []\n    };\n  }\n\n  var sourceId = S.session_id;\n  /* istanbul ignore if */\n  if (hasSessionId(sourceId, targetHistory)) {\n    return {\n      last_seq: S.last_seq,\n      history: sourceHistory\n    };\n  }\n\n  var targetId = T.session_id;\n  if (hasSessionId(targetId, sourceRest)) {\n    return {\n      last_seq: T.last_seq,\n      history: targetRest\n    };\n  }\n\n  return compareReplicationHistory(sourceRest, targetRest);\n}\n\nfunction hasSessionId(sessionId, history) {\n  var props = history[0];\n  var rest = history.slice(1);\n\n  if (!sessionId || history.length === 0) {\n    return false;\n  }\n\n  if (sessionId === props.session_id) {\n    return true;\n  }\n\n  return hasSessionId(sessionId, rest);\n}\n\nfunction isForbiddenError(err) {\n  return typeof err.status === 'number' && Math.floor(err.status / 100) === 4;\n}\n\nvar STARTING_BACK_OFF = 0;\n\nfunction backOff(opts, returnValue, error, callback) {\n  if (opts.retry === false) {\n    returnValue.emit('error', error);\n    returnValue.removeAllListeners();\n    return;\n  }\n  /* istanbul ignore if */\n  if (typeof opts.back_off_function !== 'function') {\n    opts.back_off_function = defaultBackOff;\n  }\n  returnValue.emit('requestError', error);\n  if (returnValue.state === 'active' || returnValue.state === 'pending') {\n    returnValue.emit('paused', error);\n    returnValue.state = 'stopped';\n    var backOffSet = function backoffTimeSet() {\n      opts.current_back_off = STARTING_BACK_OFF;\n    };\n    var removeBackOffSetter = function removeBackOffTimeSet() {\n      returnValue.removeListener('active', backOffSet);\n    };\n    returnValue.once('paused', removeBackOffSetter);\n    returnValue.once('active', backOffSet);\n  }\n\n  opts.current_back_off = opts.current_back_off || STARTING_BACK_OFF;\n  opts.current_back_off = opts.back_off_function(opts.current_back_off);\n  setTimeout(callback, opts.current_back_off);\n}\n\nfunction sortObjectPropertiesByKey(queryParams) {\n  return Object.keys(queryParams).sort(collate).reduce(function (result, key) {\n    result[key] = queryParams[key];\n    return result;\n  }, {});\n}\n\n// Generate a unique id particular to this replication.\n// Not guaranteed to align perfectly with CouchDB's rep ids.\nfunction generateReplicationId(src, target, opts) {\n  var docIds = opts.doc_ids ? opts.doc_ids.sort(collate) : '';\n  var filterFun = opts.filter ? opts.filter.toString() : '';\n  var queryParams = '';\n  var filterViewName =  '';\n  var selector = '';\n\n  // possibility for checkpoints to be lost here as behaviour of\n  // JSON.stringify is not stable (see #6226)\n  /* istanbul ignore if */\n  if (opts.selector) {\n    selector = JSON.stringify(opts.selector);\n  }\n\n  if (opts.filter && opts.query_params) {\n    queryParams = JSON.stringify(sortObjectPropertiesByKey(opts.query_params));\n  }\n\n  if (opts.filter && opts.filter === '_view') {\n    filterViewName = opts.view.toString();\n  }\n\n  return Promise.all([src.id(), target.id()]).then(function (res) {\n    var queryData = res[0] + res[1] + filterFun + filterViewName +\n      queryParams + docIds + selector;\n    return new Promise(function (resolve) {\n      binaryMd5(queryData, resolve);\n    });\n  }).then(function (md5sum) {\n    // can't use straight-up md5 alphabet, because\n    // the char '/' is interpreted as being for attachments,\n    // and + is also not url-safe\n    md5sum = md5sum.replace(/\\//g, '.').replace(/\\+/g, '_');\n    return '_local/' + md5sum;\n  });\n}\n\nfunction replicate(src, target, opts, returnValue, result) {\n  var batches = [];               // list of batches to be processed\n  var currentBatch;               // the batch currently being processed\n  var pendingBatch = {\n    seq: 0,\n    changes: [],\n    docs: []\n  }; // next batch, not yet ready to be processed\n  var writingCheckpoint = false;  // true while checkpoint is being written\n  var changesCompleted = false;   // true when all changes received\n  var replicationCompleted = false; // true when replication has completed\n  var last_seq = 0;\n  var continuous = opts.continuous || opts.live || false;\n  var batch_size = opts.batch_size || 100;\n  var batches_limit = opts.batches_limit || 10;\n  var changesPending = false;     // true while src.changes is running\n  var doc_ids = opts.doc_ids;\n  var selector = opts.selector;\n  var repId;\n  var checkpointer;\n  var changedDocs = [];\n  // Like couchdb, every replication gets a unique session id\n  var session = uuid();\n\n  result = result || {\n    ok: true,\n    start_time: new Date().toISOString(),\n    docs_read: 0,\n    docs_written: 0,\n    doc_write_failures: 0,\n    errors: []\n  };\n\n  var changesOpts = {};\n  returnValue.ready(src, target);\n\n  function initCheckpointer() {\n    if (checkpointer) {\n      return Promise.resolve();\n    }\n    return generateReplicationId(src, target, opts).then(function (res) {\n      repId = res;\n\n      var checkpointOpts = {};\n      if (opts.checkpoint === false) {\n        checkpointOpts = { writeSourceCheckpoint: false, writeTargetCheckpoint: false };\n      } else if (opts.checkpoint === 'source') {\n        checkpointOpts = { writeSourceCheckpoint: true, writeTargetCheckpoint: false };\n      } else if (opts.checkpoint === 'target') {\n        checkpointOpts = { writeSourceCheckpoint: false, writeTargetCheckpoint: true };\n      } else {\n        checkpointOpts = { writeSourceCheckpoint: true, writeTargetCheckpoint: true };\n      }\n\n      checkpointer = new Checkpointer(src, target, repId, returnValue, checkpointOpts);\n    });\n  }\n\n  function writeDocs() {\n    changedDocs = [];\n\n    if (currentBatch.docs.length === 0) {\n      return;\n    }\n    var docs = currentBatch.docs;\n    var bulkOpts = {timeout: opts.timeout};\n    return target.bulkDocs({docs: docs, new_edits: false}, bulkOpts).then(function (res) {\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        throw new Error('cancelled');\n      }\n\n      // `res` doesn't include full documents (which live in `docs`), so we create a map of \n      // (id -> error), and check for errors while iterating over `docs`\n      var errorsById = Object.create(null);\n      res.forEach(function (res) {\n        if (res.error) {\n          errorsById[res.id] = res;\n        }\n      });\n\n      var errorsNo = Object.keys(errorsById).length;\n      result.doc_write_failures += errorsNo;\n      result.docs_written += docs.length - errorsNo;\n\n      docs.forEach(function (doc) {\n        var error = errorsById[doc._id];\n        if (error) {\n          result.errors.push(error);\n          // Normalize error name. i.e. 'Unauthorized' -> 'unauthorized' (eg Sync Gateway)\n          var errorName = (error.name || '').toLowerCase();\n          if (errorName === 'unauthorized' || errorName === 'forbidden') {\n            returnValue.emit('denied', clone(error));\n          } else {\n            throw error;\n          }\n        } else {\n          changedDocs.push(doc);\n        }\n      });\n\n    }, function (err) {\n      result.doc_write_failures += docs.length;\n      throw err;\n    });\n  }\n\n  function finishBatch() {\n    if (currentBatch.error) {\n      throw new Error('There was a problem getting docs.');\n    }\n    result.last_seq = last_seq = currentBatch.seq;\n    var outResult = clone(result);\n    if (changedDocs.length) {\n      outResult.docs = changedDocs;\n      // Attach 'pending' property if server supports it (CouchDB 2.0+)\n      /* istanbul ignore if */\n      if (typeof currentBatch.pending === 'number') {\n        outResult.pending = currentBatch.pending;\n        delete currentBatch.pending;\n      }\n      returnValue.emit('change', outResult);\n    }\n    writingCheckpoint = true;\n    return checkpointer.writeCheckpoint(currentBatch.seq,\n        session).then(function () {\n      writingCheckpoint = false;\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        throw new Error('cancelled');\n      }\n      currentBatch = undefined;\n      getChanges();\n    }).catch(function (err) {\n      onCheckpointError(err);\n      throw err;\n    });\n  }\n\n  function getDiffs() {\n    var diff = {};\n    currentBatch.changes.forEach(function (change) {\n      // Couchbase Sync Gateway emits these, but we can ignore them\n      /* istanbul ignore if */\n      if (change.id === \"_user/\") {\n        return;\n      }\n      diff[change.id] = change.changes.map(function (x) {\n        return x.rev;\n      });\n    });\n    return target.revsDiff(diff).then(function (diffs) {\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        throw new Error('cancelled');\n      }\n      // currentBatch.diffs elements are deleted as the documents are written\n      currentBatch.diffs = diffs;\n    });\n  }\n\n  function getBatchDocs() {\n    return getDocs(src, target, currentBatch.diffs, returnValue).then(function (got) {\n      currentBatch.error = !got.ok;\n      got.docs.forEach(function (doc) {\n        delete currentBatch.diffs[doc._id];\n        result.docs_read++;\n        currentBatch.docs.push(doc);\n      });\n    });\n  }\n\n  function startNextBatch() {\n    if (returnValue.cancelled || currentBatch) {\n      return;\n    }\n    if (batches.length === 0) {\n      processPendingBatch(true);\n      return;\n    }\n    currentBatch = batches.shift();\n    getDiffs()\n      .then(getBatchDocs)\n      .then(writeDocs)\n      .then(finishBatch)\n      .then(startNextBatch)\n      .catch(function (err) {\n        abortReplication('batch processing terminated with error', err);\n      });\n  }\n\n\n  function processPendingBatch(immediate) {\n    if (pendingBatch.changes.length === 0) {\n      if (batches.length === 0 && !currentBatch) {\n        if ((continuous && changesOpts.live) || changesCompleted) {\n          returnValue.state = 'pending';\n          returnValue.emit('paused');\n        }\n        if (changesCompleted) {\n          completeReplication();\n        }\n      }\n      return;\n    }\n    if (\n      immediate ||\n      changesCompleted ||\n      pendingBatch.changes.length >= batch_size\n    ) {\n      batches.push(pendingBatch);\n      pendingBatch = {\n        seq: 0,\n        changes: [],\n        docs: []\n      };\n      if (returnValue.state === 'pending' || returnValue.state === 'stopped') {\n        returnValue.state = 'active';\n        returnValue.emit('active');\n      }\n      startNextBatch();\n    }\n  }\n\n\n  function abortReplication(reason, err) {\n    if (replicationCompleted) {\n      return;\n    }\n    if (!err.message) {\n      err.message = reason;\n    }\n    result.ok = false;\n    result.status = 'aborting';\n    batches = [];\n    pendingBatch = {\n      seq: 0,\n      changes: [],\n      docs: []\n    };\n    completeReplication(err);\n  }\n\n\n  function completeReplication(fatalError) {\n    if (replicationCompleted) {\n      return;\n    }\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      result.status = 'cancelled';\n      if (writingCheckpoint) {\n        return;\n      }\n    }\n    result.status = result.status || 'complete';\n    result.end_time = new Date().toISOString();\n    result.last_seq = last_seq;\n    replicationCompleted = true;\n\n    if (fatalError) {\n      // need to extend the error because Firefox considers \".result\" read-only\n      fatalError = createError(fatalError);\n      fatalError.result = result;\n\n      // Normalize error name. i.e. 'Unauthorized' -> 'unauthorized' (eg Sync Gateway)\n      var errorName = (fatalError.name || '').toLowerCase();\n      if (errorName === 'unauthorized' || errorName === 'forbidden') {\n        returnValue.emit('error', fatalError);\n        returnValue.removeAllListeners();\n      } else {\n        backOff(opts, returnValue, fatalError, function () {\n          replicate(src, target, opts, returnValue);\n        });\n      }\n    } else {\n      returnValue.emit('complete', result);\n      returnValue.removeAllListeners();\n    }\n  }\n\n\n  function onChange(change, pending, lastSeq) {\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      return completeReplication();\n    }\n    // Attach 'pending' property if server supports it (CouchDB 2.0+)\n    /* istanbul ignore if */\n    if (typeof pending === 'number') {\n      pendingBatch.pending = pending;\n    }\n\n    var filter = filterChange(opts)(change);\n    if (!filter) {\n      return;\n    }\n    pendingBatch.seq = change.seq || lastSeq;\n    pendingBatch.changes.push(change);\n    nextTick(function () {\n      processPendingBatch(batches.length === 0 && changesOpts.live);\n    });\n  }\n\n\n  function onChangesComplete(changes) {\n    changesPending = false;\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      return completeReplication();\n    }\n\n    // if no results were returned then we're done,\n    // else fetch more\n    if (changes.results.length > 0) {\n      changesOpts.since = changes.results[changes.results.length - 1].seq;\n      getChanges();\n      processPendingBatch(true);\n    } else {\n\n      var complete = function () {\n        if (continuous) {\n          changesOpts.live = true;\n          getChanges();\n        } else {\n          changesCompleted = true;\n        }\n        processPendingBatch(true);\n      };\n\n      // update the checkpoint so we start from the right seq next time\n      if (!currentBatch && changes.results.length === 0) {\n        writingCheckpoint = true;\n        checkpointer.writeCheckpoint(changes.last_seq,\n            session).then(function () {\n          writingCheckpoint = false;\n          result.last_seq = last_seq = changes.last_seq;\n          complete();\n        })\n        .catch(onCheckpointError);\n      } else {\n        complete();\n      }\n    }\n  }\n\n\n  function onChangesError(err) {\n    changesPending = false;\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      return completeReplication();\n    }\n    abortReplication('changes rejected', err);\n  }\n\n\n  function getChanges() {\n    if (!(\n      !changesPending &&\n      !changesCompleted &&\n      batches.length < batches_limit\n      )) {\n      return;\n    }\n    changesPending = true;\n    function abortChanges() {\n      changes.cancel();\n    }\n    function removeListener() {\n      returnValue.removeListener('cancel', abortChanges);\n    }\n\n    if (returnValue._changes) { // remove old changes() and listeners\n      returnValue.removeListener('cancel', returnValue._abortChanges);\n      returnValue._changes.cancel();\n    }\n    returnValue.once('cancel', abortChanges);\n\n    var changes = src.changes(changesOpts)\n      .on('change', onChange);\n    changes.then(removeListener, removeListener);\n    changes.then(onChangesComplete)\n      .catch(onChangesError);\n\n    if (opts.retry) {\n      // save for later so we can cancel if necessary\n      returnValue._changes = changes;\n      returnValue._abortChanges = abortChanges;\n    }\n  }\n\n\n  function startChanges() {\n    initCheckpointer().then(function () {\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        return;\n      }\n      return checkpointer.getCheckpoint().then(function (checkpoint) {\n        last_seq = checkpoint;\n        changesOpts = {\n          since: last_seq,\n          limit: batch_size,\n          batch_size: batch_size,\n          style: 'all_docs',\n          doc_ids: doc_ids,\n          selector: selector,\n          return_docs: true // required so we know when we're done\n        };\n        if (opts.filter) {\n          if (typeof opts.filter !== 'string') {\n            // required for the client-side filter in onChange\n            changesOpts.include_docs = true;\n          } else { // ddoc filter\n            changesOpts.filter = opts.filter;\n          }\n        }\n        if ('heartbeat' in opts) {\n          changesOpts.heartbeat = opts.heartbeat;\n        }\n        if ('timeout' in opts) {\n          changesOpts.timeout = opts.timeout;\n        }\n        if (opts.query_params) {\n          changesOpts.query_params = opts.query_params;\n        }\n        if (opts.view) {\n          changesOpts.view = opts.view;\n        }\n        getChanges();\n      });\n    }).catch(function (err) {\n      abortReplication('getCheckpoint rejected with ', err);\n    });\n  }\n\n  /* istanbul ignore next */\n  function onCheckpointError(err) {\n    writingCheckpoint = false;\n    abortReplication('writeCheckpoint completed with error', err);\n  }\n\n  /* istanbul ignore if */\n  if (returnValue.cancelled) { // cancelled immediately\n    completeReplication();\n    return;\n  }\n\n  if (!returnValue._addedListeners) {\n    returnValue.once('cancel', completeReplication);\n\n    if (typeof opts.complete === 'function') {\n      returnValue.once('error', opts.complete);\n      returnValue.once('complete', function (result) {\n        opts.complete(null, result);\n      });\n    }\n    returnValue._addedListeners = true;\n  }\n\n  if (typeof opts.since === 'undefined') {\n    startChanges();\n  } else {\n    initCheckpointer().then(function () {\n      writingCheckpoint = true;\n      return checkpointer.writeCheckpoint(opts.since, session);\n    }).then(function () {\n      writingCheckpoint = false;\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        return;\n      }\n      last_seq = opts.since;\n      startChanges();\n    }).catch(onCheckpointError);\n  }\n}\n\n// We create a basic promise so the caller can cancel the replication possibly\n// before we have actually started listening to changes etc\ninherits(Replication, EventEmitter);\nfunction Replication() {\n  EventEmitter.call(this);\n  this.cancelled = false;\n  this.state = 'pending';\n  var self = this;\n  var promise = new Promise(function (fulfill, reject) {\n    self.once('complete', fulfill);\n    self.once('error', reject);\n  });\n  self.then = function (resolve, reject) {\n    return promise.then(resolve, reject);\n  };\n  self.catch = function (reject) {\n    return promise.catch(reject);\n  };\n  // As we allow error handling via \"error\" event as well,\n  // put a stub in here so that rejecting never throws UnhandledError.\n  self.catch(function () {});\n}\n\nReplication.prototype.cancel = function () {\n  this.cancelled = true;\n  this.state = 'cancelled';\n  this.emit('cancel');\n};\n\nReplication.prototype.ready = function (src, target) {\n  var self = this;\n  if (self._readyCalled) {\n    return;\n  }\n  self._readyCalled = true;\n\n  function onDestroy() {\n    self.cancel();\n  }\n  src.once('destroyed', onDestroy);\n  target.once('destroyed', onDestroy);\n  function cleanup() {\n    src.removeListener('destroyed', onDestroy);\n    target.removeListener('destroyed', onDestroy);\n  }\n  self.once('complete', cleanup);\n};\n\nfunction toPouch(db, opts) {\n  var PouchConstructor = opts.PouchConstructor;\n  if (typeof db === 'string') {\n    return new PouchConstructor(db, opts);\n  } else {\n    return db;\n  }\n}\n\nfunction replicateWrapper(src, target, opts, callback) {\n\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  if (typeof opts === 'undefined') {\n    opts = {};\n  }\n\n  if (opts.doc_ids && !Array.isArray(opts.doc_ids)) {\n    throw createError(BAD_REQUEST,\n                       \"`doc_ids` filter parameter is not a list.\");\n  }\n\n  opts.complete = callback;\n  opts = clone(opts);\n  opts.continuous = opts.continuous || opts.live;\n  opts.retry = ('retry' in opts) ? opts.retry : false;\n  /*jshint validthis:true */\n  opts.PouchConstructor = opts.PouchConstructor || this;\n  var replicateRet = new Replication(opts);\n  var srcPouch = toPouch(src, opts);\n  var targetPouch = toPouch(target, opts);\n  replicate(srcPouch, targetPouch, opts, replicateRet);\n  return replicateRet;\n}\n\ninherits(Sync, EventEmitter);\nfunction sync(src, target, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  if (typeof opts === 'undefined') {\n    opts = {};\n  }\n  opts = clone(opts);\n  /*jshint validthis:true */\n  opts.PouchConstructor = opts.PouchConstructor || this;\n  src = toPouch(src, opts);\n  target = toPouch(target, opts);\n  return new Sync(src, target, opts, callback);\n}\n\nfunction Sync(src, target, opts, callback) {\n  var self = this;\n  this.canceled = false;\n\n  var optsPush = opts.push ? $inject_Object_assign({}, opts, opts.push) : opts;\n  var optsPull = opts.pull ? $inject_Object_assign({}, opts, opts.pull) : opts;\n\n  this.push = replicateWrapper(src, target, optsPush);\n  this.pull = replicateWrapper(target, src, optsPull);\n\n  this.pushPaused = true;\n  this.pullPaused = true;\n\n  function pullChange(change) {\n    self.emit('change', {\n      direction: 'pull',\n      change: change\n    });\n  }\n  function pushChange(change) {\n    self.emit('change', {\n      direction: 'push',\n      change: change\n    });\n  }\n  function pushDenied(doc) {\n    self.emit('denied', {\n      direction: 'push',\n      doc: doc\n    });\n  }\n  function pullDenied(doc) {\n    self.emit('denied', {\n      direction: 'pull',\n      doc: doc\n    });\n  }\n  function pushPaused() {\n    self.pushPaused = true;\n    /* istanbul ignore if */\n    if (self.pullPaused) {\n      self.emit('paused');\n    }\n  }\n  function pullPaused() {\n    self.pullPaused = true;\n    /* istanbul ignore if */\n    if (self.pushPaused) {\n      self.emit('paused');\n    }\n  }\n  function pushActive() {\n    self.pushPaused = false;\n    /* istanbul ignore if */\n    if (self.pullPaused) {\n      self.emit('active', {\n        direction: 'push'\n      });\n    }\n  }\n  function pullActive() {\n    self.pullPaused = false;\n    /* istanbul ignore if */\n    if (self.pushPaused) {\n      self.emit('active', {\n        direction: 'pull'\n      });\n    }\n  }\n\n  var removed = {};\n\n  function removeAll(type) { // type is 'push' or 'pull'\n    return function (event, func) {\n      var isChange = event === 'change' &&\n        (func === pullChange || func === pushChange);\n      var isDenied = event === 'denied' &&\n        (func === pullDenied || func === pushDenied);\n      var isPaused = event === 'paused' &&\n        (func === pullPaused || func === pushPaused);\n      var isActive = event === 'active' &&\n        (func === pullActive || func === pushActive);\n\n      if (isChange || isDenied || isPaused || isActive) {\n        if (!(event in removed)) {\n          removed[event] = {};\n        }\n        removed[event][type] = true;\n        if (Object.keys(removed[event]).length === 2) {\n          // both push and pull have asked to be removed\n          self.removeAllListeners(event);\n        }\n      }\n    };\n  }\n\n  if (opts.live) {\n    this.push.on('complete', self.pull.cancel.bind(self.pull));\n    this.pull.on('complete', self.push.cancel.bind(self.push));\n  }\n\n  function addOneListener(ee, event, listener) {\n    if (ee.listeners(event).indexOf(listener) == -1) {\n      ee.on(event, listener);\n    }\n  }\n\n  this.on('newListener', function (event) {\n    if (event === 'change') {\n      addOneListener(self.pull, 'change', pullChange);\n      addOneListener(self.push, 'change', pushChange);\n    } else if (event === 'denied') {\n      addOneListener(self.pull, 'denied', pullDenied);\n      addOneListener(self.push, 'denied', pushDenied);\n    } else if (event === 'active') {\n      addOneListener(self.pull, 'active', pullActive);\n      addOneListener(self.push, 'active', pushActive);\n    } else if (event === 'paused') {\n      addOneListener(self.pull, 'paused', pullPaused);\n      addOneListener(self.push, 'paused', pushPaused);\n    }\n  });\n\n  this.on('removeListener', function (event) {\n    if (event === 'change') {\n      self.pull.removeListener('change', pullChange);\n      self.push.removeListener('change', pushChange);\n    } else if (event === 'denied') {\n      self.pull.removeListener('denied', pullDenied);\n      self.push.removeListener('denied', pushDenied);\n    } else if (event === 'active') {\n      self.pull.removeListener('active', pullActive);\n      self.push.removeListener('active', pushActive);\n    } else if (event === 'paused') {\n      self.pull.removeListener('paused', pullPaused);\n      self.push.removeListener('paused', pushPaused);\n    }\n  });\n\n  this.pull.on('removeListener', removeAll('pull'));\n  this.push.on('removeListener', removeAll('push'));\n\n  var promise = Promise.all([\n    this.push,\n    this.pull\n  ]).then(function (resp) {\n    var out = {\n      push: resp[0],\n      pull: resp[1]\n    };\n    self.emit('complete', out);\n    if (callback) {\n      callback(null, out);\n    }\n    self.removeAllListeners();\n    return out;\n  }, function (err) {\n    self.cancel();\n    if (callback) {\n      // if there's a callback, then the callback can receive\n      // the error event\n      callback(err);\n    } else {\n      // if there's no callback, then we're safe to emit an error\n      // event, which would otherwise throw an unhandled error\n      // due to 'error' being a special event in EventEmitters\n      self.emit('error', err);\n    }\n    self.removeAllListeners();\n    if (callback) {\n      // no sense throwing if we're already emitting an 'error' event\n      throw err;\n    }\n  });\n\n  this.then = function (success, err) {\n    return promise.then(success, err);\n  };\n\n  this.catch = function (err) {\n    return promise.catch(err);\n  };\n}\n\nSync.prototype.cancel = function () {\n  if (!this.canceled) {\n    this.canceled = true;\n    this.push.cancel();\n    this.pull.cancel();\n  }\n};\n\nfunction replication(PouchDB) {\n  PouchDB.replicate = replicateWrapper;\n  PouchDB.sync = sync;\n\n  Object.defineProperty(PouchDB.prototype, 'replicate', {\n    get: function () {\n      var self = this;\n      if (typeof this.replicateMethods === 'undefined') {\n        this.replicateMethods = {\n          from: function (other, opts, callback) {\n            return self.constructor.replicate(other, self, opts, callback);\n          },\n          to: function (other, opts, callback) {\n            return self.constructor.replicate(self, other, opts, callback);\n          }\n        };\n      }\n      return this.replicateMethods;\n    }\n  });\n\n  PouchDB.prototype.sync = function (dbName, opts, callback) {\n    return this.constructor.sync(this, dbName, opts, callback);\n  };\n}\n\nPouchDB.plugin(IDBPouch)\n  .plugin(HttpPouch$1)\n  .plugin(mapreduce)\n  .plugin(replication);\n\n// Pull from src because pouchdb-node/pouchdb-browser themselves\n\nexport default PouchDB;\n","'use strict';\n\nmodule.exports = argsArray;\n\nfunction argsArray(fun) {\n  return function () {\n    var len = arguments.length;\n    if (len) {\n      var args = [];\n      var i = -1;\n      while (++i < len) {\n        args[i] = arguments[i];\n      }\n      return fun.call(this, args);\n    } else {\n      return fun.call(this, []);\n    }\n  };\n}","'use strict';\nvar Mutation = global.MutationObserver || global.WebKitMutationObserver;\n\nvar scheduleDrain;\n\n{\n  if (Mutation) {\n    var called = 0;\n    var observer = new Mutation(nextTick);\n    var element = global.document.createTextNode('');\n    observer.observe(element, {\n      characterData: true\n    });\n    scheduleDrain = function () {\n      element.data = (called = ++called % 2);\n    };\n  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\n    var channel = new global.MessageChannel();\n    channel.port1.onmessage = nextTick;\n    scheduleDrain = function () {\n      channel.port2.postMessage(0);\n    };\n  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\n    scheduleDrain = function () {\n\n      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n      var scriptEl = global.document.createElement('script');\n      scriptEl.onreadystatechange = function () {\n        nextTick();\n\n        scriptEl.onreadystatechange = null;\n        scriptEl.parentNode.removeChild(scriptEl);\n        scriptEl = null;\n      };\n      global.document.documentElement.appendChild(scriptEl);\n    };\n  } else {\n    scheduleDrain = function () {\n      setTimeout(nextTick, 0);\n    };\n  }\n}\n\nvar draining;\nvar queue = [];\n//named nextTick for less confusing stack traces\nfunction nextTick() {\n  draining = true;\n  var i, oldQueue;\n  var len = queue.length;\n  while (len) {\n    oldQueue = queue;\n    queue = [];\n    i = -1;\n    while (++i < len) {\n      oldQueue[i]();\n    }\n    len = queue.length;\n  }\n  draining = false;\n}\n\nmodule.exports = immediate;\nfunction immediate(task) {\n  if (queue.push(task) === 1 && !draining) {\n    scheduleDrain();\n  }\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = $getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  var args = [];\n  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    ReflectApply(this.listener, this.target, args);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n","(function (factory) {\n    if (typeof exports === 'object') {\n        // Node/CommonJS\n        module.exports = factory();\n    } else if (typeof define === 'function' && define.amd) {\n        // AMD\n        define(factory);\n    } else {\n        // Browser globals (with support for web workers)\n        var glob;\n\n        try {\n            glob = window;\n        } catch (e) {\n            glob = self;\n        }\n\n        glob.SparkMD5 = factory();\n    }\n}(function (undefined) {\n\n    'use strict';\n\n    /*\n     * Fastest md5 implementation around (JKM md5).\n     * Credits: Joseph Myers\n     *\n     * @see http://www.myersdaily.org/joseph/javascript/md5-text.html\n     * @see http://jsperf.com/md5-shootout/7\n     */\n\n    /* this function is much faster,\n      so if possible we use it. Some IEs\n      are the only ones I know of that\n      need the idiotic second function,\n      generated by an if clause.  */\n    var add32 = function (a, b) {\n        return (a + b) & 0xFFFFFFFF;\n    },\n        hex_chr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];\n\n\n    function cmn(q, a, b, x, s, t) {\n        a = add32(add32(a, q), add32(x, t));\n        return add32((a << s) | (a >>> (32 - s)), b);\n    }\n\n    function md5cycle(x, k) {\n        var a = x[0],\n            b = x[1],\n            c = x[2],\n            d = x[3];\n\n        a += (b & c | ~b & d) + k[0] - 680876936 | 0;\n        a  = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[1] - 389564586 | 0;\n        d  = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[2] + 606105819 | 0;\n        c  = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[3] - 1044525330 | 0;\n        b  = (b << 22 | b >>> 10) + c | 0;\n        a += (b & c | ~b & d) + k[4] - 176418897 | 0;\n        a  = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[5] + 1200080426 | 0;\n        d  = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[6] - 1473231341 | 0;\n        c  = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[7] - 45705983 | 0;\n        b  = (b << 22 | b >>> 10) + c | 0;\n        a += (b & c | ~b & d) + k[8] + 1770035416 | 0;\n        a  = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[9] - 1958414417 | 0;\n        d  = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[10] - 42063 | 0;\n        c  = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[11] - 1990404162 | 0;\n        b  = (b << 22 | b >>> 10) + c | 0;\n        a += (b & c | ~b & d) + k[12] + 1804603682 | 0;\n        a  = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[13] - 40341101 | 0;\n        d  = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[14] - 1502002290 | 0;\n        c  = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[15] + 1236535329 | 0;\n        b  = (b << 22 | b >>> 10) + c | 0;\n\n        a += (b & d | c & ~d) + k[1] - 165796510 | 0;\n        a  = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[6] - 1069501632 | 0;\n        d  = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[11] + 643717713 | 0;\n        c  = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[0] - 373897302 | 0;\n        b  = (b << 20 | b >>> 12) + c | 0;\n        a += (b & d | c & ~d) + k[5] - 701558691 | 0;\n        a  = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[10] + 38016083 | 0;\n        d  = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[15] - 660478335 | 0;\n        c  = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[4] - 405537848 | 0;\n        b  = (b << 20 | b >>> 12) + c | 0;\n        a += (b & d | c & ~d) + k[9] + 568446438 | 0;\n        a  = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[14] - 1019803690 | 0;\n        d  = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[3] - 187363961 | 0;\n        c  = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[8] + 1163531501 | 0;\n        b  = (b << 20 | b >>> 12) + c | 0;\n        a += (b & d | c & ~d) + k[13] - 1444681467 | 0;\n        a  = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[2] - 51403784 | 0;\n        d  = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[7] + 1735328473 | 0;\n        c  = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[12] - 1926607734 | 0;\n        b  = (b << 20 | b >>> 12) + c | 0;\n\n        a += (b ^ c ^ d) + k[5] - 378558 | 0;\n        a  = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[8] - 2022574463 | 0;\n        d  = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[11] + 1839030562 | 0;\n        c  = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[14] - 35309556 | 0;\n        b  = (b << 23 | b >>> 9) + c | 0;\n        a += (b ^ c ^ d) + k[1] - 1530992060 | 0;\n        a  = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[4] + 1272893353 | 0;\n        d  = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[7] - 155497632 | 0;\n        c  = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[10] - 1094730640 | 0;\n        b  = (b << 23 | b >>> 9) + c | 0;\n        a += (b ^ c ^ d) + k[13] + 681279174 | 0;\n        a  = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[0] - 358537222 | 0;\n        d  = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[3] - 722521979 | 0;\n        c  = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[6] + 76029189 | 0;\n        b  = (b << 23 | b >>> 9) + c | 0;\n        a += (b ^ c ^ d) + k[9] - 640364487 | 0;\n        a  = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[12] - 421815835 | 0;\n        d  = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[15] + 530742520 | 0;\n        c  = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[2] - 995338651 | 0;\n        b  = (b << 23 | b >>> 9) + c | 0;\n\n        a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;\n        a  = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;\n        d  = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;\n        c  = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;\n        b  = (b << 21 |b >>> 11) + c | 0;\n        a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;\n        a  = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;\n        d  = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;\n        c  = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;\n        b  = (b << 21 |b >>> 11) + c | 0;\n        a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;\n        a  = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;\n        d  = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;\n        c  = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;\n        b  = (b << 21 |b >>> 11) + c | 0;\n        a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;\n        a  = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;\n        d  = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;\n        c  = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;\n        b  = (b << 21 | b >>> 11) + c | 0;\n\n        x[0] = a + x[0] | 0;\n        x[1] = b + x[1] | 0;\n        x[2] = c + x[2] | 0;\n        x[3] = d + x[3] | 0;\n    }\n\n    function md5blk(s) {\n        var md5blks = [],\n            i; /* Andy King said do it this way. */\n\n        for (i = 0; i < 64; i += 4) {\n            md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);\n        }\n        return md5blks;\n    }\n\n    function md5blk_array(a) {\n        var md5blks = [],\n            i; /* Andy King said do it this way. */\n\n        for (i = 0; i < 64; i += 4) {\n            md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);\n        }\n        return md5blks;\n    }\n\n    function md51(s) {\n        var n = s.length,\n            state = [1732584193, -271733879, -1732584194, 271733878],\n            i,\n            length,\n            tail,\n            tmp,\n            lo,\n            hi;\n\n        for (i = 64; i <= n; i += 64) {\n            md5cycle(state, md5blk(s.substring(i - 64, i)));\n        }\n        s = s.substring(i - 64);\n        length = s.length;\n        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);\n        }\n        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n        if (i > 55) {\n            md5cycle(state, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Beware that the final length might not fit in 32 bits so we take care of that\n        tmp = n * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n\n        md5cycle(state, tail);\n        return state;\n    }\n\n    function md51_array(a) {\n        var n = a.length,\n            state = [1732584193, -271733879, -1732584194, 271733878],\n            i,\n            length,\n            tail,\n            tmp,\n            lo,\n            hi;\n\n        for (i = 64; i <= n; i += 64) {\n            md5cycle(state, md5blk_array(a.subarray(i - 64, i)));\n        }\n\n        // Not sure if it is a bug, however IE10 will always produce a sub array of length 1\n        // containing the last element of the parent array if the sub array specified starts\n        // beyond the length of the parent array - weird.\n        // https://connect.microsoft.com/IE/feedback/details/771452/typed-array-subarray-issue\n        a = (i - 64) < n ? a.subarray(i - 64) : new Uint8Array(0);\n\n        length = a.length;\n        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= a[i] << ((i % 4) << 3);\n        }\n\n        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n        if (i > 55) {\n            md5cycle(state, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Beware that the final length might not fit in 32 bits so we take care of that\n        tmp = n * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n\n        md5cycle(state, tail);\n\n        return state;\n    }\n\n    function rhex(n) {\n        var s = '',\n            j;\n        for (j = 0; j < 4; j += 1) {\n            s += hex_chr[(n >> (j * 8 + 4)) & 0x0F] + hex_chr[(n >> (j * 8)) & 0x0F];\n        }\n        return s;\n    }\n\n    function hex(x) {\n        var i;\n        for (i = 0; i < x.length; i += 1) {\n            x[i] = rhex(x[i]);\n        }\n        return x.join('');\n    }\n\n    // In some cases the fast add32 function cannot be used..\n    if (hex(md51('hello')) !== '5d41402abc4b2a76b9719d911017c592') {\n        add32 = function (x, y) {\n            var lsw = (x & 0xFFFF) + (y & 0xFFFF),\n                msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n            return (msw << 16) | (lsw & 0xFFFF);\n        };\n    }\n\n    // ---------------------------------------------------\n\n    /**\n     * ArrayBuffer slice polyfill.\n     *\n     * @see https://github.com/ttaubert/node-arraybuffer-slice\n     */\n\n    if (typeof ArrayBuffer !== 'undefined' && !ArrayBuffer.prototype.slice) {\n        (function () {\n            function clamp(val, length) {\n                val = (val | 0) || 0;\n\n                if (val < 0) {\n                    return Math.max(val + length, 0);\n                }\n\n                return Math.min(val, length);\n            }\n\n            ArrayBuffer.prototype.slice = function (from, to) {\n                var length = this.byteLength,\n                    begin = clamp(from, length),\n                    end = length,\n                    num,\n                    target,\n                    targetArray,\n                    sourceArray;\n\n                if (to !== undefined) {\n                    end = clamp(to, length);\n                }\n\n                if (begin > end) {\n                    return new ArrayBuffer(0);\n                }\n\n                num = end - begin;\n                target = new ArrayBuffer(num);\n                targetArray = new Uint8Array(target);\n\n                sourceArray = new Uint8Array(this, begin, num);\n                targetArray.set(sourceArray);\n\n                return target;\n            };\n        })();\n    }\n\n    // ---------------------------------------------------\n\n    /**\n     * Helpers.\n     */\n\n    function toUtf8(str) {\n        if (/[\\u0080-\\uFFFF]/.test(str)) {\n            str = unescape(encodeURIComponent(str));\n        }\n\n        return str;\n    }\n\n    function utf8Str2ArrayBuffer(str, returnUInt8Array) {\n        var length = str.length,\n           buff = new ArrayBuffer(length),\n           arr = new Uint8Array(buff),\n           i;\n\n        for (i = 0; i < length; i += 1) {\n            arr[i] = str.charCodeAt(i);\n        }\n\n        return returnUInt8Array ? arr : buff;\n    }\n\n    function arrayBuffer2Utf8Str(buff) {\n        return String.fromCharCode.apply(null, new Uint8Array(buff));\n    }\n\n    function concatenateArrayBuffers(first, second, returnUInt8Array) {\n        var result = new Uint8Array(first.byteLength + second.byteLength);\n\n        result.set(new Uint8Array(first));\n        result.set(new Uint8Array(second), first.byteLength);\n\n        return returnUInt8Array ? result : result.buffer;\n    }\n\n    function hexToBinaryString(hex) {\n        var bytes = [],\n            length = hex.length,\n            x;\n\n        for (x = 0; x < length - 1; x += 2) {\n            bytes.push(parseInt(hex.substr(x, 2), 16));\n        }\n\n        return String.fromCharCode.apply(String, bytes);\n    }\n\n    // ---------------------------------------------------\n\n    /**\n     * SparkMD5 OOP implementation.\n     *\n     * Use this class to perform an incremental md5, otherwise use the\n     * static methods instead.\n     */\n\n    function SparkMD5() {\n        // call reset to init the instance\n        this.reset();\n    }\n\n    /**\n     * Appends a string.\n     * A conversion will be applied if an utf8 string is detected.\n     *\n     * @param {String} str The string to be appended\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.append = function (str) {\n        // Converts the string to utf8 bytes if necessary\n        // Then append as binary\n        this.appendBinary(toUtf8(str));\n\n        return this;\n    };\n\n    /**\n     * Appends a binary string.\n     *\n     * @param {String} contents The binary string to be appended\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.appendBinary = function (contents) {\n        this._buff += contents;\n        this._length += contents.length;\n\n        var length = this._buff.length,\n            i;\n\n        for (i = 64; i <= length; i += 64) {\n            md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));\n        }\n\n        this._buff = this._buff.substring(i - 64);\n\n        return this;\n    };\n\n    /**\n     * Finishes the incremental computation, reseting the internal state and\n     * returning the result.\n     *\n     * @param {Boolean} raw True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.prototype.end = function (raw) {\n        var buff = this._buff,\n            length = buff.length,\n            i,\n            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            ret;\n\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= buff.charCodeAt(i) << ((i % 4) << 3);\n        }\n\n        this._finish(tail, length);\n        ret = hex(this._hash);\n\n        if (raw) {\n            ret = hexToBinaryString(ret);\n        }\n\n        this.reset();\n\n        return ret;\n    };\n\n    /**\n     * Resets the internal state of the computation.\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.reset = function () {\n        this._buff = '';\n        this._length = 0;\n        this._hash = [1732584193, -271733879, -1732584194, 271733878];\n\n        return this;\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @return {Object} The state\n     */\n    SparkMD5.prototype.getState = function () {\n        return {\n            buff: this._buff,\n            length: this._length,\n            hash: this._hash\n        };\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @param {Object} state The state\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.setState = function (state) {\n        this._buff = state.buff;\n        this._length = state.length;\n        this._hash = state.hash;\n\n        return this;\n    };\n\n    /**\n     * Releases memory used by the incremental buffer and other additional\n     * resources. If you plan to use the instance again, use reset instead.\n     */\n    SparkMD5.prototype.destroy = function () {\n        delete this._hash;\n        delete this._buff;\n        delete this._length;\n    };\n\n    /**\n     * Finish the final calculation based on the tail.\n     *\n     * @param {Array}  tail   The tail (will be modified)\n     * @param {Number} length The length of the remaining buffer\n     */\n    SparkMD5.prototype._finish = function (tail, length) {\n        var i = length,\n            tmp,\n            lo,\n            hi;\n\n        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n        if (i > 55) {\n            md5cycle(this._hash, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Do the final computation based on the tail and length\n        // Beware that the final length may not fit in 32 bits so we take care of that\n        tmp = this._length * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n        md5cycle(this._hash, tail);\n    };\n\n    /**\n     * Performs the md5 hash on a string.\n     * A conversion will be applied if utf8 string is detected.\n     *\n     * @param {String}  str The string\n     * @param {Boolean} raw True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.hash = function (str, raw) {\n        // Converts the string to utf8 bytes if necessary\n        // Then compute it using the binary function\n        return SparkMD5.hashBinary(toUtf8(str), raw);\n    };\n\n    /**\n     * Performs the md5 hash on a binary string.\n     *\n     * @param {String}  content The binary string\n     * @param {Boolean} raw     True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.hashBinary = function (content, raw) {\n        var hash = md51(content),\n            ret = hex(hash);\n\n        return raw ? hexToBinaryString(ret) : ret;\n    };\n\n    // ---------------------------------------------------\n\n    /**\n     * SparkMD5 OOP implementation for array buffers.\n     *\n     * Use this class to perform an incremental md5 ONLY for array buffers.\n     */\n    SparkMD5.ArrayBuffer = function () {\n        // call reset to init the instance\n        this.reset();\n    };\n\n    /**\n     * Appends an array buffer.\n     *\n     * @param {ArrayBuffer} arr The array to be appended\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.append = function (arr) {\n        var buff = concatenateArrayBuffers(this._buff.buffer, arr, true),\n            length = buff.length,\n            i;\n\n        this._length += arr.byteLength;\n\n        for (i = 64; i <= length; i += 64) {\n            md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));\n        }\n\n        this._buff = (i - 64) < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);\n\n        return this;\n    };\n\n    /**\n     * Finishes the incremental computation, reseting the internal state and\n     * returning the result.\n     *\n     * @param {Boolean} raw True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.ArrayBuffer.prototype.end = function (raw) {\n        var buff = this._buff,\n            length = buff.length,\n            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            i,\n            ret;\n\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= buff[i] << ((i % 4) << 3);\n        }\n\n        this._finish(tail, length);\n        ret = hex(this._hash);\n\n        if (raw) {\n            ret = hexToBinaryString(ret);\n        }\n\n        this.reset();\n\n        return ret;\n    };\n\n    /**\n     * Resets the internal state of the computation.\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.reset = function () {\n        this._buff = new Uint8Array(0);\n        this._length = 0;\n        this._hash = [1732584193, -271733879, -1732584194, 271733878];\n\n        return this;\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @return {Object} The state\n     */\n    SparkMD5.ArrayBuffer.prototype.getState = function () {\n        var state = SparkMD5.prototype.getState.call(this);\n\n        // Convert buffer to a string\n        state.buff = arrayBuffer2Utf8Str(state.buff);\n\n        return state;\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @param {Object} state The state\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.setState = function (state) {\n        // Convert string to buffer\n        state.buff = utf8Str2ArrayBuffer(state.buff, true);\n\n        return SparkMD5.prototype.setState.call(this, state);\n    };\n\n    SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;\n\n    SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;\n\n    /**\n     * Performs the md5 hash on an array buffer.\n     *\n     * @param {ArrayBuffer} arr The array buffer\n     * @param {Boolean}     raw True to get the raw string, false to get the hex one\n     *\n     * @return {String} The result\n     */\n    SparkMD5.ArrayBuffer.hash = function (arr, raw) {\n        var hash = md51_array(new Uint8Array(arr)),\n            ret = hex(hash);\n\n        return raw ? hexToBinaryString(ret) : ret;\n    };\n\n    return SparkMD5;\n}));\n","var v1 = require('./v1');\nvar v4 = require('./v4');\n\nvar uuid = v4;\nuuid.v1 = v1;\nuuid.v4 = v4;\n\nmodule.exports = uuid;\n","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nvar _nodeId;\nvar _clockseq;\n\n// Previous uuid creation time\nvar _lastMSecs = 0;\nvar _lastNSecs = 0;\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n  var node = options.node || _nodeId;\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n  if (node == null || clockseq == null) {\n    var seedBytes = rng();\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [\n        seedBytes[0] | 0x01,\n        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]\n      ];\n    }\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  }\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : bytesToUuid(b);\n}\n\nmodule.exports = v1;\n","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n","'use strict';\n\n/**\n * Stringify/parse functions that don't operate\n * recursively, so they avoid call stack exceeded\n * errors.\n */\nexports.stringify = function stringify(input) {\n  var queue = [];\n  queue.push({obj: input});\n\n  var res = '';\n  var next, obj, prefix, val, i, arrayPrefix, keys, k, key, value, objPrefix;\n  while ((next = queue.pop())) {\n    obj = next.obj;\n    prefix = next.prefix || '';\n    val = next.val || '';\n    res += prefix;\n    if (val) {\n      res += val;\n    } else if (typeof obj !== 'object') {\n      res += typeof obj === 'undefined' ? null : JSON.stringify(obj);\n    } else if (obj === null) {\n      res += 'null';\n    } else if (Array.isArray(obj)) {\n      queue.push({val: ']'});\n      for (i = obj.length - 1; i >= 0; i--) {\n        arrayPrefix = i === 0 ? '' : ',';\n        queue.push({obj: obj[i], prefix: arrayPrefix});\n      }\n      queue.push({val: '['});\n    } else { // object\n      keys = [];\n      for (k in obj) {\n        if (obj.hasOwnProperty(k)) {\n          keys.push(k);\n        }\n      }\n      queue.push({val: '}'});\n      for (i = keys.length - 1; i >= 0; i--) {\n        key = keys[i];\n        value = obj[key];\n        objPrefix = (i > 0 ? ',' : '');\n        objPrefix += JSON.stringify(key) + ':';\n        queue.push({obj: value, prefix: objPrefix});\n      }\n      queue.push({val: '{'});\n    }\n  }\n  return res;\n};\n\n// Convenience function for the parse function.\n// This pop function is basically copied from\n// pouchCollate.parseIndexableString\nfunction pop(obj, stack, metaStack) {\n  var lastMetaElement = metaStack[metaStack.length - 1];\n  if (obj === lastMetaElement.element) {\n    // popping a meta-element, e.g. an object whose value is another object\n    metaStack.pop();\n    lastMetaElement = metaStack[metaStack.length - 1];\n  }\n  var element = lastMetaElement.element;\n  var lastElementIndex = lastMetaElement.index;\n  if (Array.isArray(element)) {\n    element.push(obj);\n  } else if (lastElementIndex === stack.length - 2) { // obj with key+value\n    var key = stack.pop();\n    element[key] = obj;\n  } else {\n    stack.push(obj); // obj with key only\n  }\n}\n\nexports.parse = function (str) {\n  var stack = [];\n  var metaStack = []; // stack for arrays and objects\n  var i = 0;\n  var collationIndex,parsedNum,numChar;\n  var parsedString,lastCh,numConsecutiveSlashes,ch;\n  var arrayElement, objElement;\n  while (true) {\n    collationIndex = str[i++];\n    if (collationIndex === '}' ||\n        collationIndex === ']' ||\n        typeof collationIndex === 'undefined') {\n      if (stack.length === 1) {\n        return stack.pop();\n      } else {\n        pop(stack.pop(), stack, metaStack);\n        continue;\n      }\n    }\n    switch (collationIndex) {\n      case ' ':\n      case '\\t':\n      case '\\n':\n      case ':':\n      case ',':\n        break;\n      case 'n':\n        i += 3; // 'ull'\n        pop(null, stack, metaStack);\n        break;\n      case 't':\n        i += 3; // 'rue'\n        pop(true, stack, metaStack);\n        break;\n      case 'f':\n        i += 4; // 'alse'\n        pop(false, stack, metaStack);\n        break;\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n      case '-':\n        parsedNum = '';\n        i--;\n        while (true) {\n          numChar = str[i++];\n          if (/[\\d\\.\\-e\\+]/.test(numChar)) {\n            parsedNum += numChar;\n          } else {\n            i--;\n            break;\n          }\n        }\n        pop(parseFloat(parsedNum), stack, metaStack);\n        break;\n      case '\"':\n        parsedString = '';\n        lastCh = void 0;\n        numConsecutiveSlashes = 0;\n        while (true) {\n          ch = str[i++];\n          if (ch !== '\"' || (lastCh === '\\\\' &&\n              numConsecutiveSlashes % 2 === 1)) {\n            parsedString += ch;\n            lastCh = ch;\n            if (lastCh === '\\\\') {\n              numConsecutiveSlashes++;\n            } else {\n              numConsecutiveSlashes = 0;\n            }\n          } else {\n            break;\n          }\n        }\n        pop(JSON.parse('\"' + parsedString + '\"'), stack, metaStack);\n        break;\n      case '[':\n        arrayElement = { element: [], index: stack.length };\n        stack.push(arrayElement.element);\n        metaStack.push(arrayElement);\n        break;\n      case '{':\n        objElement = { element: {}, index: stack.length };\n        stack.push(objElement.element);\n        metaStack.push(objElement);\n        break;\n      default:\n        throw new Error(\n          'unexpectedly reached end of input: ' + collationIndex);\n    }\n  }\n};\n","module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}"],"sourceRoot":""}